/*!
 * Name: @alipay/tiny
 * Description: The Tiny engine is an HTML5 game engine designed to be lightweight and concise JavaScript-friendly syntax, it will only for mobile.
 * Author: yiqi
 * Version: v0.2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Tiny"] = factory();
	else
		root["Tiny"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Loader = exports.audioManager = exports.audio = exports.particles = exports.loaders = exports.interaction = exports.extract = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	// export libs


	var _polyfill = __webpack_require__(1);

	Object.keys(_polyfill).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _polyfill[key];
	    }
	  });
	});

	var _core = __webpack_require__(6);

	Object.keys(_core).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _core[key];
	    }
	  });
	});

	var _extras = __webpack_require__(142);

	Object.keys(_extras).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _extras[key];
	    }
	  });
	});

	var _actions = __webpack_require__(123);

	Object.keys(_actions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _actions[key];
	    }
	  });
	});

	var _scroller = __webpack_require__(148);

	Object.keys(_scroller).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _scroller[key];
	    }
	  });
	});

	var _extract = __webpack_require__(157);

	var extract = _interopRequireWildcard(_extract);

	var _interaction = __webpack_require__(124);

	var interaction = _interopRequireWildcard(_interaction);

	var _loaders = __webpack_require__(129);

	var loaders = _interopRequireWildcard(_loaders);

	var _particles = __webpack_require__(160);

	var particles = _interopRequireWildcard(_particles);

	var _audio = __webpack_require__(165);

	var _audio2 = _interopRequireDefault(_audio);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.extract = extract;
	exports.interaction = interaction;
	exports.loaders = loaders;
	exports.particles = particles;

	/**
	 * audio
	 */

	var loader = loaders.Loader;
	loader.addTinyMiddleware(_audio2.default.audioParser);

	var baseAdd = loader.prototype.add;
	loader.prototype.add = function (name, url, options, cb) {
	  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	    if (Object.prototype.toString.call(name.url) === '[object Array]') {
	      name.url = _audio2.default.audioUrlParser(name.url);
	    }
	  }

	  if (Object.prototype.toString.call(url) === '[object Array]') {
	    url = _audio2.default.audioUrlParser(url);
	  }

	  return baseAdd.call(this, name, url, options, cb);
	};

	var audioManager = new _audio2.default.AudioManager();
	exports.audio = _audio2.default;
	exports.audioManager = audioManager;

	/**
	 * A premade instance of the loader that can be used to load resources.
	 *
	 * @example
	 *
	 * var resources = [..];
	 * Tiny.Loader.run({
	 *   resources: resources,
	 *   onProgress: function (pre) {
	 *     console.log("percent:", pre + "%");
	 *   },
	 *   onAllComplete: function () {
	 *     console.log('all complete');
	 *     Tiny.app.run(new MenuLayer());
	 *   }
	 * });
	 *
	 * @name Loader
	 * @memberof Tiny
	 * @property {Tiny.loaders.Loader}
	 */

	var Loader = loaders && loaders.Loader ? new loaders.Loader() : null; // check is there in case user excludes loader lib

	exports.Loader = Loader;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(2);

	__webpack_require__(4);

	__webpack_require__(5);

	if (!window.ArrayBuffer) {
	  window.ArrayBuffer = Array;
	}

	if (!window.Float32Array) {
	  window.Float32Array = Array;
	}

	if (!window.Uint32Array) {
	  window.Uint32Array = Array;
	}

	if (!window.Uint16Array) {
	  window.Uint16Array = Array;
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _objectAssign = __webpack_require__(3);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	if (!Object.assign) {
	  Object.assign = _objectAssign2.default;
	} // References:
	// https://github.com/sindresorhus/object-assign
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */

	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// References:
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// https://gist.github.com/1579671
	// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
	// https://gist.github.com/timhall/4078614
	// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

	// Expected to be used with Browserfiy
	// Browserify automatically detects the use of `global` and passes the
	// correct reference of `global`, `self`, and finally `window`

	var ONE_FRAME_TIME = 16;

	// Date.now
	if (!(Date.now && Date.prototype.getTime)) {
	  Date.now = function now() {
	    return new Date().getTime();
	  };
	}

	// performance.now
	if (!(global.performance && global.performance.now)) {
	  var startTime = Date.now();

	  if (!global.performance) {
	    global.performance = {};
	  }

	  global.performance.now = function () {
	    return Date.now() - startTime;
	  };
	}

	// requestAnimationFrame
	var lastTime = Date.now();
	var vendors = ['ms', 'moz', 'webkit', 'o'];

	for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
	  var p = vendors[x];

	  global.requestAnimationFrame = global[p + 'RequestAnimationFrame'];
	  global.cancelAnimationFrame = global[p + 'CancelAnimationFrame'] || global[p + 'CancelRequestAnimationFrame'];
	}

	if (!global.requestAnimationFrame) {
	  global.requestAnimationFrame = function (callback) {
	    if (typeof callback !== 'function') {
	      throw new TypeError(callback + 'is not a function');
	    }

	    var currentTime = Date.now();
	    var delay = ONE_FRAME_TIME + lastTime - currentTime;

	    if (delay < 0) {
	      delay = 0;
	    }

	    lastTime = currentTime;

	    return setTimeout(function () {
	      lastTime = Date.now();
	      callback(performance.now());
	    }, delay);
	  };
	}

	if (!global.cancelAnimationFrame) {
	  global.cancelAnimationFrame = function (id) {
	    return clearTimeout(id);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	"use strict";

	// References:
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	if (!Math.sign) {
	  Math.sign = function mathSign(x) {
	    x = Number(x);

	    if (x === 0 || isNaN(x)) {
	      return x;
	    }

	    return x > 0 ? 1 : -1;
	  };
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Application = exports.Filter = exports.SpriteMaskFilter = exports.Quad = exports.RenderTarget = exports.ObjectRenderer = exports.WebGLManager = exports.Shader = exports.CanvasRenderTarget = exports.TextureUvs = exports.VideoBaseTexture = exports.BaseRenderTexture = exports.RenderTexture = exports.BaseTexture = exports.Texture = exports.CanvasGraphicsRenderer = exports.GraphicsRenderer = exports.GraphicsData = exports.Graphics = exports.TextStyle = exports.Text = exports.SpriteRenderer = exports.CanvasTinter = exports.CanvasSpriteRenderer = exports.AnimatedSprite = exports.Sprite = exports.TransformBase = exports.TransformStatic = exports.Transform = exports.Container = exports.DisplayObject = exports.Bounds = exports.glCore = exports.WebGLRenderer = exports.CanvasRenderer = exports.ticker = undefined;

	var _const = __webpack_require__(7);

	Object.keys(_const).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _const[key];
	    }
	  });
	});

	var _math = __webpack_require__(8);

	Object.keys(_math).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _math[key];
	    }
	  });
	});

	var _utils = __webpack_require__(18);

	Object.keys(_utils).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _utils[key];
	    }
	  });
	});

	var _settings = __webpack_require__(20);

	Object.keys(_settings).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _settings[key];
	    }
	  });
	});

	var _pixiGlCore = __webpack_require__(28);

	Object.defineProperty(exports, 'glCore', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_pixiGlCore).default;
	  }
	});

	var _Bounds = __webpack_require__(45);

	Object.defineProperty(exports, 'Bounds', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Bounds).default;
	  }
	});

	var _DisplayObject = __webpack_require__(46);

	Object.defineProperty(exports, 'DisplayObject', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DisplayObject).default;
	  }
	});

	var _Container = __webpack_require__(50);

	Object.defineProperty(exports, 'Container', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Container).default;
	  }
	});

	var _Transform = __webpack_require__(49);

	Object.defineProperty(exports, 'Transform', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Transform).default;
	  }
	});

	var _TransformStatic = __webpack_require__(47);

	Object.defineProperty(exports, 'TransformStatic', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TransformStatic).default;
	  }
	});

	var _TransformBase = __webpack_require__(48);

	Object.defineProperty(exports, 'TransformBase', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TransformBase).default;
	  }
	});

	var _Sprite = __webpack_require__(51);

	Object.defineProperty(exports, 'Sprite', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Sprite).default;
	  }
	});

	var _AnimatedSprite = __webpack_require__(68);

	Object.defineProperty(exports, 'AnimatedSprite', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_AnimatedSprite).default;
	  }
	});

	var _CanvasSpriteRenderer = __webpack_require__(69);

	Object.defineProperty(exports, 'CanvasSpriteRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CanvasSpriteRenderer).default;
	  }
	});

	var _CanvasTinter = __webpack_require__(78);

	Object.defineProperty(exports, 'CanvasTinter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CanvasTinter).default;
	  }
	});

	var _SpriteRenderer = __webpack_require__(79);

	Object.defineProperty(exports, 'SpriteRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_SpriteRenderer).default;
	  }
	});

	var _Text = __webpack_require__(104);

	Object.defineProperty(exports, 'Text', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Text).default;
	  }
	});

	var _TextStyle = __webpack_require__(105);

	Object.defineProperty(exports, 'TextStyle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TextStyle).default;
	  }
	});

	var _Graphics = __webpack_require__(106);

	Object.defineProperty(exports, 'Graphics', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Graphics).default;
	  }
	});

	var _GraphicsData = __webpack_require__(107);

	Object.defineProperty(exports, 'GraphicsData', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_GraphicsData).default;
	  }
	});

	var _GraphicsRenderer = __webpack_require__(109);

	Object.defineProperty(exports, 'GraphicsRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_GraphicsRenderer).default;
	  }
	});

	var _CanvasGraphicsRenderer = __webpack_require__(118);

	Object.defineProperty(exports, 'CanvasGraphicsRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CanvasGraphicsRenderer).default;
	  }
	});

	var _Texture = __webpack_require__(52);

	Object.defineProperty(exports, 'Texture', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Texture).default;
	  }
	});

	var _BaseTexture = __webpack_require__(53);

	Object.defineProperty(exports, 'BaseTexture', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BaseTexture).default;
	  }
	});

	var _RenderTexture = __webpack_require__(72);

	Object.defineProperty(exports, 'RenderTexture', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_RenderTexture).default;
	  }
	});

	var _BaseRenderTexture = __webpack_require__(73);

	Object.defineProperty(exports, 'BaseRenderTexture', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BaseRenderTexture).default;
	  }
	});

	var _VideoBaseTexture = __webpack_require__(64);

	Object.defineProperty(exports, 'VideoBaseTexture', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_VideoBaseTexture).default;
	  }
	});

	var _TextureUvs = __webpack_require__(67);

	Object.defineProperty(exports, 'TextureUvs', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TextureUvs).default;
	  }
	});

	var _CanvasRenderTarget = __webpack_require__(75);

	Object.defineProperty(exports, 'CanvasRenderTarget', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CanvasRenderTarget).default;
	  }
	});

	var _Shader = __webpack_require__(93);

	Object.defineProperty(exports, 'Shader', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Shader).default;
	  }
	});

	var _WebGLManager = __webpack_require__(81);

	Object.defineProperty(exports, 'WebGLManager', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_WebGLManager).default;
	  }
	});

	var _ObjectRenderer = __webpack_require__(80);

	Object.defineProperty(exports, 'ObjectRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ObjectRenderer).default;
	  }
	});

	var _RenderTarget = __webpack_require__(90);

	Object.defineProperty(exports, 'RenderTarget', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_RenderTarget).default;
	  }
	});

	var _Quad = __webpack_require__(91);

	Object.defineProperty(exports, 'Quad', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Quad).default;
	  }
	});

	var _SpriteMaskFilter = __webpack_require__(84);

	Object.defineProperty(exports, 'SpriteMaskFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_SpriteMaskFilter).default;
	  }
	});

	var _Filter = __webpack_require__(85);

	Object.defineProperty(exports, 'Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Filter).default;
	  }
	});

	var _Application = __webpack_require__(119);

	Object.defineProperty(exports, 'Application', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Application).default;
	  }
	});

	var _ticker = __webpack_require__(65);

	var ticker = _interopRequireWildcard(_ticker);

	var _CanvasRenderer = __webpack_require__(70);

	var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

	var _WebGLRenderer = __webpack_require__(82);

	var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.ticker = ticker;
	exports.CanvasRenderer = _CanvasRenderer2.default;
	exports.WebGLRenderer = _WebGLRenderer2.default; /**
	                                                  * @namespace Tiny
	                                                  */

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * String of the current Tiny version.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name VERSION
	 * @type {string}
	 */
	var VERSION = exports.VERSION = '0.2.0';

	/**
	 * Math.PI * 2
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name PI_2
	 * @type {number}
	 */
	var PI_2 = exports.PI_2 = Math.PI * 2;

	/**
	 * Constant conversion factor for converting radians to degrees
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name RAD_TO_DEG
	 * @type {number}
	 */
	var RAD_TO_DEG = exports.RAD_TO_DEG = 180 / Math.PI;

	/**
	 * Constant conversion factor for converting degrees to radians
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name DEG_TO_RAD
	 * @type {number}
	 */
	var DEG_TO_RAD = exports.DEG_TO_RAD = Math.PI / 180;

	/**
	 * Constant to identify the Renderer Type.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name RENDERER_TYPE
	 * @type {object}
	 * @property {number} UNKNOWN - Unknown render type.
	 * @property {number} WEBGL - WebGL render type.
	 * @property {number} CANVAS - Canvas render type.
	 */
	var RENDERER_TYPE = exports.RENDERER_TYPE = {
	  UNKNOWN: 0,
	  WEBGL: 1,
	  CANVAS: 2
	};

	/**
	 * Various blend modes supported by Tiny.
	 * <br>
	 * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
	 * Anything else will silently act like NORMAL.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name BLEND_MODES
	 * @type {object}
	 * @property {number} NORMAL
	 * @property {number} ADD
	 * @property {number} MULTIPLY
	 * @property {number} SCREEN
	 * @property {number} OVERLAY
	 * @property {number} DARKEN
	 * @property {number} LIGHTEN
	 * @property {number} COLOR_DODGE
	 * @property {number} COLOR_BURN
	 * @property {number} HARD_LIGHT
	 * @property {number} SOFT_LIGHT
	 * @property {number} DIFFERENCE
	 * @property {number} EXCLUSION
	 * @property {number} HUE
	 * @property {number} SATURATION
	 * @property {number} COLOR
	 * @property {number} LUMINOSITY
	 */
	var BLEND_MODES = exports.BLEND_MODES = {
	  NORMAL: 0,
	  ADD: 1,
	  MULTIPLY: 2,
	  SCREEN: 3,
	  OVERLAY: 4,
	  DARKEN: 5,
	  LIGHTEN: 6,
	  COLOR_DODGE: 7,
	  COLOR_BURN: 8,
	  HARD_LIGHT: 9,
	  SOFT_LIGHT: 10,
	  DIFFERENCE: 11,
	  EXCLUSION: 12,
	  HUE: 13,
	  SATURATION: 14,
	  COLOR: 15,
	  LUMINOSITY: 16
	};

	/**
	 * Various webgl draw modes. These can be used to specify which GL drawMode to use
	 * under certain situations and renderers.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name DRAW_MODES
	 * @type {object}
	 * @property {number} POINTS
	 * @property {number} LINES
	 * @property {number} LINE_LOOP
	 * @property {number} LINE_STRIP
	 * @property {number} TRIANGLES
	 * @property {number} TRIANGLE_STRIP
	 * @property {number} TRIANGLE_FAN
	 */
	var DRAW_MODES = exports.DRAW_MODES = {
	  POINTS: 0,
	  LINES: 1,
	  LINE_LOOP: 2,
	  LINE_STRIP: 3,
	  TRIANGLES: 4,
	  TRIANGLE_STRIP: 5,
	  TRIANGLE_FAN: 6
	};

	/**
	 * The scale modes that are supported by Tiny.
	 *
	 * The {@link Tiny.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
	 * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @name SCALE_MODES
	 * @type {object}
	 * @property {number} LINEAR Smooth scaling
	 * @property {number} NEAREST Pixelating scaling
	 */
	var SCALE_MODES = exports.SCALE_MODES = {
	  LINEAR: 0,
	  NEAREST: 1
	};

	/**
	 * The wrap modes that are supported by Tiny.
	 *
	 * The {@link Tiny.settings.WRAP_MODE} wrap mode affects the default wraping mode of future operations.
	 * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
	 * If the texture is non power of two then clamp will be used regardless as webGL can
	 * only use REPEAT if the texture is po2.
	 *
	 * This property only affects WebGL.
	 *
	 * @static
	 * @constant
	 * @name WRAP_MODES
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} CLAMP - The textures uvs are clamped
	 * @property {number} REPEAT - The texture uvs tile and repeat
	 * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
	 */
	var WRAP_MODES = exports.WRAP_MODES = {
	  CLAMP: 0,
	  REPEAT: 1,
	  MIRRORED_REPEAT: 2
	};

	/**
	 * The gc modes that are supported by Tiny.
	 *
	 * The {@link Tiny.settings.GC_MODE} Garbage Collection mode for Tiny textures is AUTO
	 * If set to GC_MODE, the renderer will occasianally check textures usage. If they are not
	 * used for a specified period of time they will be removed from the GPU. They will of course
	 * be uploaded again when they are required. This is a silent behind the scenes process that
	 * should ensure that the GPU does not  get filled up.
	 *
	 * Handy for mobile devices!
	 * This property only affects WebGL.
	 *
	 * @static
	 * @constant
	 * @name GC_MODES
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} AUTO - Garbage collection will happen periodically automatically
	 * @property {number} MANUAL - Garbage collection will need to be called manually
	 */
	var GC_MODES = exports.GC_MODES = {
	  AUTO: 0,
	  MANUAL: 1
	};

	/**
	 * Regexp for image type by extension.
	 *
	 * @static
	 * @constant
	 * @memberof Tiny
	 * @type {RegExp|string}
	 * @example `image.png`
	 */
	var URL_FILE_EXTENSION = exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i;

	/**
	 * Regexp for data URI.
	 * Based on: {@link https://github.com/ragingwind/data-uri-regex}
	 *
	 * @static
	 * @constant
	 * @name DATA_URI
	 * @memberof Tiny
	 * @type {RegExp|string}
	 * @example data:image/png;base64
	 */
	var DATA_URI = exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;(charset=[\w-]+|base64))?,(.*)/i;

	/**
	 * Regexp for SVG size.
	 *
	 * @static
	 * @constant
	 * @name SVG_SIZE
	 * @memberof Tiny
	 * @type {RegExp|string}
	 * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
	 */
	var SVG_SIZE = exports.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;

	/**
	 * Constants that identify shapes, mainly to prevent `instanceof` calls.
	 *
	 * @static
	 * @constant
	 * @name SHAPES
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} POLY Polygon
	 * @property {number} RECT Rectangle
	 * @property {number} CIRC Circle
	 * @property {number} ELIP Ellipse
	 * @property {number} RREC Rounded Rectangle
	 */
	var SHAPES = exports.SHAPES = {
	  POLY: 0,
	  RECT: 1,
	  CIRC: 2,
	  ELIP: 3,
	  RREC: 4
	};

	/**
	 * Constants that specify float precision in shaders.
	 *
	 * @static
	 * @constant
	 * @name PRECISION
	 * @memberof Tiny
	 * @type {object}
	 * @property {string} LOW='lowp'
	 * @property {string} MEDIUM='mediump'
	 * @property {string} HIGH='highp'
	 */
	var PRECISION = exports.PRECISION = {
	  LOW: 'lowp',
	  MEDIUM: 'mediump',
	  HIGH: 'highp'
	};

	/**
	 * Constants that specify the transform type.
	 *
	 * @static
	 * @constant
	 * @name TRANSFORM_MODE
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} STATIC
	 * @property {number} DYNAMIC
	 */
	var TRANSFORM_MODE = exports.TRANSFORM_MODE = {
	  STATIC: 0,
	  DYNAMIC: 1
	};

	/**
	 * Constants that define the type of gradient on text.
	 *
	 * @static
	 * @constant
	 * @name TEXT_GRADIENT
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} LINEAR_VERTICAL Vertical gradient
	 * @property {number} LINEAR_HORIZONTAL Linear gradient
	 */
	var TEXT_GRADIENT = exports.TEXT_GRADIENT = {
	  LINEAR_VERTICAL: 0,
	  LINEAR_HORIZONTAL: 1
	};

	/**
	 * 主界面尺寸
	 *
	 * @static
	 * @constant
	 * @name WIN_SIZE
	 * @memberof Tiny
	 * @type {object}
	 * @property {number} width   宽
	 * @property {number} height  高
	 */
	var WIN_SIZE = exports.WIN_SIZE = {
	  width: 0,
	  height: 0
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Point = __webpack_require__(9);

	Object.defineProperty(exports, 'Point', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Point).default;
	  }
	});

	var _ObservablePoint = __webpack_require__(10);

	Object.defineProperty(exports, 'ObservablePoint', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ObservablePoint).default;
	  }
	});

	var _Matrix = __webpack_require__(11);

	Object.defineProperty(exports, 'Matrix', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Matrix).default;
	  }
	});

	var _GroupD = __webpack_require__(12);

	Object.defineProperty(exports, 'GroupD8', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_GroupD).default;
	  }
	});

	var _Circle = __webpack_require__(13);

	Object.defineProperty(exports, 'Circle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Circle).default;
	  }
	});

	var _Ellipse = __webpack_require__(15);

	Object.defineProperty(exports, 'Ellipse', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Ellipse).default;
	  }
	});

	var _Polygon = __webpack_require__(16);

	Object.defineProperty(exports, 'Polygon', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Polygon).default;
	  }
	});

	var _Rectangle = __webpack_require__(14);

	Object.defineProperty(exports, 'Rectangle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Rectangle).default;
	  }
	});

	var _RoundedRectangle = __webpack_require__(17);

	Object.defineProperty(exports, 'RoundedRectangle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_RoundedRectangle).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The Point object represents a location in a two-dimensional coordinate system, where x represents
	 * the horizontal axis and y represents the vertical axis.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Point = function () {
	  /**
	   * @param {number} [x=0] - position of the point on the x axis
	   * @param {number} [y=0] - position of the point on the y axis
	   */
	  function Point() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    _classCallCheck(this, Point);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y;
	  }

	  /**
	   * Creates a clone of this point
	   *
	   * @return {Tiny.Point} a copy of the point
	   */


	  _createClass(Point, [{
	    key: "clone",
	    value: function clone() {
	      return new Point(this.x, this.y);
	    }

	    /**
	     * Copies x and y from the given point
	     *
	     * @param {Tiny.Point} p - The point to copy.
	     */

	  }, {
	    key: "copy",
	    value: function copy(p) {
	      this.set(p.x, p.y);
	    }

	    /**
	     * Returns true if the given point is equal to this point
	     *
	     * @param {Tiny.Point} p - The point to check
	     * @return {boolean} Whether the given point equal to this point
	     */

	  }, {
	    key: "equals",
	    value: function equals(p) {
	      return p.x === this.x && p.y === this.y;
	    }

	    /**
	     * Sets the point to a new x and y position.
	     * If y is omitted, both x and y will be set to x.
	     *
	     * @param {number} [x=0] - position of the point on the x axis
	     * @param {number} [y=0] - position of the point on the y axis
	     */

	  }, {
	    key: "set",
	    value: function set(x, y) {
	      this.x = x || 0;
	      this.y = y || (y !== 0 ? this.x : 0);
	    }
	  }]);

	  return Point;
	}();

	exports.default = Point;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The Point object represents a location in a two-dimensional coordinate system, where x represents
	 * the horizontal axis and y represents the vertical axis.
	 * An observable point is a point that triggers a callback when the point's position is changed.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var ObservablePoint = function () {
	  /**
	   * @param {Function} cb - callback when changed
	   * @param {object} scope - owner of callback
	   * @param {number} [x=0] - position of the point on the x axis
	   * @param {number} [y=0] - position of the point on the y axis
	   */
	  function ObservablePoint(cb, scope) {
	    var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, ObservablePoint);

	    this._x = x;
	    this._y = y;

	    this.cb = cb;
	    this.scope = scope;
	  }

	  /**
	   * Sets the point to a new x and y position.
	   * If y is omitted, both x and y will be set to x.
	   *
	   * @param {number} [x=0] - position of the point on the x axis
	   * @param {number} [y=0] - position of the point on the y axis
	   */


	  _createClass(ObservablePoint, [{
	    key: "set",
	    value: function set(x, y) {
	      var _x = x || 0;
	      var _y = y || (y !== 0 ? _x : 0);

	      if (this._x !== _x || this._y !== _y) {
	        this._x = _x;
	        this._y = _y;
	        this.cb.call(this.scope);
	      }
	    }

	    /**
	     * Copies the data from another point
	     *
	     * @param {Tiny.Point|Tiny.ObservablePoint} point - point to copy from
	     */

	  }, {
	    key: "copy",
	    value: function copy(point) {
	      if (this._x !== point.x || this._y !== point.y) {
	        this._x = point.x;
	        this._y = point.y;
	        this.cb.call(this.scope);
	      }
	    }

	    /**
	     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
	     *
	     * @member {number}
	     */

	  }, {
	    key: "x",
	    get: function get() {
	      return this._x;
	    },
	    set: function set(value) {
	      if (this._x !== value) {
	        this._x = value;
	        this.cb.call(this.scope);
	      }
	    }

	    /**
	     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
	     *
	     * @member {number}
	     */

	  }, {
	    key: "y",
	    get: function get() {
	      return this._y;
	    },
	    set: function set(value) {
	      if (this._y !== value) {
	        this._y = value;
	        this.cb.call(this.scope);
	      }
	    }
	  }]);

	  return ObservablePoint;
	}();

	exports.default = ObservablePoint;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Point = __webpack_require__(9);

	var _Point2 = _interopRequireDefault(_Point);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The pixi Matrix class as an object, which makes it a lot faster,
	 * here is a representation of it :
	 * | a | b | tx|
	 * | c | d | ty|
	 * | 0 | 0 | 1 |
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Matrix = function () {
	  /**
	   *
	   */
	  function Matrix() {
	    _classCallCheck(this, Matrix);

	    /**
	     * @member {number}
	     * @default 1
	     */
	    this.a = 1;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.b = 0;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.c = 0;

	    /**
	     * @member {number}
	     * @default 1
	     */
	    this.d = 1;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.tx = 0;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.ty = 0;

	    this.array = null;
	  }

	  /**
	   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
	   *
	   * a = array[0]
	   * b = array[1]
	   * c = array[3]
	   * d = array[4]
	   * tx = array[2]
	   * ty = array[5]
	   *
	   * @param {number[]} array - The array that the matrix will be populated from.
	   */


	  _createClass(Matrix, [{
	    key: 'fromArray',
	    value: function fromArray(array) {
	      this.a = array[0];
	      this.b = array[1];
	      this.c = array[3];
	      this.d = array[4];
	      this.tx = array[2];
	      this.ty = array[5];
	    }

	    /**
	     * sets the matrix properties
	     *
	     * @param {number} a - Matrix component
	     * @param {number} b - Matrix component
	     * @param {number} c - Matrix component
	     * @param {number} d - Matrix component
	     * @param {number} tx - Matrix component
	     * @param {number} ty - Matrix component
	     *
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'set',
	    value: function set(a, b, c, d, tx, ty) {
	      this.a = a;
	      this.b = b;
	      this.c = c;
	      this.d = d;
	      this.tx = tx;
	      this.ty = ty;

	      return this;
	    }

	    /**
	     * Creates an array from the current Matrix object.
	     *
	     * @param {boolean} transpose - Whether we need to transpose the matrix or not
	     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
	     * @return {number[]} the newly created array which contains the matrix
	     */

	  }, {
	    key: 'toArray',
	    value: function toArray(transpose, out) {
	      if (!this.array) {
	        this.array = new Float32Array(9);
	      }

	      var array = out || this.array;

	      if (transpose) {
	        array[0] = this.a;
	        array[1] = this.b;
	        array[2] = 0;
	        array[3] = this.c;
	        array[4] = this.d;
	        array[5] = 0;
	        array[6] = this.tx;
	        array[7] = this.ty;
	        array[8] = 1;
	      } else {
	        array[0] = this.a;
	        array[1] = this.c;
	        array[2] = this.tx;
	        array[3] = this.b;
	        array[4] = this.d;
	        array[5] = this.ty;
	        array[6] = 0;
	        array[7] = 0;
	        array[8] = 1;
	      }

	      return array;
	    }

	    /**
	     * Get a new position with the current transformation applied.
	     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
	     *
	     * @param {Tiny.Point} pos - The origin
	     * @param {Tiny.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
	     * @return {Tiny.Point} The new point, transformed through this matrix
	     */

	  }, {
	    key: 'apply',
	    value: function apply(pos, newPos) {
	      newPos = newPos || new _Point2.default();

	      var x = pos.x;
	      var y = pos.y;

	      newPos.x = this.a * x + this.c * y + this.tx;
	      newPos.y = this.b * x + this.d * y + this.ty;

	      return newPos;
	    }

	    /**
	     * Get a new position with the inverse of the current transformation applied.
	     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
	     *
	     * @param {Tiny.Point} pos - The origin
	     * @param {Tiny.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
	     * @return {Tiny.Point} The new point, inverse-transformed through this matrix
	     */

	  }, {
	    key: 'applyInverse',
	    value: function applyInverse(pos, newPos) {
	      newPos = newPos || new _Point2.default();

	      var id = 1 / (this.a * this.d + this.c * -this.b);

	      var x = pos.x;
	      var y = pos.y;

	      newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
	      newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

	      return newPos;
	    }

	    /**
	     * Translates the matrix on the x and y.
	     *
	     * @param {number} x How much to translate x by
	     * @param {number} y How much to translate y by
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'translate',
	    value: function translate(x, y) {
	      this.tx += x;
	      this.ty += y;

	      return this;
	    }

	    /**
	     * Applies a scale transformation to the matrix.
	     *
	     * @param {number} x The amount to scale horizontally
	     * @param {number} y The amount to scale vertically
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'scale',
	    value: function scale(x, y) {
	      this.a *= x;
	      this.d *= y;
	      this.c *= x;
	      this.b *= y;
	      this.tx *= x;
	      this.ty *= y;

	      return this;
	    }

	    /**
	     * Applies a rotation transformation to the matrix.
	     *
	     * @param {number} angle - The angle in radians.
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'rotate',
	    value: function rotate(angle) {
	      var cos = Math.cos(angle);
	      var sin = Math.sin(angle);

	      var a1 = this.a;
	      var c1 = this.c;
	      var tx1 = this.tx;

	      this.a = a1 * cos - this.b * sin;
	      this.b = a1 * sin + this.b * cos;
	      this.c = c1 * cos - this.d * sin;
	      this.d = c1 * sin + this.d * cos;
	      this.tx = tx1 * cos - this.ty * sin;
	      this.ty = tx1 * sin + this.ty * cos;

	      return this;
	    }

	    /**
	     * Appends the given Matrix to this Matrix.
	     *
	     * @param {Tiny.Matrix} matrix - The matrix to append.
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'append',
	    value: function append(matrix) {
	      var a1 = this.a;
	      var b1 = this.b;
	      var c1 = this.c;
	      var d1 = this.d;

	      this.a = matrix.a * a1 + matrix.b * c1;
	      this.b = matrix.a * b1 + matrix.b * d1;
	      this.c = matrix.c * a1 + matrix.d * c1;
	      this.d = matrix.c * b1 + matrix.d * d1;

	      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
	      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

	      return this;
	    }

	    /**
	     * Sets the matrix based on all the available properties
	     *
	     * @param {number} x - Position on the x axis
	     * @param {number} y - Position on the y axis
	     * @param {number} pivotX - Pivot on the x axis
	     * @param {number} pivotY - Pivot on the y axis
	     * @param {number} scaleX - Scale on the x axis
	     * @param {number} scaleY - Scale on the y axis
	     * @param {number} rotation - Rotation in radians
	     * @param {number} skewX - Skew on the x axis
	     * @param {number} skewY - Skew on the y axis
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'setTransform',
	    value: function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
	      var sr = Math.sin(rotation);
	      var cr = Math.cos(rotation);
	      var cy = Math.cos(skewY);
	      var sy = Math.sin(skewY);
	      var nsx = -Math.sin(skewX);
	      var cx = Math.cos(skewX);

	      var a = cr * scaleX;
	      var b = sr * scaleX;
	      var c = -sr * scaleY;
	      var d = cr * scaleY;

	      this.a = cy * a + sy * c;
	      this.b = cy * b + sy * d;
	      this.c = nsx * a + cx * c;
	      this.d = nsx * b + cx * d;

	      this.tx = x + (pivotX * a + pivotY * c);
	      this.ty = y + (pivotX * b + pivotY * d);

	      return this;
	    }

	    /**
	     * Prepends the given Matrix to this Matrix.
	     *
	     * @param {Tiny.Matrix} matrix - The matrix to prepend
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'prepend',
	    value: function prepend(matrix) {
	      var tx1 = this.tx;

	      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
	        var a1 = this.a;
	        var c1 = this.c;

	        this.a = a1 * matrix.a + this.b * matrix.c;
	        this.b = a1 * matrix.b + this.b * matrix.d;
	        this.c = c1 * matrix.a + this.d * matrix.c;
	        this.d = c1 * matrix.b + this.d * matrix.d;
	      }

	      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
	      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;

	      return this;
	    }

	    /**
	     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
	     *
	     * @param {Tiny.Transform|Tiny.TransformStatic} transform - The transform to apply the properties to.
	     * @return {Tiny.Transform|Tiny.TransformStatic} The transform with the newly applied properties
	     */

	  }, {
	    key: 'decompose',
	    value: function decompose(transform) {
	      // sort out rotation / skew..
	      var a = this.a;
	      var b = this.b;
	      var c = this.c;
	      var d = this.d;

	      var skewX = -Math.atan2(-c, d);
	      var skewY = Math.atan2(b, a);

	      var delta = Math.abs(skewX + skewY);

	      if (delta < 0.00001) {
	        transform.rotation = skewY;

	        if (a < 0 && d >= 0) {
	          transform.rotation += transform.rotation <= 0 ? Math.PI : -Math.PI;
	        }

	        transform.skew.x = transform.skew.y = 0;
	      } else {
	        transform.skew.x = skewX;
	        transform.skew.y = skewY;
	      }

	      // next set scale
	      transform.scale.x = Math.sqrt(a * a + b * b);
	      transform.scale.y = Math.sqrt(c * c + d * d);

	      // next set position
	      transform.position.x = this.tx;
	      transform.position.y = this.ty;

	      return transform;
	    }

	    /**
	     * Inverts this matrix
	     *
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'invert',
	    value: function invert() {
	      var a1 = this.a;
	      var b1 = this.b;
	      var c1 = this.c;
	      var d1 = this.d;
	      var tx1 = this.tx;
	      var n = a1 * d1 - b1 * c1;

	      this.a = d1 / n;
	      this.b = -b1 / n;
	      this.c = -c1 / n;
	      this.d = a1 / n;
	      this.tx = (c1 * this.ty - d1 * tx1) / n;
	      this.ty = -(a1 * this.ty - b1 * tx1) / n;

	      return this;
	    }

	    /**
	     * Resets this Matix to an identity (default) matrix.
	     *
	     * @return {Tiny.Matrix} This matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'identity',
	    value: function identity() {
	      this.a = 1;
	      this.b = 0;
	      this.c = 0;
	      this.d = 1;
	      this.tx = 0;
	      this.ty = 0;

	      return this;
	    }

	    /**
	     * Creates a new Matrix object with the same values as this one.
	     *
	     * @return {Tiny.Matrix} A copy of this matrix. Good for chaining method calls.
	     */

	  }, {
	    key: 'clone',
	    value: function clone() {
	      var matrix = new Matrix();

	      matrix.a = this.a;
	      matrix.b = this.b;
	      matrix.c = this.c;
	      matrix.d = this.d;
	      matrix.tx = this.tx;
	      matrix.ty = this.ty;

	      return matrix;
	    }

	    /**
	     * Changes the values of the given matrix to be the same as the ones in this matrix
	     *
	     * @param {Tiny.Matrix} matrix - The matrix to copy from.
	     * @return {Tiny.Matrix} The matrix given in parameter with its values updated.
	     */

	  }, {
	    key: 'copy',
	    value: function copy(matrix) {
	      matrix.a = this.a;
	      matrix.b = this.b;
	      matrix.c = this.c;
	      matrix.d = this.d;
	      matrix.tx = this.tx;
	      matrix.ty = this.ty;

	      return matrix;
	    }

	    /**
	     * A default (identity) matrix
	     *
	     * @static
	     * @const
	     */

	  }], [{
	    key: 'IDENTITY',
	    get: function get() {
	      return new Matrix();
	    }

	    /**
	     * A temp matrix
	     *
	     * @static
	     * @const
	     */

	  }, {
	    key: 'TEMP_MATRIX',
	    get: function get() {
	      return new Matrix();
	    }
	  }]);

	  return Matrix;
	}();

	exports.default = Matrix;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Matrix = __webpack_require__(11);

	var _Matrix2 = _interopRequireDefault(_Matrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16

	var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
	var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
	var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
	var tempMatrices = [];

	var mul = [];

	function signum(x) {
	  if (x < 0) {
	    return -1;
	  }
	  if (x > 0) {
	    return 1;
	  }

	  return 0;
	}

	function init() {
	  for (var i = 0; i < 16; i++) {
	    var row = [];

	    mul.push(row);

	    for (var j = 0; j < 16; j++) {
	      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
	      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
	      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
	      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);

	      for (var k = 0; k < 16; k++) {
	        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
	          row.push(k);
	          break;
	        }
	      }
	    }
	  }

	  for (var _i = 0; _i < 16; _i++) {
	    var mat = new _Matrix2.default();

	    mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
	    tempMatrices.push(mat);
	  }
	}

	init();

	/**
	 * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},
	 * D8 is the same but with diagonals. Used for texture rotations.
	 *
	 * Vector xX(i), xY(i) is U-axis of sprite with rotation i
	 * Vector yY(i), yY(i) is V-axis of sprite with rotation i
	 * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
	 * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
	 * This is the small part of gameofbombs.com portal system. It works.
	 *
	 * @author Ivan @ivanpopelyshev
	 * @class
	 * @memberof Tiny
	 */
	var GroupD8 = {
	  E: 0,
	  SE: 1,
	  S: 2,
	  SW: 3,
	  W: 4,
	  NW: 5,
	  N: 6,
	  NE: 7,
	  MIRROR_VERTICAL: 8,
	  MIRROR_HORIZONTAL: 12,
	  uX: function uX(ind) {
	    return ux[ind];
	  },
	  uY: function uY(ind) {
	    return uy[ind];
	  },
	  vX: function vX(ind) {
	    return vx[ind];
	  },
	  vY: function vY(ind) {
	    return vy[ind];
	  },
	  inv: function inv(rotation) {
	    if (rotation & 8) {
	      return rotation & 15;
	    }

	    return -rotation & 7;
	  },
	  add: function add(rotationSecond, rotationFirst) {
	    return mul[rotationSecond][rotationFirst];
	  },
	  sub: function sub(rotationSecond, rotationFirst) {
	    return mul[rotationSecond][GroupD8.inv(rotationFirst)];
	  },

	  /**
	   * Adds 180 degrees to rotation. Commutative operation.
	   *
	   * @memberof Tiny.GroupD8
	   * @param {number} rotation - The number to rotate.
	   * @return {number} rotated number
	   */
	  rotate180: function rotate180(rotation) {
	    return rotation ^ 4;
	  },

	  /**
	   * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.
	   *
	   * @memberof Tiny.GroupD8
	   * @param {number} rotation - The number to check.
	   * @return {boolean} Whether or not the width/height should be swapped.
	   */
	  isSwapWidthHeight: function isSwapWidthHeight(rotation) {
	    return (rotation & 3) === 2;
	  },

	  /**
	   * @memberof Tiny.GroupD8
	   * @param {number} dx - TODO
	   * @param {number} dy - TODO
	   *
	   * @return {number} TODO
	   */
	  byDirection: function byDirection(dx, dy) {
	    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
	      if (dy >= 0) {
	        return GroupD8.S;
	      }

	      return GroupD8.N;
	    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
	      if (dx > 0) {
	        return GroupD8.E;
	      }

	      return GroupD8.W;
	    } else if (dy > 0) {
	      if (dx > 0) {
	        return GroupD8.SE;
	      }

	      return GroupD8.SW;
	    } else if (dx > 0) {
	      return GroupD8.NE;
	    }

	    return GroupD8.NW;
	  },

	  /**
	   * Helps sprite to compensate texture packer rotation.
	   *
	   * @memberof Tiny.GroupD8
	   * @param {Tiny.Matrix} matrix - sprite world matrix
	   * @param {number} rotation - The rotation factor to use.
	   * @param {number} tx - sprite anchoring
	   * @param {number} ty - sprite anchoring
	   */
	  matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {
	    var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    // Packer used "rotation", we use "inv(rotation)"
	    var mat = tempMatrices[GroupD8.inv(rotation)];

	    mat.tx = tx;
	    mat.ty = ty;
	    matrix.append(mat);
	  }
	};

	exports.default = GroupD8;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Rectangle = __webpack_require__(14);

	var _Rectangle2 = _interopRequireDefault(_Rectangle);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The Circle object can be used to specify a hit area for displayObjects
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Circle = function () {
	  /**
	   * @param {number} [x=0] - The X coordinate of the center of this circle
	   * @param {number} [y=0] - The Y coordinate of the center of this circle
	   * @param {number} [radius=0] - The radius of the circle
	   */
	  function Circle() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    _classCallCheck(this, Circle);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.radius = radius;

	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     * @readOnly
	     * @default Tiny.SHAPES.CIRC
	     * @see Tiny.SHAPES
	     */
	    this.type = _const.SHAPES.CIRC;
	  }

	  /**
	   * Creates a clone of this Circle instance
	   *
	   * @return {Tiny.Circle} a copy of the Circle
	   */


	  _createClass(Circle, [{
	    key: 'clone',
	    value: function clone() {
	      return new Circle(this.x, this.y, this.radius);
	    }

	    /**
	     * Checks whether the x and y coordinates given are contained within this circle
	     *
	     * @param {number} x - The X coordinate of the point to test
	     * @param {number} y - The Y coordinate of the point to test
	     * @return {boolean} Whether the x/y coordinates are within this Circle
	     */

	  }, {
	    key: 'contains',
	    value: function contains(x, y) {
	      if (this.radius <= 0) {
	        return false;
	      }

	      var r2 = this.radius * this.radius;
	      var dx = this.x - x;
	      var dy = this.y - y;

	      dx *= dx;
	      dy *= dy;

	      return dx + dy <= r2;
	    }

	    /**
	     * Returns the framing rectangle of the circle as a Rectangle object
	     *
	     * @return {Tiny.Rectangle} the framing rectangle
	     */

	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
	    }
	  }]);

	  return Circle;
	}();

	exports.default = Circle;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _const = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Rectangle object is an area defined by its position, as indicated by its top-left corner
	 * point (x, y) and by its width and its height.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Rectangle = function () {
	  /**
	   * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
	   * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
	   * @param {number} [width=0] - The overall width of this rectangle
	   * @param {number} [height=0] - The overall height of this rectangle
	   */
	  function Rectangle() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, Rectangle);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height;

	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     * @readOnly
	     * @default Tiny.SHAPES.RECT
	     * @see Tiny.SHAPES
	     */
	    this.type = _const.SHAPES.RECT;
	  }

	  /**
	   * returns the left edge of the rectangle
	   *
	   * @member {number}
	   */


	  _createClass(Rectangle, [{
	    key: 'clone',


	    /**
	     * Creates a clone of this Rectangle
	     *
	     * @return {Tiny.Rectangle} a copy of the rectangle
	     */
	    value: function clone() {
	      return new Rectangle(this.x, this.y, this.width, this.height);
	    }

	    /**
	     * Copies another rectangle to this one.
	     *
	     * @param {Tiny.Rectangle} rectangle - The rectangle to copy.
	     * @return {Tiny.Rectangle} Returns itself.
	     */

	  }, {
	    key: 'copy',
	    value: function copy(rectangle) {
	      this.x = rectangle.x;
	      this.y = rectangle.y;
	      this.width = rectangle.width;
	      this.height = rectangle.height;

	      return this;
	    }

	    /**
	     * Checks whether the x and y coordinates given are contained within this Rectangle
	     *
	     * @param {number} x - The X coordinate of the point to test
	     * @param {number} y - The Y coordinate of the point to test
	     * @return {boolean} Whether the x/y coordinates are within this Rectangle
	     */

	  }, {
	    key: 'contains',
	    value: function contains(x, y) {
	      if (this.width <= 0 || this.height <= 0) {
	        return false;
	      }

	      if (x >= this.x && x < this.x + this.width) {
	        if (y >= this.y && y < this.y + this.height) {
	          return true;
	        }
	      }

	      return false;
	    }

	    /**
	     * Pads the rectangle making it grow in all directions.
	     *
	     * @param {number} paddingX - The horizontal padding amount.
	     * @param {number} paddingY - The vertical padding amount.
	     */

	  }, {
	    key: 'pad',
	    value: function pad(paddingX, paddingY) {
	      paddingX = paddingX || 0;
	      paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

	      this.x -= paddingX;
	      this.y -= paddingY;

	      this.width += paddingX * 2;
	      this.height += paddingY * 2;
	    }

	    /**
	     * Fits this rectangle around the passed one.
	     *
	     * @param {Tiny.Rectangle} rectangle - The rectangle to fit.
	     */

	  }, {
	    key: 'fit',
	    value: function fit(rectangle) {
	      if (this.x < rectangle.x) {
	        this.width += this.x;
	        if (this.width < 0) {
	          this.width = 0;
	        }

	        this.x = rectangle.x;
	      }

	      if (this.y < rectangle.y) {
	        this.height += this.y;
	        if (this.height < 0) {
	          this.height = 0;
	        }
	        this.y = rectangle.y;
	      }

	      if (this.x + this.width > rectangle.x + rectangle.width) {
	        this.width = rectangle.width - this.x;
	        if (this.width < 0) {
	          this.width = 0;
	        }
	      }

	      if (this.y + this.height > rectangle.y + rectangle.height) {
	        this.height = rectangle.height - this.y;
	        if (this.height < 0) {
	          this.height = 0;
	        }
	      }
	    }

	    /**
	     * Enlarges this rectangle to include the passed rectangle.
	     *
	     * @param {Tiny.Rectangle} rectangle - The rectangle to include.
	     */

	  }, {
	    key: 'enlarge',
	    value: function enlarge(rectangle) {
	      var x1 = Math.min(this.x, rectangle.x);
	      var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
	      var y1 = Math.min(this.y, rectangle.y);
	      var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

	      this.x = x1;
	      this.width = x2 - x1;
	      this.y = y1;
	      this.height = y2 - y1;
	    }
	  }, {
	    key: 'left',
	    get: function get() {
	      return this.x;
	    }

	    /**
	     * returns the right edge of the rectangle
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'right',
	    get: function get() {
	      return this.x + this.width;
	    }

	    /**
	     * returns the top edge of the rectangle
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'top',
	    get: function get() {
	      return this.y;
	    }

	    /**
	     * returns the bottom edge of the rectangle
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'bottom',
	    get: function get() {
	      return this.y + this.height;
	    }

	    /**
	     * A constant empty rectangle.
	     *
	     * @static
	     * @constant
	     */

	  }], [{
	    key: 'EMPTY',
	    get: function get() {
	      return new Rectangle(0, 0, 0, 0);
	    }
	  }]);

	  return Rectangle;
	}();

	exports.default = Rectangle;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Rectangle = __webpack_require__(14);

	var _Rectangle2 = _interopRequireDefault(_Rectangle);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The Ellipse object can be used to specify a hit area for displayObjects
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Ellipse = function () {
	  /**
	   * @param {number} [x=0] - The X coordinate of the center of this circle
	   * @param {number} [y=0] - The Y coordinate of the center of this circle
	   * @param {number} [width=0] - The half width of this ellipse
	   * @param {number} [height=0] - The half height of this ellipse
	   */
	  function Ellipse() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, Ellipse);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height;

	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     * @readOnly
	     * @default Tiny.SHAPES.ELIP
	     * @see Tiny.SHAPES
	     */
	    this.type = _const.SHAPES.ELIP;
	  }

	  /**
	   * Creates a clone of this Ellipse instance
	   *
	   * @return {Tiny.Ellipse} a copy of the ellipse
	   */


	  _createClass(Ellipse, [{
	    key: 'clone',
	    value: function clone() {
	      return new Ellipse(this.x, this.y, this.width, this.height);
	    }

	    /**
	     * Checks whether the x and y coordinates given are contained within this ellipse
	     *
	     * @param {number} x - The X coordinate of the point to test
	     * @param {number} y - The Y coordinate of the point to test
	     * @return {boolean} Whether the x/y coords are within this ellipse
	     */

	  }, {
	    key: 'contains',
	    value: function contains(x, y) {
	      if (this.width <= 0 || this.height <= 0) {
	        return false;
	      }

	      // normalize the coords to an ellipse with center 0,0
	      var normx = (x - this.x) / this.width;
	      var normy = (y - this.y) / this.height;

	      normx *= normx;
	      normy *= normy;

	      return normx + normy <= 1;
	    }

	    /**
	     * Returns the framing rectangle of the ellipse as a Rectangle object
	     *
	     * @return {Tiny.Rectangle} the framing rectangle
	     */

	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height);
	    }
	  }]);

	  return Ellipse;
	}();

	exports.default = Ellipse;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Point = __webpack_require__(9);

	var _Point2 = _interopRequireDefault(_Point);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var Polygon = function () {
	  /**
	   * @param {Tiny.Point[]|number[]} points - This can be an array of Points
	   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
	   *  the arguments passed can be all the points of the polygon e.g.
	   *  `new Tiny.Polygon(new Tiny.Point(), new Tiny.Point(), ...)`, or the arguments passed can be flat
	   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
	   */
	  function Polygon() {
	    for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
	      points[_key] = arguments[_key];
	    }

	    _classCallCheck(this, Polygon);

	    if (Array.isArray(points[0])) {
	      points = points[0];
	    }

	    // if this is an array of points, convert it to a flat array of numbers
	    if (points[0] instanceof _Point2.default) {
	      var p = [];

	      for (var i = 0, il = points.length; i < il; i++) {
	        p.push(points[i].x, points[i].y);
	      }

	      points = p;
	    }

	    this.closed = true;

	    /**
	     * An array of the points of this polygon
	     *
	     * @member {number[]}
	     */
	    this.points = points;

	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     * @readOnly
	     * @default Tiny.SHAPES.POLY
	     * @see Tiny.SHAPES
	     */
	    this.type = _const.SHAPES.POLY;
	  }

	  /**
	   * Creates a clone of this polygon
	   *
	   * @return {Tiny.Polygon} a copy of the polygon
	   */


	  _createClass(Polygon, [{
	    key: 'clone',
	    value: function clone() {
	      return new Polygon(this.points.slice());
	    }

	    /**
	     * Closes the polygon, adding points if necessary.
	     *
	     */

	  }, {
	    key: 'close',
	    value: function close() {
	      var points = this.points;

	      // close the poly if the value is true!
	      if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
	        points.push(points[0], points[1]);
	      }
	    }

	    /**
	     * Checks whether the x and y coordinates passed to this function are contained within this polygon
	     *
	     * @param {number} x - The X coordinate of the point to test
	     * @param {number} y - The Y coordinate of the point to test
	     * @return {boolean} Whether the x/y coordinates are within this polygon
	     */

	  }, {
	    key: 'contains',
	    value: function contains(x, y) {
	      var inside = false;

	      // use some raycasting to test hits
	      // https://github.com/substack/point-in-polygon/blob/master/index.js
	      var length = this.points.length / 2;

	      for (var i = 0, j = length - 1; i < length; j = i++) {
	        var xi = this.points[i * 2];
	        var yi = this.points[i * 2 + 1];
	        var xj = this.points[j * 2];
	        var yj = this.points[j * 2 + 1];
	        var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;

	        if (intersect) {
	          inside = !inside;
	        }
	      }

	      return inside;
	    }
	  }]);

	  return Polygon;
	}();

	exports.default = Polygon;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _const = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
	 * top-left corner point (x, y) and by its width and its height and its radius.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var RoundedRectangle = function () {
	  /**
	   * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
	   * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
	   * @param {number} [width=0] - The overall width of this rounded rectangle
	   * @param {number} [height=0] - The overall height of this rounded rectangle
	   * @param {number} [radius=20] - Controls the radius of the rounded corners
	   */
	  function RoundedRectangle() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;

	    _classCallCheck(this, RoundedRectangle);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height;

	    /**
	     * @member {number}
	     * @default 20
	     */
	    this.radius = radius;

	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     * @readonly
	     * @default Tiny.SHAPES.RREC
	     * @see Tiny.SHAPES
	     */
	    this.type = _const.SHAPES.RREC;
	  }

	  /**
	   * Creates a clone of this Rounded Rectangle
	   *
	   * @return {Tiny.RoundedRectangle} a copy of the rounded rectangle
	   */


	  _createClass(RoundedRectangle, [{
	    key: 'clone',
	    value: function clone() {
	      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
	    }

	    /**
	     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
	     *
	     * @param {number} x - The X coordinate of the point to test
	     * @param {number} y - The Y coordinate of the point to test
	     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
	     */

	  }, {
	    key: 'contains',
	    value: function contains(x, y) {
	      if (this.width <= 0 || this.height <= 0) {
	        return false;
	      }
	      if (x >= this.x && x <= this.x + this.width) {
	        if (y >= this.y && y <= this.y + this.height) {
	          if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) {
	            return true;
	          }
	          var dx = x - (this.x + this.radius);
	          var dy = y - (this.y + this.radius);
	          var radius2 = this.radius * this.radius;

	          if (dx * dx + dy * dy <= radius2) {
	            return true;
	          }
	          dx = x - (this.x + this.width - this.radius);
	          if (dx * dx + dy * dy <= radius2) {
	            return true;
	          }
	          dy = y - (this.y + this.height - this.radius);
	          if (dx * dx + dy * dy <= radius2) {
	            return true;
	          }
	          dx = x - (this.x + this.radius);
	          if (dx * dx + dy * dy <= radius2) {
	            return true;
	          }
	        }
	      }

	      return false;
	    }
	  }]);

	  return RoundedRectangle;
	}();

	exports.default = RoundedRectangle;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BaseTextureCache = exports.TextureCache = exports.isArray = exports.pluginTarget = exports.EventEmitter = exports.isMobile = exports.TWEEN = undefined;

	var _decide = __webpack_require__(19);

	Object.keys(_decide).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _decide[key];
	    }
	  });
	});
	exports.uid = uid;
	exports.isFunction = isFunction;
	exports.isNumber = isNumber;
	exports.isString = isString;
	exports.isUndefined = isUndefined;
	exports.getTime = getTime;
	exports.random = random;
	exports.randomInt = randomInt;
	exports.randomFloat = randomFloat;
	exports.randomBool = randomBool;
	exports.randomPM = randomPM;
	exports.randomFromArray = randomFromArray;
	exports.hex2rgb = hex2rgb;
	exports.hex2string = hex2string;
	exports.rgb2hex = rgb2hex;
	exports.deg2radian = deg2radian;
	exports.getXMLHttpRequest = getXMLHttpRequest;
	exports.getResolutionOfUrl = getResolutionOfUrl;
	exports.decomposeDataUri = decomposeDataUri;
	exports.getUrlFileExtension = getUrlFileExtension;
	exports.getSvgSize = getSvgSize;
	exports.isWebGLSupported = isWebGLSupported;
	exports.sign = sign;
	exports.removeItems = removeItems;
	exports.arrayRemoveObject = arrayRemoveObject;
	exports.detect = detect;
	exports.point = point;
	exports.scale = scale;

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _tween = __webpack_require__(25);

	var _tween2 = _interopRequireDefault(_tween);

	var _pluginTarget = __webpack_require__(27);

	var _pluginTarget2 = _interopRequireDefault(_pluginTarget);

	var _ismobilejs = __webpack_require__(22);

	var isMobile = _interopRequireWildcard(_ismobilejs);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var nextUid = 0;

	exports.TWEEN = _tween2.default;
	exports.isMobile = isMobile;
	exports.EventEmitter = _eventemitter2.default;
	exports.pluginTarget = _pluginTarget2.default;

	/**
	 * Gets the next unique identifier
	 *
	 * @memberof Tiny
	 * @function uid
	 * @return {number} The next unique identifier to use.
	 */

	function uid() {
	  return ++nextUid;
	}

	/**
	 * 判断对象是否是`String`类型
	 *
	 * @static
	 * @memberof Tiny
	 * @function isString
	 * @param {Object} obj 要判断的对象
	 * @return {Boolean}
	 */
	var isArray = exports.isArray = Array.isArray || function (obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
	};

	/**
	 * 判断对象是否是函数类型
	 *
	 * @static
	 * @memberof Tiny
	 * @function isFunction
	 * @param {Object} obj 要判断的对象
	 * @return {Boolean}
	 */
	function isFunction(obj) {
	  return Object.prototype.toString.call(obj) === '[object Function]';
	}

	/**
	 * 判断对象是否是`Number`类型
	 *
	 * @static
	 * @memberof Tiny
	 * @function isNumber
	 * @param {Object} obj 要判断的对象
	 * @return {Boolean}
	 */
	function isNumber(obj) {
	  return Object.prototype.toString.call(obj) === '[object Number]';
	}

	/**
	 * 判断对象是否是`String`类型
	 *
	 * @static
	 * @memberof Tiny
	 * @function isString
	 * @param {Object} obj 要判断的对象
	 * @return {Boolean}
	 */
	function isString(obj) {
	  return typeof obj === 'string';
	}

	/**
	 * @memberof Tiny
	 * @function isUndefined
	 * @param obj
	 */
	function isUndefined(obj) {
	  return obj === void 0;
	}

	/**
	 * @memberof Tiny
	 * @function getTime
	 * @return {*}
	 */
	function getTime() {
	  return window.performance.timing.navigationStart + window.performance.now();
	}

	/**
	 * @memberof Tiny
	 * @function random
	 * @param min
	 * @param max
	 * @return {*}
	 */
	function random(min, max) {
	  if (isArray(min)) {
	    max = min[1];
	    min = min[0];
	  }
	  return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	/**
	 * @memberof Tiny
	 * @function randomInt
	 * @return {*}
	 */
	function randomInt() {
	  return random.call.apply(random, [this].concat(Array.prototype.slice.call(arguments)));
	}

	/**
	 * @memberof Tiny
	 * @function randomFloat
	 * @param min
	 * @param max
	 * @return {*}
	 */
	function randomFloat(min, max) {
	  return min + Math.random() * (max - min);
	}

	/**
	 * @memberof Tiny
	 * @function randomBool
	 * @param chance
	 * @return {boolean}
	 */
	function randomBool(chance) {
	  chance = chance ? chance : 0.5; // eslint-disable-line
	  return Math.random() < chance;
	}

	/**
	 * @memberof Tiny
	 * @function randomPM
	 * @param chance
	 * @return {number}
	 */
	function randomPM(chance) {
	  chance = chance ? chance : 0.5; // eslint-disable-line
	  return Math.random() > chance ? -1 : 1;
	}

	/**
	 * @memberof Tiny
	 * @function randomFromArray
	 * @param arr
	 * @return {*}
	 */
	function randomFromArray(arr) {
	  return arr[random(0, arr.length - 1)];
	}

	/**
	 * Converts a hex color number to an [R, G, B] array
	 *
	 * @memberof Tiny
	 * @function hex2rgb
	 * @param {number} hex - The number to convert
	 * @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
	 * @return {number[]} An array representing the [R, G, B] of the color.
	 */
	function hex2rgb(hex, out) {
	  out = out || [];

	  out[0] = (hex >> 16 & 0xFF) / 255;
	  out[1] = (hex >> 8 & 0xFF) / 255;
	  out[2] = (hex & 0xFF) / 255;

	  return out;
	}

	/**
	 * Converts a hex color number to a string.
	 *
	 * @memberof Tiny
	 * @function hex2string
	 * @param {number} hex - Number in hex
	 * @return {string} The string color.
	 */
	function hex2string(hex) {
	  hex = hex.toString(16);
	  hex = '000000'.substr(0, 6 - hex.length) + hex;

	  return '#' + hex;
	}

	/**
	 * Converts a color as an [R, G, B] array to a hex number
	 *
	 * @memberof Tiny
	 * @function rgb2hex
	 * @param {number[]} rgb - rgb array
	 * @return {number} The color number
	 */
	function rgb2hex(rgb) {
	  return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
	}

	/**
	 * @memberof Tiny
	 * @function deg2radian
	 * @param deg
	 * @return {number}
	 */
	function deg2radian(deg) {
	  return _const.PI_2 * deg / 360;
	}

	function getXMLHttpRequest() {
	  var xhr = this._XMLHttpRequest;
	  if (!xhr) {
	    xhr = new XMLHttpRequest();
	    this._XMLHttpRequest = xhr;
	  } else {
	    if (+xhr.readyState !== 4) {
	      return new XMLHttpRequest();
	    }
	  }
	  return xhr;
	}

	/**
	 * get the resolution / device pixel ratio of an asset by looking for the prefix
	 * used by spritesheets and image urls
	 *
	 * @memberof Tiny
	 * @function getResolutionOfUrl
	 * @param {string} url - the image path
	 * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
	 * @return {number} resolution / device pixel ratio of an asset
	 */
	function getResolutionOfUrl(url, defaultValue) {
	  var resolution = _settings2.default.RETINA_PREFIX.exec(url);

	  if (resolution) {
	    return parseFloat(resolution[1]);
	  }

	  return defaultValue !== undefined ? defaultValue : 1;
	}

	/**
	 * Typedef for decomposeDataUri return object.
	 *
	 * @typedef {object} DecomposedDataUri
	 * @property {mediaType} Media type, eg. `image`
	 * @property {subType} Sub type, eg. `png`
	 * @property {encoding} Data encoding, eg. `base64`
	 * @property {data} The actual data
	 */

	/**
	 * Split a data URI into components. Returns undefined if
	 * parameter `dataUri` is not a valid data URI.
	 *
	 * @memberof Tiny
	 * @function decomposeDataUri
	 * @param {string} dataUri - the data URI to check
	 * @return {DecomposedDataUri|undefined} The decomposed data uri or undefined
	 */
	function decomposeDataUri(dataUri) {
	  var dataUriMatch = _const.DATA_URI.exec(dataUri);

	  if (dataUriMatch) {
	    return {
	      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
	      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
	      encoding: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
	      data: dataUriMatch[4]
	    };
	  }

	  return undefined;
	}

	/**
	 * Get type of the image by regexp for extension. Returns undefined for unknown extensions.
	 *
	 * @memberof Tiny
	 * @function getUrlFileExtension
	 * @param {string} url - the image path
	 * @return {string|undefined} image extension
	 */
	function getUrlFileExtension(url) {
	  var extension = _const.URL_FILE_EXTENSION.exec(url);

	  if (extension) {
	    return extension[1].toLowerCase();
	  }

	  return undefined;
	}

	/**
	 * Typedef for Size object.
	 *
	 * @typedef {object} Size
	 * @property {width} Width component
	 * @property {height} Height component
	 */

	/**
	 * Get size from an svg string using regexp.
	 *
	 * @memberof Tiny
	 * @function getSvgSize
	 * @param {string} svgString - a serialized svg element
	 * @return {Size|undefined} image extension
	 */
	function getSvgSize(svgString) {
	  var sizeMatch = _const.SVG_SIZE.exec(svgString);
	  var size = {};

	  if (sizeMatch) {
	    size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
	    size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
	  }

	  return size;
	}

	/**
	 * Helper for checking for webgl support
	 *
	 * @memberof Tiny
	 * @function isWebGLSupported
	 * @return {boolean} is webgl supported
	 */
	function isWebGLSupported() {
	  var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };

	  try {
	    if (!window.WebGLRenderingContext) {
	      return false;
	    }

	    var canvas = document.createElement('canvas');
	    var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

	    var success = !!(gl && gl.getContextAttributes().stencil);

	    if (gl) {
	      var loseContext = gl.getExtension('WEBGL_lose_context');

	      if (loseContext) {
	        loseContext.loseContext();
	      }
	    }

	    gl = null;

	    return success;
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * Returns sign of number
	 *
	 * @memberof Tiny
	 * @function sign
	 * @param {number} n - the number to check the sign of
	 * @return {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
	 */
	function sign(n) {
	  if (n === 0) return 0;

	  return n < 0 ? -1 : 1;
	}

	/**
	 * Remove a range of items from an array
	 *
	 * @memberof Tiny
	 * @function removeItems
	 * @param {Array<*>} arr The target array
	 * @param {number} startIdx The index to begin removing from (inclusive)
	 * @param {number} removeCount How many items to remove
	 */
	function removeItems(arr, startIdx, removeCount) {
	  var length = arr.length;

	  if (startIdx >= length || removeCount === 0) {
	    return;
	  }

	  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;

	  var len = length - removeCount;

	  for (var i = startIdx; i < len; ++i) {
	    arr[i] = arr[i + removeCount];
	  }

	  arr.length = len;
	}

	/**
	 * @memberof Tiny
	 * @function arrayRemoveObject
	 * @param arr
	 * @param delObj
	 */
	function arrayRemoveObject(arr, delObj) {
	  for (var i = 0, l = arr.length; i < l; i++) {
	    if (arr[i] === delObj) {
	      arr.splice(i, 1);
	      break;
	    }
	  }
	}

	/**
	 * @memberof Tiny
	 * @function detect
	 * @param obj
	 * @param iterator
	 * @param context
	 * @param arg1
	 * @param arg2
	 * @return {*}
	 */
	function detect(obj, iterator, context, arg1, arg2) {
	  var result = void 0;
	  if (obj === null) {
	    return;
	  }
	  if (obj.length === +obj.length) {
	    for (var i = 0, l = obj.length; i < l; i++) {
	      result = iterator.call(context, obj[i], i, arg1, arg2);
	      if (result) {
	        return result;
	      }
	    }
	    return false;
	  } else {
	    for (var key in obj) {
	      result = iterator.call(context, obj[key], key, arg1, arg2);
	      if (result) {
	        return result;
	      }
	    }
	    return false;
	  }
	}

	/**
	 * @memberof Tiny
	 * @function point
	 * @param x
	 * @param y
	 * @return {{x: *, y: *}}
	 */
	function point(x, y) {
	  return {
	    x: x, // eslint-disable-line
	    y: y === void 0 ? x : y
	  };
	}

	/**
	 * @memberof Tiny
	 * @function scale
	 * @param x
	 * @param y
	 * @return {{scaleX: *, scaleY: *}}
	 */
	function scale(x, y) {
	  return {
	    scaleX: x,
	    scaleY: y === void 0 ? x : y
	  };
	}

	/**
	 *
	 * @name TextureCache
	 * @memberof Tiny
	 * @type {object}
	 * @private
	 */
	var TextureCache = exports.TextureCache = {};

	/**
	 *
	 * @name BaseTextureCache
	 * @memberof Tiny
	 * @type {object}
	 * @private
	 */
	var BaseTextureCache = exports.BaseTextureCache = {};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.rectContainsRect = rectContainsRect;
	exports.rectGetMaxX = rectGetMaxX;
	exports.rectGetMidX = rectGetMidX;
	exports.rectGetMinX = rectGetMinX;
	exports.rectGetMaxY = rectGetMaxY;
	exports.rectGetMidY = rectGetMidY;
	exports.rectGetMinY = rectGetMinY;
	exports.rectContainsPoint = rectContainsPoint;
	exports.rectIntersectsRect = rectIntersectsRect;
	exports.rectUnion = rectUnion;
	exports.isPixelCollision = isPixelCollision;

	var _math = __webpack_require__(8);

	/**
	 *
	 * 检测一个对象 bound 是否在另一个对象 bound 内部
	 *
	 * ![rectContainsRect](http://tfs.alipayobjects.com/images/rmsweb/T1hoXgXXNfXXXXXXXX.png)
	 *
	 * 注意：边缘重叠始终返回fasle
	 *
	 * @example
	 *
	 * var rect1 = new Tiny.Rectangle(10, 10, 100, 100);
	 * var rect2 = new Tiny.Rectangle(30, 30, 50, 50);
	 * Tiny.rectContainsRect(rect1, rect2);
	 * //=> true
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectContainsRect
	 * @param rect1
	 * @param rect2
	 * @return {boolean}
	 */
	function rectContainsRect(rect1, rect2) {
	  if (!rect1 || !rect2) {
	    return false;
	  }

	  return !(rect1.x >= rect2.x || rect1.y >= rect2.y || rect1.x + rect1.width <= rect2.x + rect2.width || rect1.y + rect1.height <= rect2.y + rect2.height);
	}

	/**
	 * 获取对象 bound 的横向最大值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMaxX
	 * @param rect
	 * @return {number}
	 */
	function rectGetMaxX(rect) {
	  return rect.x + rect.width;
	}

	/**
	 * 获取对象 bound 的横向中心值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMidX
	 * @param rect
	 * @return {number}
	 */
	function rectGetMidX(rect) {
	  return rect.x + rect.width / 2.0;
	}

	/**
	 * 获取对象 bound 的横向最小值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMinX
	 * @param rect
	 * @return {number}
	 */
	function rectGetMinX(rect) {
	  return rect.x;
	}

	/**
	 * 获取对象 bound 的纵向最大值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMaxY
	 * @param rect
	 * @return {number}
	 */
	function rectGetMaxY(rect) {
	  return rect.y + rect.height;
	}

	/**
	 * 获取对象 bound 的纵向中心值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMidY
	 * @param rect
	 * @return {number}
	 */
	function rectGetMidY(rect) {
	  return rect.y + rect.height / 2.0;
	}

	/**
	 * 获取对象 bound 的纵向最小值
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectGetMinY
	 * @param rect
	 * @return {number}
	 */
	function rectGetMinY(rect) {
	  return rect.y;
	}

	/**
	 * 检测一个点是否在一个对象 bound 内部
	 *
	 * ![rectContainsPoint](http://tfs.alipayobjects.com/images/rmsweb/T1GENgXkRaXXXXXXXX.png)
	 *
	 * 注意：边缘重叠始终返回fasle
	 *
	 * @example
	 *
	 * var rect = new Tiny.Rectangle(10, 10, 50, 50);
	 * var p = new Tiny.Point(49, 62);
	 * Tiny.rectContainsPoint(rect, p);
	 * //=> true
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectContainsPoint
	 * @param rect
	 * @param point
	 * @return {boolean}
	 */
	function rectContainsPoint(rect, point) {
	  return point.x >= rectGetMinX(rect) && point.x <= rectGetMaxX(rect) && point.y >= rectGetMinY(rect) && point.y <= rectGetMaxY(rect);
	}

	/**
	 * 检测两个对象 bound 是否相交，一般用于检测碰撞
	 *
	 * ![rectIntersectsRect](http://tfs.alipayobjects.com/images/rmsweb/T18.hgXoddXXXXXXXX.png)
	 *
	 * 注意：边缘重叠始终返回true
	 *
	 * @example
	 *
	 * var rect1 = new Tiny.Rectangle(10, 10, 50, 50);
	 * var rect2 = new Tiny.Rectangle(50, 30, 50, 50);
	 * Tiny.rectIntersectsRect(rect1, rect2);
	 * //=> true
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectIntersectsRect
	 * @param rectA
	 * @param rectB
	 * @return {boolean}
	 */
	function rectIntersectsRect(rectA, rectB) {
	  return !(rectGetMaxX(rectA) < rectGetMinX(rectB) || rectGetMaxX(rectB) < rectGetMinX(rectA) || rectGetMaxY(rectA) < rectGetMinY(rectB) || rectGetMaxY(rectB) < rectGetMinY(rectA));
	}

	/**
	 * 返回两个对象 bound 的总区域
	 *
	 * ![rectUnion](http://tfs.alipayobjects.com/images/rmsweb/T1JD4gXhlfXXXXXXXX.png)
	 *
	 * @example
	 *
	 * var rect1 = new Tiny.Rectangle(10, 10, 50, 50);
	 * var rect2 = new Tiny.Rectangle(33, 34, 50, 50);
	 * Tiny.rectUnion(rect1, rect2);
	 * //=> Tiny.Rectangle(10, 10, 73, 74)
	 *
	 * @static
	 * @memberof Tiny
	 * @function rectUnion
	 * @param rectA
	 * @param rectB
	 * @return {Tiny.Rectangle}
	 */
	function rectUnion(rectA, rectB) {
	  var rect = _math.Rectangle.EMPTY;
	  rect.x = Math.min(rectA.x, rectB.x);
	  rect.y = Math.min(rectA.y, rectB.y);
	  rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
	  rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
	  return rect;
	}

	/**
	 * 像素检测判断是否碰撞
	 *
	 * Tiny.js 的这个方法用于JavaScript HTML5 Canvas Image 纯像素级的碰撞检测。
	 * 作者是：JOE
	 *
	 * @see http://www.playmycode.com/blog/2011/08/javascript-per-pixel-html5-canvas-image-collision-detection/
	 *
	 * @static
	 * @memberof Tiny
	 * @function isPixelCollision
	 * @param first
	 * @param x
	 * @param y
	 * @param isFirstCentred
	 * @param other
	 * @param x2
	 * @param y2
	 * @param isOtherCentred
	 * @return {boolean}
	 */
	function isPixelCollision(first, x, y, isFirstCentred, other, x2, y2, isOtherCentred) {
	  // we need to avoid using floats, as were doing array lookups
	  x = Math.round(x);
	  y = Math.round(y);
	  x2 = Math.round(x2);
	  y2 = Math.round(y2);

	  var w = first.collisionWidth || first.width;
	  var h = first.collisionHeight || first.height;
	  var w2 = other.collisionWidth || other.width;
	  var h2 = other.collisionHeight || other.height;

	  // deal with the image being centred
	  if (isFirstCentred) {
	    // fast rounding, but positive only
	    x -= w / 2 + 0.5 << 0;
	    y -= h / 2 + 0.5 << 0;
	  }
	  if (isOtherCentred) {
	    x2 -= w2 / 2 + 0.5 << 0;
	    y2 -= h2 / 2 + 0.5 << 0;
	  }

	  // find the top left and bottom right corners of overlapping area
	  var xMin = Math.max(x, x2);
	  var yMin = Math.max(y, y2);
	  var xMax = Math.min(x + w, x2 + w2);
	  var yMax = Math.min(y + h, y2 + h2);

	  // Sanity collision check, we ensure that the top-left corner is both
	  // above and to the left of the bottom-right corner.
	  if (xMin >= xMax || yMin >= yMax) {
	    return false;
	  }

	  var xDiff = xMax - xMin;
	  var yDiff = yMax - yMin;

	  // get the pixels out from the images
	  var pixels = first.data;
	  var pixels2 = other.data;

	  if (!pixels || !pixels2) {
	    throw new Error('The Sprit\'s data cannot be null' + (!pixels && ', first.data is ' + pixels) + (!pixels2 && ', other.data is ' + pixels2 + '.'));
	  }

	  // if the area is really small,
	  // then just perform a normal image collision check
	  if (xDiff < 4 && yDiff < 4) {
	    for (var pixelX = xMin; pixelX < xMax; pixelX++) {
	      for (var pixelY = yMin; pixelY < yMax; pixelY++) {
	        if (pixels[(pixelX - x + (pixelY - y) * w) * 4 + 3] !== 0 && pixels2[(pixelX - x2 + (pixelY - y2) * w2) * 4 + 3] !== 0) {
	          return true;
	        }
	      }
	    }
	  } else {
	    /* What is this doing?
	     * It is iterating over the overlapping area,
	     * across the x then y the,
	     * checking if the pixels are on top of this.
	     *
	     * What is special is that it increments by incX or incY,
	     * allowing it to quickly jump across the image in large increments
	     * rather then slowly going pixel by pixel.
	     *
	     * This makes it more likely to find a colliding pixel early.
	     */

	    // Work out the increments,
	    // it's a third, but ensure we don't get a tiny
	    // slither of an area for the last iteration (using fast ceil).
	    var incX = xDiff / 3.0;
	    var incY = yDiff / 3.0;
	    incX = ~~incX === incX ? incX : incX + 1 | 0;
	    incY = ~~incY === incY ? incY : incY + 1 | 0;

	    for (var offsetY = 0; offsetY < incY; offsetY++) {
	      for (var offsetX = 0; offsetX < incX; offsetX++) {
	        for (var _pixelY = yMin + offsetY; _pixelY < yMax; _pixelY += incY) {
	          for (var _pixelX = xMin + offsetX; _pixelX < xMax; _pixelX += incX) {
	            if (pixels[(_pixelX - x + (_pixelY - y) * w) * 4 + 3] !== 0 && pixels2[(_pixelX - x2 + (_pixelY - y2) * w2) * 4 + 3] !== 0) {
	              return true;
	            }
	          }
	        }
	      }
	    }
	  }

	  return false;
	}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.config = undefined;

	var _maxRecommendedTextures = __webpack_require__(21);

	var _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);

	var _canUploadSameBuffer = __webpack_require__(23);

	var _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  /**
	   * Target frames per millisecond.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 0.06
	   */
	  TARGET_FPMS: 0.06,

	  /**
	   * If set to true WebGL will attempt make textures mimpaped by default.
	   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {boolean}
	   * @default true
	   */
	  MIPMAP_TEXTURES: true,

	  /**
	   * Default resolution / device pixel ratio of the renderer.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 1
	   */
	  RESOLUTION: 1,

	  /**
	   * Default filter resolution.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 1
	   */
	  FILTER_RESOLUTION: 1,

	  /**
	   * The maximum textures that this device supports.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 32
	   */
	  SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32),

	  /**
	   * The default sprite batch size.
	   *
	   * The default aims to balance desktop and mobile devices.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 4096
	   */
	  SPRITE_BATCH_SIZE: 4096,

	  /**
	   * The prefix that denotes a URL is for a retina asset.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {RegExp|string}
	   * @example `@2x`
	   * @default /@(.+)x/
	   */
	  RETINA_PREFIX: /@(.+)x/,

	  /**
	   * The default render options if none are supplied to {@link Tiny.WebGLRenderer}
	   * or {@link Tiny.CanvasRenderer}.
	   *
	   * @static
	   * @constant
	   * @memberof Tiny
	   * @type {object}
	   * @property {HTMLCanvasElement}  view=null
	   * @property {number}             resolution=1
	   * @property {boolean}            antialias=false
	   * @property {boolean}            forceFXAA=false
	   * @property {boolean}            autoResize=false
	   * @property {boolean}            transparent=false
	   * @property {number}             backgroundColor=0x000000
	   * @property {boolean}            clearBeforeRender=true
	   * @property {boolean}            preserveDrawingBuffer=false
	   * @property {boolean}            roundPixels=false
	   */
	  RENDER_OPTIONS: {
	    view: null,
	    antialias: false,
	    forceFXAA: false,
	    autoResize: false,
	    transparent: false,
	    backgroundColor: 0x000000,
	    clearBeforeRender: true,
	    preserveDrawingBuffer: false,
	    roundPixels: false
	  },

	  /**
	   * Default transform type.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {Tiny.TRANSFORM_MODE}
	   * @default Tiny.TRANSFORM_MODE.STATIC
	   */
	  TRANSFORM_MODE: 0,

	  /**
	   * Default Garbage Collection mode.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {Tiny.GC_MODES}
	   * @default Tiny.GC_MODES.AUTO
	   */
	  GC_MODE: 0,

	  /**
	   * Default Garbage Collection max idle.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 3600
	   */
	  GC_MAX_IDLE: 60 * 60,

	  /**
	   * Default Garbage Collection maximum check count.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {number}
	   * @default 600
	   */
	  GC_MAX_CHECK_COUNT: 60 * 10,

	  /**
	   * Default wrap modes that are supported by Tiny.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {Tiny.WRAP_MODES}
	   * @default Tiny.WRAP_MODES.CLAMP
	   */
	  WRAP_MODE: 0,

	  /**
	   * The scale modes that are supported by Tiny.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {Tiny.SCALE_MODES}
	   * @default Tiny.SCALE_MODES.LINEAR
	   */
	  SCALE_MODE: 0,

	  /**
	   * Default specify float precision in shaders.
	   *
	   * @static
	   * @memberof Tiny
	   * @type {Tiny.PRECISION}
	   * @default Tiny.PRECISION.MEDIUM
	   */
	  PRECISION: 'mediump',

	  /**
	   * Can we upload the same buffer in a single frame?
	   *
	   * @static
	   * @constant
	   * @memberof Tiny
	   * @type {boolean}
	   */
	  CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)()

	};

	/**
	 * 默认配置参数
	 *
	 * @static
	 * @constant
	 * @name config
	 * @memberof Tiny
	 * @type {object}
	 * @property {number}   width=320               宽度
	 * @property {number}   height=568              高度 ['480', '568']
	 * @property {string}   canvasId='TinyCanvas'   canvas的DOM
	 * @property {boolean}  fullScreen=true         是否全屏
	 * @property {number}   dpi=1                   分辨率
	 * @property {string}   audioType='WebAudio'    音频类型 ['WebAudio', 'Audio']
	 * @property {boolean}  showFPS=false           是否显示帧频
	 * @property {number}   frameRate=60            帧频
	 * @property {number}   renderType=0            渲染类型 [0: 自动识别, 1: WEBGL, 2: CANVAS]
	 * @property {object}   renderOptions           渲染参数，见{@link Tiny.RENDER_OPTIONS}
	 * @property {number}   autoRender=1            是否自动渲染 [0: 手动, 1: 自动]
	 */

	var config = exports.config = {
	  width: 320,
	  height: 568,
	  canvasId: 'TinyCanvas',
	  fullScreen: true,
	  dpi: 1,
	  audioType: 'WebAudio',
	  showFPS: false,
	  frameRate: 60,
	  renderType: 0, //WEBGL: 1, CANVAS: 2
	  renderOptions: {},
	  autoRender: 1 };

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = maxRecommendedTextures;

	var _ismobilejs = __webpack_require__(22);

	var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function maxRecommendedTextures(max) {
	  if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
	    // check if the res is iphone 6 or higher..
	    return 4;
	  }

	  // desktop should be ok
	  return max;
	}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/**
	 * isMobile.js v0.4.1
	 *
	 * A simple library to detect Apple phones and tablets,
	 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
	 * and any kind of seven inch device, via user agent sniffing.
	 *
	 * @author: Kai Mallea (kmallea@gmail.com)
	 *
	 * @license: http://creativecommons.org/publicdomain/zero/1.0/
	 */
	(function (global) {

	    var apple_phone = /iPhone/i,
	        apple_ipod = /iPod/i,
	        apple_tablet = /iPad/i,
	        android_phone = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,
	        // Match 'Android' AND 'Mobile'
	    android_tablet = /Android/i,
	        amazon_phone = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
	        amazon_tablet = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
	        windows_phone = /Windows Phone/i,
	        windows_tablet = /(?=.*\bWindows\b)(?=.*\bARM\b)/i,
	        // Match 'Windows' AND 'ARM'
	    other_blackberry = /BlackBerry/i,
	        other_blackberry_10 = /BB10/i,
	        other_opera = /Opera Mini/i,
	        other_chrome = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
	        other_firefox = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,
	        // Match 'Firefox' AND 'Mobile'
	    seven_inch = new RegExp('(?:' + // Non-capturing group

	    'Nexus 7' + // Nexus 7

	    '|' + // OR

	    'BNTV250' + // B&N Nook Tablet 7 inch

	    '|' + // OR

	    'Kindle Fire' + // Kindle Fire

	    '|' + // OR

	    'Silk' + // Kindle Fire, Silk Accelerated

	    '|' + // OR

	    'GT-P1000' + // Galaxy Tab 7 inch

	    ')', // End non-capturing group

	    'i'); // Case-insensitive matching

	    var match = function match(regex, userAgent) {
	        return regex.test(userAgent);
	    };

	    var IsMobileClass = function IsMobileClass(userAgent) {
	        var ua = userAgent || navigator.userAgent;

	        // Facebook mobile app's integrated browser adds a bunch of strings that
	        // match everything. Strip it out if it exists.
	        var tmp = ua.split('[FBAN');
	        if (typeof tmp[1] !== 'undefined') {
	            ua = tmp[0];
	        }

	        // Twitter mobile app's integrated browser on iPad adds a "Twitter for
	        // iPhone" string. Same probable happens on other tablet platforms.
	        // This will confuse detection so strip it out if it exists.
	        tmp = ua.split('Twitter');
	        if (typeof tmp[1] !== 'undefined') {
	            ua = tmp[0];
	        }

	        this.apple = {
	            phone: match(apple_phone, ua),
	            ipod: match(apple_ipod, ua),
	            tablet: !match(apple_phone, ua) && match(apple_tablet, ua),
	            device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua)
	        };
	        this.amazon = {
	            phone: match(amazon_phone, ua),
	            tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
	            device: match(amazon_phone, ua) || match(amazon_tablet, ua)
	        };
	        this.android = {
	            phone: match(amazon_phone, ua) || match(android_phone, ua),
	            tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)),
	            device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua)
	        };
	        this.windows = {
	            phone: match(windows_phone, ua),
	            tablet: match(windows_tablet, ua),
	            device: match(windows_phone, ua) || match(windows_tablet, ua)
	        };
	        this.other = {
	            blackberry: match(other_blackberry, ua),
	            blackberry10: match(other_blackberry_10, ua),
	            opera: match(other_opera, ua),
	            firefox: match(other_firefox, ua),
	            chrome: match(other_chrome, ua),
	            device: match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua)
	        };
	        this.seven_inch = match(seven_inch, ua);
	        this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;

	        // excludes 'other' devices and ipods, targeting touchscreen phones
	        this.phone = this.apple.phone || this.android.phone || this.windows.phone;

	        // excludes 7 inch devices, classifying as phone or tablet is left to the user
	        this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;

	        if (typeof window === 'undefined') {
	            return this;
	        }
	    };

	    var instantiate = function instantiate() {
	        var IM = new IsMobileClass();
	        IM.Class = IsMobileClass;
	        return IM;
	    };

	    if (typeof module !== 'undefined' && module.exports && typeof window === 'undefined') {
	        //node
	        module.exports = IsMobileClass;
	    } else if (typeof module !== 'undefined' && module.exports && typeof window !== 'undefined') {
	        //browserify
	        module.exports = instantiate();
	    } else if (true) {
	        //AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        global.isMobile = instantiate();
	    }
	})(undefined);

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = canUploadSameBuffer;
	function canUploadSameBuffer() {
	  // Uploading the same buffer multiple times in a single frame can cause perf issues.
	  // Apparent on IOS so only check for that at the moment
	  // this check may become more complex if this issue pops up elsewhere.
	  var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

	  return !ios;
	}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var has = Object.prototype.hasOwnProperty,
	    prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @api private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {Mixed} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = [],
	      events,
	      name;

	  if (this._eventsCount === 0) return names;

	  for (name in events = this._events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Boolean} exists Only check if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event,
	      available = this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt],
	      len = arguments.length,
	      args,
	      i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1:
	        return listeners.fn.call(listeners.context), true;
	      case 2:
	        return listeners.fn.call(listeners.context, a1), true;
	      case 3:
	        return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4:
	        return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5:
	        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6:
	        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len - 1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length,
	        j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1:
	          listeners[i].fn.call(listeners[i].context);break;
	        case 2:
	          listeners[i].fn.call(listeners[i].context, a1);break;
	        case 3:
	          listeners[i].fn.call(listeners[i].context, a1, a2);break;
	        case 4:
	          listeners[i].fn.call(listeners[i].context, a1, a2, a3);break;
	        default:
	          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this),
	      evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];

	  return this;
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true),
	      evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];

	  return this;
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {Mixed} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
	      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {String|Symbol} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) {
	      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    }
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */

	var TWEEN = TWEEN || function () {

		var _tweens = [];

		return {

			getAll: function getAll() {

				return _tweens;
			},

			removeAll: function removeAll() {

				_tweens = [];
			},

			add: function add(tween) {

				_tweens.push(tween);
			},

			remove: function remove(tween) {

				var i = _tweens.indexOf(tween);

				if (i !== -1) {
					_tweens.splice(i, 1);
				}
			},

			update: function update(time, preserve) {

				if (_tweens.length === 0) {
					return false;
				}

				var i = 0;

				time = time !== undefined ? time : TWEEN.now();

				while (i < _tweens.length) {

					if (_tweens[i].update(time) || preserve) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}
				}

				return true;
			}
		};
	}();

	// Include a performance.now polyfill.
	// In node.js, use process.hrtime.
	if (typeof window === 'undefined' && typeof process !== 'undefined') {
		TWEEN.now = function () {
			var time = process.hrtime();

			// Convert [seconds, nanoseconds] to milliseconds.
			return time[0] * 1000 + time[1] / 1000000;
		};
	}
	// In a browser, use window.performance.now if it is available.
	else if (typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined) {
			// This must be bound, because directly assigning this function
			// leads to an invocation exception in Chrome.
			TWEEN.now = window.performance.now.bind(window.performance);
		}
		// Use Date.now if it is available.
		else if (Date.now !== undefined) {
				TWEEN.now = Date.now;
			}
			// Otherwise, use 'new Date().getTime()'.
			else {
					TWEEN.now = function () {
						return new Date().getTime();
					};
				}

	TWEEN.Tween = function (object) {

		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _repeatDelayTime;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;

		this.to = function (properties, duration) {

			_valuesEnd = properties;

			if (duration !== undefined) {
				_duration = duration;
			}

			return this;
		};

		this.start = function (time) {

			TWEEN.add(this);

			_isPlaying = true;

			_onStartCallbackFired = false;

			_startTime = time !== undefined ? time : TWEEN.now();
			_startTime += _delayTime;

			for (var property in _valuesEnd) {

				// Check if an Array was provided as property value
				if (_valuesEnd[property] instanceof Array) {

					if (_valuesEnd[property].length === 0) {
						continue;
					}

					// Create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
				}

				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (_object[property] === undefined) {
					continue;
				}

				// Save the starting value.
				_valuesStart[property] = _object[property];

				if (_valuesStart[property] instanceof Array === false) {
					_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}

				_valuesStartRepeat[property] = _valuesStart[property] || 0;
			}

			return this;
		};

		this.stop = function () {

			if (!_isPlaying) {
				return this;
			}

			TWEEN.remove(this);
			_isPlaying = false;

			if (_onStopCallback !== null) {
				_onStopCallback.call(_object, _object);
			}

			this.stopChainedTweens();
			return this;
		};

		this.end = function () {

			this.update(_startTime + _duration);
			return this;
		};

		this.stopChainedTweens = function () {

			for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
				_chainedTweens[i].stop();
			}
		};

		this.delay = function (amount) {

			_delayTime = amount;
			return this;
		};

		this.repeat = function (times) {

			_repeat = times;
			return this;
		};

		this.repeatDelay = function (amount) {

			_repeatDelayTime = amount;
			return this;
		};

		this.yoyo = function (yoyo) {

			_yoyo = yoyo;
			return this;
		};

		this.easing = function (easing) {

			_easingFunction = easing;
			return this;
		};

		this.interpolation = function (interpolation) {

			_interpolationFunction = interpolation;
			return this;
		};

		this.chain = function () {

			_chainedTweens = arguments;
			return this;
		};

		this.onStart = function (callback) {

			_onStartCallback = callback;
			return this;
		};

		this.onUpdate = function (callback) {

			_onUpdateCallback = callback;
			return this;
		};

		this.onComplete = function (callback) {

			_onCompleteCallback = callback;
			return this;
		};

		this.onStop = function (callback) {

			_onStopCallback = callback;
			return this;
		};

		this.update = function (time) {

			var property;
			var elapsed;
			var value;

			if (time < _startTime) {
				return true;
			}

			if (_onStartCallbackFired === false) {

				if (_onStartCallback !== null) {
					_onStartCallback.call(_object, _object);
				}

				_onStartCallbackFired = true;
			}

			elapsed = (time - _startTime) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;

			value = _easingFunction(elapsed);

			for (property in _valuesEnd) {

				// Don't update properties that do not exist in the source object
				if (_valuesStart[property] === undefined) {
					continue;
				}

				var start = _valuesStart[property] || 0;
				var end = _valuesEnd[property];

				if (end instanceof Array) {

					_object[property] = _interpolationFunction(end, value);
				} else {

					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof end === 'string') {

						if (end.charAt(0) === '+' || end.charAt(0) === '-') {
							end = start + parseFloat(end);
						} else {
							end = parseFloat(end);
						}
					}

					// Protect against non numeric properties.
					if (typeof end === 'number') {
						_object[property] = start + (end - start) * value;
					}
				}
			}

			if (_onUpdateCallback !== null) {
				_onUpdateCallback.call(_object, value);
			}

			if (elapsed === 1) {

				if (_repeat > 0) {

					if (isFinite(_repeat)) {
						_repeat--;
					}

					// Reassign starting values, restart by making startTime = now
					for (property in _valuesStartRepeat) {

						if (typeof _valuesEnd[property] === 'string') {
							_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
						}

						if (_yoyo) {
							var tmp = _valuesStartRepeat[property];

							_valuesStartRepeat[property] = _valuesEnd[property];
							_valuesEnd[property] = tmp;
						}

						_valuesStart[property] = _valuesStartRepeat[property];
					}

					if (_yoyo) {
						_reversed = !_reversed;
					}

					if (_repeatDelayTime !== undefined) {
						_startTime = time + _repeatDelayTime;
					} else {
						_startTime = time + _delayTime;
					}

					return true;
				} else {

					if (_onCompleteCallback !== null) {

						_onCompleteCallback.call(_object, _object);
					}

					for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						_chainedTweens[i].start(_startTime + _duration);
					}

					return false;
				}
			}

			return true;
		};
	};

	TWEEN.Easing = {

		Linear: {

			None: function None(k) {

				return k;
			}

		},

		Quadratic: {

			In: function In(k) {

				return k * k;
			},

			Out: function Out(k) {

				return k * (2 - k);
			},

			InOut: function InOut(k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}

				return -0.5 * (--k * (k - 2) - 1);
			}

		},

		Cubic: {

			In: function In(k) {

				return k * k * k;
			},

			Out: function Out(k) {

				return --k * k * k + 1;
			},

			InOut: function InOut(k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k + 2);
			}

		},

		Quartic: {

			In: function In(k) {

				return k * k * k * k;
			},

			Out: function Out(k) {

				return 1 - --k * k * k * k;
			},

			InOut: function InOut(k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}

				return -0.5 * ((k -= 2) * k * k * k - 2);
			}

		},

		Quintic: {

			In: function In(k) {

				return k * k * k * k * k;
			},

			Out: function Out(k) {

				return --k * k * k * k * k + 1;
			},

			InOut: function InOut(k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k * k * k + 2);
			}

		},

		Sinusoidal: {

			In: function In(k) {

				return 1 - Math.cos(k * Math.PI / 2);
			},

			Out: function Out(k) {

				return Math.sin(k * Math.PI / 2);
			},

			InOut: function InOut(k) {

				return 0.5 * (1 - Math.cos(Math.PI * k));
			}

		},

		Exponential: {

			In: function In(k) {

				return k === 0 ? 0 : Math.pow(1024, k - 1);
			},

			Out: function Out(k) {

				return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
			},

			InOut: function InOut(k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}

				return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
			}

		},

		Circular: {

			In: function In(k) {

				return 1 - Math.sqrt(1 - k * k);
			},

			Out: function Out(k) {

				return Math.sqrt(1 - --k * k);
			},

			InOut: function InOut(k) {

				if ((k *= 2) < 1) {
					return -0.5 * (Math.sqrt(1 - k * k) - 1);
				}

				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
			}

		},

		Elastic: {

			In: function In(k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			},

			Out: function Out(k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
			},

			InOut: function InOut(k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				k *= 2;

				if (k < 1) {
					return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
				}

				return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
			}

		},

		Back: {

			In: function In(k) {

				var s = 1.70158;

				return k * k * ((s + 1) * k - s);
			},

			Out: function Out(k) {

				var s = 1.70158;

				return --k * k * ((s + 1) * k + s) + 1;
			},

			InOut: function InOut(k) {

				var s = 1.70158 * 1.525;

				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}

				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
			}

		},

		Bounce: {

			In: function In(k) {

				return 1 - TWEEN.Easing.Bounce.Out(1 - k);
			},

			Out: function Out(k) {

				if (k < 1 / 2.75) {
					return 7.5625 * k * k;
				} else if (k < 2 / 2.75) {
					return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
				} else if (k < 2.5 / 2.75) {
					return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
				} else {
					return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
				}
			},

			InOut: function InOut(k) {

				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}

				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
			}

		}

	};

	TWEEN.Interpolation = {

		Linear: function Linear(v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
		},

		Bezier: function Bezier(v, k) {

			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;

			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}

			return b;
		},

		CatmullRom: function CatmullRom(v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;

			if (v[0] === v[m]) {

				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}

				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
			} else {

				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}

				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}

				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
			}
		},

		Utils: {

			Linear: function Linear(p0, p1, t) {

				return (p1 - p0) * t + p0;
			},

			Bernstein: function Bernstein(n, i) {

				var fc = TWEEN.Interpolation.Utils.Factorial;

				return fc(n) / fc(i) / fc(n - i);
			},

			Factorial: function () {

				var a = [1];

				return function (n) {

					var s = 1;

					if (a[n]) {
						return a[n];
					}

					for (var i = n; i > 1; i--) {
						s *= i;
					}

					a[n] = s;
					return s;
				};
			}(),

			CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {

				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;

				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
			}

		}

	};

	// UMD (Universal Module Definition)
	(function (root) {

		if (true) {

			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return TWEEN;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {

			// Node.js
			module.exports = TWEEN;
		} else if (root !== undefined) {

			// Global variable
			root.TWEEN = TWEEN;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	'use strict';

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) {
	    return [];
	};

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Mixins functionality to make an object have "plugins".
	 *
	 * @example
	 *      function MyObject() {}
	 *
	 *      pluginTarget.mixin(MyObject);
	 *
	 * @mixin
	 * @memberof Tiny
	 * @param {object} obj - The object to mix into.
	 */
	function pluginTarget(obj) {
	  obj.__plugins = {};

	  /**
	   * Adds a plugin to an object
	   *
	   * @param {string} pluginName - The events that should be listed.
	   * @param {Function} ctor - The constructor function for the plugin.
	   */
	  obj.registerPlugin = function registerPlugin(pluginName, ctor) {
	    obj.__plugins[pluginName] = ctor;
	  };

	  /**
	   * Instantiates all the plugins of this object
	   *
	   */
	  obj.prototype.initPlugins = function initPlugins() {
	    this.plugins = this.plugins || {};

	    for (var o in obj.__plugins) {
	      this.plugins[o] = new obj.__plugins[o](this);
	    }
	  };

	  /**
	   * Removes all the plugins of this object
	   *
	   */
	  obj.prototype.destroyPlugins = function destroyPlugins() {
	    for (var o in this.plugins) {
	      this.plugins[o].destroy();
	      this.plugins[o] = null;
	    }

	    this.plugins = null;
	  };
	}

	exports.default = {
	  /**
	   * Mixes in the properties of the pluginTarget into another object
	   *
	   * @param {object} obj - The obj to mix into
	   */
	  mixin: function mixin(obj) {
	    pluginTarget(obj);
	  }
	};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var gl = {
	    createContext: __webpack_require__(29),
	    setVertexAttribArrays: __webpack_require__(30),
	    GLBuffer: __webpack_require__(31),
	    GLFramebuffer: __webpack_require__(32),
	    GLShader: __webpack_require__(34),
	    GLTexture: __webpack_require__(33),
	    VertexArrayObject: __webpack_require__(43),
	    shader: __webpack_require__(44)
	};

	// Export for Node-compatible environments
	if (typeof module !== 'undefined' && module.exports) {
	    // Export the module
	    module.exports = gl;
	}

	// Add to the browser window pixi.gl
	if (typeof window !== 'undefined') {
	    // add the window object
	    window.PIXI = window.PIXI || {};
	    window.PIXI.glCore = gl;
	}

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Helper class to create a webGL Context
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
	 * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
	 *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
	 * @return {WebGLRenderingContext} the WebGL context
	 */
	var createContext = function createContext(canvas, options) {
	    var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);

	    if (!gl) {
	        // fail, not able to get a context
	        throw new Error('This browser does not support webGL. Try using the canvas renderer');
	    }

	    return gl;
	};

	module.exports = createContext;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	"use strict";

	// var GL_MAP = {};

	/**
	 * @param gl {WebGLRenderingContext} The current WebGL context
	 * @param attribs {*}
	 * @param state {*}
	 */
	var setVertexAttribArrays = function setVertexAttribArrays(gl, attribs, state) {
	    var i;
	    if (state) {
	        var tempAttribState = state.tempAttribState,
	            attribState = state.attribState;

	        for (i = 0; i < tempAttribState.length; i++) {
	            tempAttribState[i] = false;
	        }

	        // set the new attribs
	        for (i = 0; i < attribs.length; i++) {
	            tempAttribState[attribs[i].attribute.location] = true;
	        }

	        for (i = 0; i < attribState.length; i++) {
	            if (attribState[i] !== tempAttribState[i]) {
	                attribState[i] = tempAttribState[i];

	                if (state.attribState[i]) {
	                    gl.enableVertexAttribArray(i);
	                } else {
	                    gl.disableVertexAttribArray(i);
	                }
	            }
	        }
	    } else {
	        for (i = 0; i < attribs.length; i++) {
	            var attrib = attribs[i];
	            gl.enableVertexAttribArray(attrib.attribute.location);
	        }
	    }
	};

	module.exports = setVertexAttribArrays;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	"use strict";

	var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

	/**
	 * Helper class to create a webGL buffer
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
	 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
	 * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
	 */
	var Buffer = function Buffer(gl, type, data, drawType) {

	  /**
	      * The current WebGL rendering context
	      *
	      * @member {WebGLRenderingContext}
	      */
	  this.gl = gl;

	  /**
	      * The WebGL buffer, created upon instantiation
	      *
	      * @member {WebGLBuffer}
	      */
	  this.buffer = gl.createBuffer();

	  /**
	      * The type of the buffer
	      *
	      * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
	      */
	  this.type = type || gl.ARRAY_BUFFER;

	  /**
	      * The draw type of the buffer
	      *
	      * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
	      */
	  this.drawType = drawType || gl.STATIC_DRAW;

	  /**
	      * The data in the buffer, as a typed array
	      *
	      * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
	      */
	  this.data = EMPTY_ARRAY_BUFFER;

	  if (data) {
	    this.upload(data);
	  }

	  this._updateID = 0;
	};

	/**
	 * Uploads the buffer to the GPU
	 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
	 * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
	 * @param dontBind {Boolean} whether to bind the buffer before uploading it
	 */
	Buffer.prototype.upload = function (data, offset, dontBind) {
	  // todo - needed?
	  if (!dontBind) this.bind();

	  var gl = this.gl;

	  data = data || this.data;
	  offset = offset || 0;

	  if (this.data.byteLength >= data.byteLength) {
	    gl.bufferSubData(this.type, offset, data);
	  } else {
	    gl.bufferData(this.type, data, this.drawType);
	  }

	  this.data = data;
	};
	/**
	 * Binds the buffer
	 *
	 */
	Buffer.prototype.bind = function () {
	  var gl = this.gl;
	  gl.bindBuffer(this.type, this.buffer);
	};

	Buffer.createVertexBuffer = function (gl, data, drawType) {
	  return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
	};

	Buffer.createIndexBuffer = function (gl, data, drawType) {
	  return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
	};

	Buffer.create = function (gl, type, data, drawType) {
	  return new Buffer(gl, type, data, drawType);
	};

	/**
	 * Destroys the buffer
	 *
	 */
	Buffer.prototype.destroy = function () {
	  this.gl.deleteBuffer(this.buffer);
	};

	module.exports = Buffer;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Texture = __webpack_require__(33);

	/**
	 * Helper class to create a webGL Framebuffer
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param width {Number} the width of the drawing area of the frame buffer
	 * @param height {Number} the height of the drawing area of the frame buffer
	 */
	var Framebuffer = function Framebuffer(gl, width, height) {
	  /**
	   * The current WebGL rendering context
	   *
	   * @member {WebGLRenderingContext}
	   */
	  this.gl = gl;

	  /**
	   * The frame buffer
	   *
	   * @member {WebGLFramebuffer}
	   */
	  this.framebuffer = gl.createFramebuffer();

	  /**
	   * The stencil buffer
	   *
	   * @member {WebGLRenderbuffer}
	   */
	  this.stencil = null;

	  /**
	   * The stencil buffer
	   *
	   * @member {PIXI.glCore.GLTexture}
	   */
	  this.texture = null;

	  /**
	   * The width of the drawing area of the buffer
	   *
	   * @member {Number}
	   */
	  this.width = width || 100;
	  /**
	   * The height of the drawing area of the buffer
	   *
	   * @member {Number}
	   */
	  this.height = height || 100;
	};

	/**
	 * Adds a texture to the frame buffer
	 * @param texture {PIXI.glCore.GLTexture}
	 */
	Framebuffer.prototype.enableTexture = function (texture) {
	  var gl = this.gl;

	  this.texture = texture || new Texture(gl);

	  this.texture.bind();

	  //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	  this.bind();

	  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
	};

	/**
	 * Initialises the stencil buffer
	 */
	Framebuffer.prototype.enableStencil = function () {
	  if (this.stencil) return;

	  var gl = this.gl;

	  this.stencil = gl.createRenderbuffer();

	  gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

	  // TODO.. this is depth AND stencil?
	  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
	  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height);
	};

	/**
	 * Erases the drawing area and fills it with a colour
	 * @param  r {Number} the red value of the clearing colour
	 * @param  g {Number} the green value of the clearing colour
	 * @param  b {Number} the blue value of the clearing colour
	 * @param  a {Number} the alpha value of the clearing colour
	 */
	Framebuffer.prototype.clear = function (r, g, b, a) {
	  this.bind();

	  var gl = this.gl;

	  gl.clearColor(r, g, b, a);
	  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	};

	/**
	 * Binds the frame buffer to the WebGL context
	 */
	Framebuffer.prototype.bind = function () {
	  var gl = this.gl;
	  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	};

	/**
	 * Unbinds the frame buffer to the WebGL context
	 */
	Framebuffer.prototype.unbind = function () {
	  var gl = this.gl;
	  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	};
	/**
	 * Resizes the drawing area of the buffer to the given width and height
	 * @param  width  {Number} the new width
	 * @param  height {Number} the new height
	 */
	Framebuffer.prototype.resize = function (width, height) {
	  var gl = this.gl;

	  this.width = width;
	  this.height = height;

	  if (this.texture) {
	    this.texture.uploadData(null, width, height);
	  }

	  if (this.stencil) {
	    // update the stencil buffer width and height
	    gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
	    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
	  }
	};

	/**
	 * Destroys this buffer
	 */
	Framebuffer.prototype.destroy = function () {
	  var gl = this.gl;

	  //TODO
	  if (this.texture) {
	    this.texture.destroy();
	  }

	  gl.deleteFramebuffer(this.framebuffer);

	  this.gl = null;

	  this.stencil = null;
	  this.texture = null;
	};

	/**
	 * Creates a frame buffer with a texture containing the given data
	 * @static
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param width {Number} the width of the drawing area of the frame buffer
	 * @param height {Number} the height of the drawing area of the frame buffer
	 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
	 */
	Framebuffer.createRGBA = function (gl, width, height, data) {
	  var texture = Texture.fromData(gl, null, width, height);
	  texture.enableNearestScaling();
	  texture.enableWrapClamp();

	  //now create the framebuffer object and attach the texture to it.
	  var fbo = new Framebuffer(gl, width, height);
	  fbo.enableTexture(texture);

	  //fbo.enableStencil(); // get this back on soon!

	  fbo.unbind();

	  return fbo;
	};

	/**
	 * Creates a frame buffer with a texture containing the given data
	 * @static
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param width {Number} the width of the drawing area of the frame buffer
	 * @param height {Number} the height of the drawing area of the frame buffer
	 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
	 */
	Framebuffer.createFloat32 = function (gl, width, height, data) {
	  // create a new texture..
	  var texture = new Texture.fromData(gl, data, width, height);
	  texture.enableNearestScaling();
	  texture.enableWrapClamp();

	  //now create the framebuffer object and attach the texture to it.
	  var fbo = new Framebuffer(gl, width, height);
	  fbo.enableTexture(texture);

	  fbo.unbind();

	  return fbo;
	};

	module.exports = Framebuffer;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Helper class to create a WebGL Texture
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param gl {WebGLRenderingContext} The current WebGL context
	 * @param width {number} the width of the texture
	 * @param height {number} the height of the texture
	 * @param format {number} the pixel format of the texture. defaults to gl.RGBA
	 * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
	 */
	var Texture = function Texture(gl, width, height, format, type) {
		/**
	  * The current WebGL rendering context
	  *
	  * @member {WebGLRenderingContext}
	  */
		this.gl = gl;

		/**
	  * The WebGL texture
	  *
	  * @member {WebGLTexture}
	  */
		this.texture = gl.createTexture();

		/**
	  * If mipmapping was used for this texture, enable and disable with enableMipmap()
	  *
	  * @member {Boolean}
	  */
		// some settings..
		this.mipmap = false;

		/**
	  * Set to true to enable pre-multiplied alpha
	  *
	  * @member {Boolean}
	  */
		this.premultiplyAlpha = false;

		/**
	  * The width of texture
	  *
	  * @member {Number}
	  */
		this.width = width || -1;
		/**
	  * The height of texture
	  *
	  * @member {Number}
	  */
		this.height = height || -1;

		/**
	  * The pixel format of the texture. defaults to gl.RGBA
	  *
	  * @member {Number}
	  */
		this.format = format || gl.RGBA;

		/**
	  * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
	  *
	  * @member {Number}
	  */
		this.type = type || gl.UNSIGNED_BYTE;
	};

	/**
	 * Uploads this texture to the GPU
	 * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
	 */
	Texture.prototype.upload = function (source) {
		this.bind();

		var gl = this.gl;

		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

		var newWidth = source.videoWidth || source.width;
		var newHeight = source.videoHeight || source.height;

		if (newHeight !== this.height || newWidth !== this.width) {
			gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
		} else {
			gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
		}

		// if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
		this.width = newWidth;
		this.height = newHeight;
	};

	var FLOATING_POINT_AVAILABLE = false;

	/**
	 * Use a data source and uploads this texture to the GPU
	 * @param data {TypedArray} the data to upload to the texture
	 * @param width {number} the new width of the texture
	 * @param height {number} the new height of the texture
	 */
	Texture.prototype.uploadData = function (data, width, height) {
		this.bind();

		var gl = this.gl;

		if (data instanceof Float32Array) {
			if (!FLOATING_POINT_AVAILABLE) {
				var ext = gl.getExtension("OES_texture_float");

				if (ext) {
					FLOATING_POINT_AVAILABLE = true;
				} else {
					throw new Error('floating point textures not available');
				}
			}

			this.type = gl.FLOAT;
		} else {
			// TODO support for other types
			this.type = this.type || gl.UNSIGNED_BYTE;
		}

		// what type of data?
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

		if (width !== this.width || height !== this.height) {
			gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, data || null);
		} else {
			gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
		}

		this.width = width;
		this.height = height;

		//	texSubImage2D
	};

	/**
	 * Binds the texture
	 * @param  location
	 */
	Texture.prototype.bind = function (location) {
		var gl = this.gl;

		if (location !== undefined) {
			gl.activeTexture(gl.TEXTURE0 + location);
		}

		gl.bindTexture(gl.TEXTURE_2D, this.texture);
	};

	/**
	 * Unbinds the texture
	 */
	Texture.prototype.unbind = function () {
		var gl = this.gl;
		gl.bindTexture(gl.TEXTURE_2D, null);
	};

	/**
	 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
	 */
	Texture.prototype.minFilter = function (linear) {
		var gl = this.gl;

		this.bind();

		if (this.mipmap) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
		} else {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
		}
	};

	/**
	 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
	 */
	Texture.prototype.magFilter = function (linear) {
		var gl = this.gl;

		this.bind();

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
	};

	/**
	 * Enables mipmapping
	 */
	Texture.prototype.enableMipmap = function () {
		var gl = this.gl;

		this.bind();

		this.mipmap = true;

		gl.generateMipmap(gl.TEXTURE_2D);
	};

	/**
	 * Enables linear filtering
	 */
	Texture.prototype.enableLinearScaling = function () {
		this.minFilter(true);
		this.magFilter(true);
	};

	/**
	 * Enables nearest neighbour interpolation
	 */
	Texture.prototype.enableNearestScaling = function () {
		this.minFilter(false);
		this.magFilter(false);
	};

	/**
	 * Enables clamping on the texture so WebGL will not repeat it
	 */
	Texture.prototype.enableWrapClamp = function () {
		var gl = this.gl;

		this.bind();

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	};

	/**
	 * Enable tiling on the texture
	 */
	Texture.prototype.enableWrapRepeat = function () {
		var gl = this.gl;

		this.bind();

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	};

	Texture.prototype.enableWrapMirrorRepeat = function () {
		var gl = this.gl;

		this.bind();

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
	};

	/**
	 * Destroys this texture
	 */
	Texture.prototype.destroy = function () {
		var gl = this.gl;
		//TODO
		gl.deleteTexture(this.texture);
	};

	/**
	 * @static
	 * @param gl {WebGLRenderingContext} The current WebGL context
	 * @param source {HTMLImageElement|ImageData} the source image of the texture
	 * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
	 */
	Texture.fromSource = function (gl, source, premultiplyAlpha) {
		var texture = new Texture(gl);
		texture.premultiplyAlpha = premultiplyAlpha || false;
		texture.upload(source);

		return texture;
	};

	/**
	 * @static
	 * @param gl {WebGLRenderingContext} The current WebGL context
	 * @param data {TypedArray} the data to upload to the texture
	 * @param width {number} the new width of the texture
	 * @param height {number} the new height of the texture
	 */
	Texture.fromData = function (gl, data, width, height) {
		//console.log(data, width, height);
		var texture = new Texture(gl);
		texture.uploadData(data, width, height);

		return texture;
	};

	module.exports = Texture;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var compileProgram = __webpack_require__(35),
	    extractAttributes = __webpack_require__(36),
	    extractUniforms = __webpack_require__(39),
	    setPrecision = __webpack_require__(41),
	    generateUniformAccessObject = __webpack_require__(42);

	/**
	 * Helper class to create a webGL Shader
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param gl {WebGLRenderingContext}
	 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
	 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
	 * @param precision {precision]} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
	 * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
	 */
	var Shader = function Shader(gl, vertexSrc, fragmentSrc, precision, attributeLocations) {
		/**
	  * The current WebGL rendering context
	  *
	  * @member {WebGLRenderingContext}
	  */
		this.gl = gl;

		if (precision) {
			vertexSrc = setPrecision(vertexSrc, precision);
			fragmentSrc = setPrecision(fragmentSrc, precision);
		}

		/**
	  * The shader program
	  *
	  * @member {WebGLProgram}
	  */
		// First compile the program..
		this.program = compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations);

		/**
	  * The attributes of the shader as an object containing the following properties
	  * {
	  * 	type,
	  * 	size,
	  * 	location,
	  * 	pointer
	  * }
	  * @member {Object}
	  */
		// next extract the attributes
		this.attributes = extractAttributes(gl, this.program);

		this.uniformData = extractUniforms(gl, this.program);

		/**
	  * The uniforms of the shader as an object containing the following properties
	  * {
	  * 	gl,
	  * 	data
	  * }
	  * @member {Object}
	  */
		this.uniforms = generateUniformAccessObject(gl, this.uniformData);
	};
	/**
	 * Uses this shader
	 */
	Shader.prototype.bind = function () {
		this.gl.useProgram(this.program);
	};

	/**
	 * Destroys this shader
	 * TODO
	 */
	Shader.prototype.destroy = function () {
		this.attributes = null;
		this.uniformData = null;
		this.uniforms = null;

		var gl = this.gl;
		gl.deleteProgram(this.program);
	};

	module.exports = Shader;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
	 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
	 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
	 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
	 * @return {WebGLProgram} the shader program
	 */
	var compileProgram = function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations) {
	    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
	    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

	    var program = gl.createProgram();

	    gl.attachShader(program, glVertShader);
	    gl.attachShader(program, glFragShader);

	    // optionally, set the attributes manually for the program rather than letting WebGL decide..
	    if (attributeLocations) {
	        for (var i in attributeLocations) {
	            gl.bindAttribLocation(program, attributeLocations[i], i);
	        }
	    }

	    gl.linkProgram(program);

	    // if linking fails, then log and cleanup
	    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	        console.error('Pixi.js Error: Could not initialize shader.');
	        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
	        console.error('gl.getError()', gl.getError());

	        // if there is a program info log, log it
	        if (gl.getProgramInfoLog(program) !== '') {
	            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
	        }

	        gl.deleteProgram(program);
	        program = null;
	    }

	    // clean up some shaders
	    gl.deleteShader(glVertShader);
	    gl.deleteShader(glFragShader);

	    return program;
	};

	/**
	 * @private
	 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
	 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
	 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
	 * @return {WebGLShader} the shader
	 */
	var compileShader = function compileShader(gl, type, src) {
	    var shader = gl.createShader(type);

	    gl.shaderSource(shader, src);
	    gl.compileShader(shader);

	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	        console.log(gl.getShaderInfoLog(shader));
	        return null;
	    }

	    return shader;
	};

	module.exports = compileProgram;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var mapType = __webpack_require__(37);
	var mapSize = __webpack_require__(38);

	/**
	 * Extracts the attributes
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param program {WebGLProgram} The shader program to get the attributes from
	 * @return attributes {Object}
	 */
	var extractAttributes = function extractAttributes(gl, program) {
	    var attributes = {};

	    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

	    for (var i = 0; i < totalAttributes; i++) {
	        var attribData = gl.getActiveAttrib(program, i);
	        var type = mapType(gl, attribData.type);

	        attributes[attribData.name] = {
	            type: type,
	            size: mapSize(type),
	            location: gl.getAttribLocation(program, attribData.name),
	            //TODO - make an attribute object
	            pointer: pointer
	        };
	    }

	    return attributes;
	};

	var pointer = function pointer(type, normalized, stride, start) {
	    // console.log(this.location)
	    gl.vertexAttribPointer(this.location, this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
	};

	module.exports = extractAttributes;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';

	var mapSize = function mapSize(gl, type) {
	    if (!GL_TABLE) {
	        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

	        GL_TABLE = {};

	        for (var i = 0; i < typeNames.length; ++i) {
	            var tn = typeNames[i];
	            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
	        }
	    }

	    return GL_TABLE[type];
	};

	var GL_TABLE = null;

	var GL_TO_GLSL_TYPES = {
	    'FLOAT': 'float',
	    'FLOAT_VEC2': 'vec2',
	    'FLOAT_VEC3': 'vec3',
	    'FLOAT_VEC4': 'vec4',

	    'INT': 'int',
	    'INT_VEC2': 'ivec2',
	    'INT_VEC3': 'ivec3',
	    'INT_VEC4': 'ivec4',

	    'BOOL': 'bool',
	    'BOOL_VEC2': 'bvec2',
	    'BOOL_VEC3': 'bvec3',
	    'BOOL_VEC4': 'bvec4',

	    'FLOAT_MAT2': 'mat2',
	    'FLOAT_MAT3': 'mat3',
	    'FLOAT_MAT4': 'mat4',

	    'SAMPLER_2D': 'sampler2D'
	};

	module.exports = mapSize;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param type {String}
	 * @return {Number}
	 */
	var mapSize = function mapSize(type) {
	    return GLSL_TO_SIZE[type];
	};

	var GLSL_TO_SIZE = {
	    'float': 1,
	    'vec2': 2,
	    'vec3': 3,
	    'vec4': 4,

	    'int': 1,
	    'ivec2': 2,
	    'ivec3': 3,
	    'ivec4': 4,

	    'bool': 1,
	    'bvec2': 2,
	    'bvec3': 3,
	    'bvec4': 4,

	    'mat2': 4,
	    'mat3': 9,
	    'mat4': 16,

	    'sampler2D': 1
	};

	module.exports = mapSize;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var mapType = __webpack_require__(37);
	var defaultValue = __webpack_require__(40);

	/**
	 * Extracts the uniforms
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param program {WebGLProgram} The shader program to get the uniforms from
	 * @return uniforms {Object}
	 */
	var extractUniforms = function extractUniforms(gl, program) {
	  var uniforms = {};

	  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

	  for (var i = 0; i < totalUniforms; i++) {
	    var uniformData = gl.getActiveUniform(program, i);
	    var name = uniformData.name.replace(/\[.*?\]/, "");
	    var type = mapType(gl, uniformData.type);

	    uniforms[name] = {
	      type: type,
	      size: uniformData.size,
	      location: gl.getUniformLocation(program, name),
	      value: defaultValue(type, uniformData.size)
	    };
	  }

	  return uniforms;
	};

	module.exports = extractUniforms;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param type {String} Type of value
	 * @param size {Number}
	 */
	var defaultValue = function defaultValue(type, size) {
	    switch (type) {
	        case 'float':
	            return 0;

	        case 'vec2':
	            return new Float32Array(2 * size);

	        case 'vec3':
	            return new Float32Array(3 * size);

	        case 'vec4':
	            return new Float32Array(4 * size);

	        case 'int':
	        case 'sampler2D':
	            return 0;

	        case 'ivec2':
	            return new Int32Array(2 * size);

	        case 'ivec3':
	            return new Int32Array(3 * size);

	        case 'ivec4':
	            return new Int32Array(4 * size);

	        case 'bool':
	            return false;

	        case 'bvec2':

	            return booleanArray(2 * size);

	        case 'bvec3':
	            return booleanArray(3 * size);

	        case 'bvec4':
	            return booleanArray(4 * size);

	        case 'mat2':
	            return new Float32Array([1, 0, 0, 1]);

	        case 'mat3':
	            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);

	        case 'mat4':
	            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
	    }
	};

	var booleanArray = function booleanArray(size) {
	    var array = new Array(size);

	    for (var i = 0; i < array.length; i++) {
	        array[i] = false;
	    }

	    return array;
	};

	module.exports = defaultValue;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Sets the float precision on the shader. If the precision is already present this function will do nothing
	 * @param {string} src       the shader source
	 * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
	 *
	 * @return {string} modified shader source
	 */
	var setPrecision = function setPrecision(src, precision) {
	    if (src.substring(0, 9) !== 'precision') {
	        return 'precision ' + precision + ' float;\n' + src;
	    }

	    return src;
	};

	module.exports = setPrecision;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Extracts the attributes
	 * @class
	 * @memberof PIXI.glCore.shader
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 * @param uniforms {Array} @mat ?
	 * @return attributes {Object}
	 */
	var generateUniformAccessObject = function generateUniformAccessObject(gl, uniformData) {
	    // this is the object we will be sending back.
	    // an object hierachy will be created for structs
	    var uniforms = { data: {} };

	    uniforms.gl = gl;

	    var uniformKeys = Object.keys(uniformData);

	    for (var i = 0; i < uniformKeys.length; i++) {
	        var fullName = uniformKeys[i];

	        var nameTokens = fullName.split('.');
	        var name = nameTokens[nameTokens.length - 1];

	        var uniformGroup = getUniformGroup(nameTokens, uniforms);

	        var uniform = uniformData[fullName];
	        uniformGroup.data[name] = uniform;

	        uniformGroup.gl = gl;

	        Object.defineProperty(uniformGroup, name, {
	            get: generateGetter(name),
	            set: generateSetter(name, uniform)
	        });
	    }

	    return uniforms;
	};

	var generateGetter = function generateGetter(name) {
	    var template = getterTemplate.replace('%%', name);
	    return new Function(template); // jshint ignore:line
	};

	var generateSetter = function generateSetter(name, uniform) {
	    var template = setterTemplate.replace(/%%/g, name);
	    var setTemplate;

	    if (uniform.size === 1) {
	        setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type];
	    } else {
	        setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type];
	    }

	    if (setTemplate) {
	        template += "\nthis.gl." + setTemplate + ";";
	    }

	    return new Function('value', template); // jshint ignore:line
	};

	var getUniformGroup = function getUniformGroup(nameTokens, uniform) {
	    var cur = uniform;

	    for (var i = 0; i < nameTokens.length - 1; i++) {
	        var o = cur[nameTokens[i]] || { data: {} };
	        cur[nameTokens[i]] = o;
	        cur = o;
	    }

	    return cur;
	};

	var getterTemplate = ['return this.data.%%.value;'].join('\n');

	var setterTemplate = ['this.data.%%.value = value;', 'var location = this.data.%%.location;'].join('\n');

	var GLSL_TO_SINGLE_SETTERS = {

	    'float': 'uniform1f(location, value)',

	    'vec2': 'uniform2f(location, value[0], value[1])',
	    'vec3': 'uniform3f(location, value[0], value[1], value[2])',
	    'vec4': 'uniform4f(location, value[0], value[1], value[2], value[3])',

	    'int': 'uniform1i(location, value)',
	    'ivec2': 'uniform2i(location, value[0], value[1])',
	    'ivec3': 'uniform3i(location, value[0], value[1], value[2])',
	    'ivec4': 'uniform4i(location, value[0], value[1], value[2], value[3])',

	    'bool': 'uniform1i(location, value)',
	    'bvec2': 'uniform2i(location, value[0], value[1])',
	    'bvec3': 'uniform3i(location, value[0], value[1], value[2])',
	    'bvec4': 'uniform4i(location, value[0], value[1], value[2], value[3])',

	    'mat2': 'uniformMatrix2fv(location, false, value)',
	    'mat3': 'uniformMatrix3fv(location, false, value)',
	    'mat4': 'uniformMatrix4fv(location, false, value)',

	    'sampler2D': 'uniform1i(location, value)'
	};

	var GLSL_TO_ARRAY_SETTERS = {

	    'float': 'uniform1fv(location, value)',

	    'vec2': 'uniform2fv(location, value)',
	    'vec3': 'uniform3fv(location, value)',
	    'vec4': 'uniform4fv(location, value)',

	    'int': 'uniform1iv(location, value)',
	    'ivec2': 'uniform2iv(location, value)',
	    'ivec3': 'uniform3iv(location, value)',
	    'ivec4': 'uniform4iv(location, value)',

	    'bool': 'uniform1iv(location, value)',
	    'bvec2': 'uniform2iv(location, value)',
	    'bvec3': 'uniform3iv(location, value)',
	    'bvec4': 'uniform4iv(location, value)',

	    'sampler2D': 'uniform1iv(location, value)'
	};

	module.exports = generateUniformAccessObject;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	// state object//
	var setVertexAttribArrays = __webpack_require__(30);

	/**
	 * Helper class to work with WebGL VertexArrayObjects (vaos)
	 * Only works if WebGL extensions are enabled (they usually are)
	 *
	 * @class
	 * @memberof PIXI.glCore
	 * @param gl {WebGLRenderingContext} The current WebGL rendering context
	 */
	function VertexArrayObject(gl, state) {
	    this.nativeVaoExtension = null;

	    if (!VertexArrayObject.FORCE_NATIVE) {
	        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
	    }

	    this.nativeState = state;

	    if (this.nativeVaoExtension) {
	        this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

	        var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

	        // VAO - overwrite the state..
	        this.nativeState = {
	            tempAttribState: new Array(maxAttribs),
	            attribState: new Array(maxAttribs)
	        };
	    }

	    /**
	     * The current WebGL rendering context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    /**
	     * An array of attributes
	     *
	     * @member {Array}
	     */
	    this.attributes = [];

	    /**
	     * @member {PIXI.glCore.GLBuffer}
	     */
	    this.indexBuffer = null;

	    /**
	     * A boolean flag
	     *
	     * @member {Boolean}
	     */
	    this.dirty = false;
	}

	VertexArrayObject.prototype.constructor = VertexArrayObject;
	module.exports = VertexArrayObject;

	/**
	* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
	* If you find on older devices that things have gone a bit weird then set this to true.
	*/
	/**
	 * Lets the VAO know if you should use the WebGL extension or the native methods.
	 * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
	 * If you find on older devices that things have gone a bit weird then set this to true.
	 * @static
	 * @property {Boolean} FORCE_NATIVE
	 */
	VertexArrayObject.FORCE_NATIVE = false;

	/**
	 * Binds the buffer
	 */
	VertexArrayObject.prototype.bind = function () {
	    if (this.nativeVao) {
	        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

	        if (this.dirty) {
	            this.dirty = false;
	            this.activate();
	        }
	    } else {

	        this.activate();
	    }

	    return this;
	};

	/**
	 * Unbinds the buffer
	 */
	VertexArrayObject.prototype.unbind = function () {
	    if (this.nativeVao) {
	        this.nativeVaoExtension.bindVertexArrayOES(null);
	    }

	    return this;
	};

	/**
	 * Uses this vao
	 */
	VertexArrayObject.prototype.activate = function () {

	    var gl = this.gl;
	    var lastBuffer = null;

	    for (var i = 0; i < this.attributes.length; i++) {
	        var attrib = this.attributes[i];

	        if (lastBuffer !== attrib.buffer) {
	            attrib.buffer.bind();
	            lastBuffer = attrib.buffer;
	        }

	        gl.vertexAttribPointer(attrib.attribute.location, attrib.attribute.size, attrib.type || gl.FLOAT, attrib.normalized || false, attrib.stride || 0, attrib.start || 0);
	    }

	    setVertexAttribArrays(gl, this.attributes, this.nativeState);

	    if (this.indexBuffer) {
	        this.indexBuffer.bind();
	    }

	    return this;
	};

	/**
	 *
	 * @param buffer     {PIXI.gl.GLBuffer}
	 * @param attribute  {*}
	 * @param type       {String}
	 * @param normalized {Boolean}
	 * @param stride     {Number}
	 * @param start      {Number}
	 */
	VertexArrayObject.prototype.addAttribute = function (buffer, attribute, type, normalized, stride, start) {
	    this.attributes.push({
	        buffer: buffer,
	        attribute: attribute,

	        location: attribute.location,
	        type: type || this.gl.FLOAT,
	        normalized: normalized || false,
	        stride: stride || 0,
	        start: start || 0
	    });

	    this.dirty = true;

	    return this;
	};

	/**
	 *
	 * @param buffer   {PIXI.gl.GLBuffer}
	 */
	VertexArrayObject.prototype.addIndex = function (buffer /*, options*/) {
	    this.indexBuffer = buffer;

	    this.dirty = true;

	    return this;
	};

	/**
	 * Unbinds this vao and disables it
	 */
	VertexArrayObject.prototype.clear = function () {
	    // var gl = this.gl;

	    // TODO - should this function unbind after clear?
	    // for now, no but lets see what happens in the real world!
	    if (this.nativeVao) {
	        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
	    }

	    this.attributes.length = 0;
	    this.indexBuffer = null;

	    return this;
	};

	/**
	 * @param type  {Number}
	 * @param size  {Number}
	 * @param start {Number}
	 */
	VertexArrayObject.prototype.draw = function (type, size, start) {
	    var gl = this.gl;

	    if (this.indexBuffer) {
	        gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
	    } else {
	        // TODO need a better way to calculate size..
	        gl.drawArrays(type, start, size || this.getSize());
	    }

	    return this;
	};

	/**
	 * Destroy this vao
	 */
	VertexArrayObject.prototype.destroy = function () {
	    // lose references
	    this.gl = null;
	    this.indexBuffer = null;
	    this.attributes = null;
	    this.nativeState = null;

	    if (this.nativeVao) {
	        this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
	    }

	    this.nativeVaoExtension = null;
	    this.nativeVao = null;
	};

	VertexArrayObject.prototype.getSize = function () {
	    var attrib = this.attributes[0];
	    return attrib.buffer.data.length / (attrib.stride / 4 || attrib.attribute.size);
	};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	    compileProgram: __webpack_require__(35),
	    defaultValue: __webpack_require__(40),
	    extractAttributes: __webpack_require__(36),
	    extractUniforms: __webpack_require__(39),
	    generateUniformAccessObject: __webpack_require__(42),
	    setPrecision: __webpack_require__(41),
	    mapSize: __webpack_require__(38),
	    mapType: __webpack_require__(37)
	};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _math = __webpack_require__(8);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 'Builder' pattern for bounds rectangles
	 * Axis-Aligned Bounding Box
	 * It is not a shape! Its mutable thing, no 'EMPTY' or that kind of problems
	 *
	 * @class
	 * @memberOf Tiny
	 */
	var Bounds = function () {
	  /**
	   *
	   */
	  function Bounds() {
	    _classCallCheck(this, Bounds);

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.minX = Infinity;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.minY = Infinity;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.maxX = -Infinity;

	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.maxY = -Infinity;

	    this.rect = null;
	  }

	  /**
	   * Checks if bounds are empty.
	   *
	   * @return {boolean} True if empty.
	   */


	  _createClass(Bounds, [{
	    key: 'isEmpty',
	    value: function isEmpty() {
	      return this.minX > this.maxX || this.minY > this.maxY;
	    }

	    /**
	     * Clears the bounds and resets.
	     *
	     */

	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.updateID++;

	      this.minX = Infinity;
	      this.minY = Infinity;
	      this.maxX = -Infinity;
	      this.maxY = -Infinity;
	    }

	    /**
	     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
	     * It is not guaranteed that it will return tempRect
	     *
	     * @param {Tiny.Rectangle} rect - temporary object will be used if AABB is not empty
	     * @return {Tiny.Rectangle} A rectangle of the bounds
	     */

	  }, {
	    key: 'getRectangle',
	    value: function getRectangle(rect) {
	      if (this.minX > this.maxX || this.minY > this.maxY) {
	        return _math.Rectangle.EMPTY;
	      }

	      rect = rect || new _math.Rectangle(0, 0, 1, 1);

	      rect.x = this.minX;
	      rect.y = this.minY;
	      rect.width = this.maxX - this.minX;
	      rect.height = this.maxY - this.minY;

	      return rect;
	    }

	    /**
	     * This function should be inlined when its possible.
	     *
	     * @param {Tiny.Point} point - The point to add.
	     */

	  }, {
	    key: 'addPoint',
	    value: function addPoint(point) {
	      this.minX = Math.min(this.minX, point.x);
	      this.maxX = Math.max(this.maxX, point.x);
	      this.minY = Math.min(this.minY, point.y);
	      this.maxY = Math.max(this.maxY, point.y);
	    }

	    /**
	     * Adds a quad, not transformed
	     *
	     * @param {Float32Array} vertices - The verts to add.
	     */

	  }, {
	    key: 'addQuad',
	    value: function addQuad(vertices) {
	      var minX = this.minX;
	      var minY = this.minY;
	      var maxX = this.maxX;
	      var maxY = this.maxY;

	      var x = vertices[0];
	      var y = vertices[1];

	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = vertices[2];
	      y = vertices[3];
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = vertices[4];
	      y = vertices[5];
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = vertices[6];
	      y = vertices[7];
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      this.minX = minX;
	      this.minY = minY;
	      this.maxX = maxX;
	      this.maxY = maxY;
	    }

	    /**
	     * Adds sprite frame, transformed.
	     *
	     * @param {Tiny.TransformBase} transform - TODO
	     * @param {number} x0 - TODO
	     * @param {number} y0 - TODO
	     * @param {number} x1 - TODO
	     * @param {number} y1 - TODO
	     */

	  }, {
	    key: 'addFrame',
	    value: function addFrame(transform, x0, y0, x1, y1) {
	      var matrix = transform.worldTransform;
	      var a = matrix.a;
	      var b = matrix.b;
	      var c = matrix.c;
	      var d = matrix.d;
	      var tx = matrix.tx;
	      var ty = matrix.ty;

	      var minX = this.minX;
	      var minY = this.minY;
	      var maxX = this.maxX;
	      var maxY = this.maxY;

	      var x = a * x0 + c * y0 + tx;
	      var y = b * x0 + d * y0 + ty;

	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = a * x1 + c * y0 + tx;
	      y = b * x1 + d * y0 + ty;
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = a * x0 + c * y1 + tx;
	      y = b * x0 + d * y1 + ty;
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      x = a * x1 + c * y1 + tx;
	      y = b * x1 + d * y1 + ty;
	      minX = x < minX ? x : minX;
	      minY = y < minY ? y : minY;
	      maxX = x > maxX ? x : maxX;
	      maxY = y > maxY ? y : maxY;

	      this.minX = minX;
	      this.minY = minY;
	      this.maxX = maxX;
	      this.maxY = maxY;
	    }

	    /**
	     * Add an array of vertices
	     *
	     * @param {Tiny.TransformBase} transform - TODO
	     * @param {Float32Array} vertices - TODO
	     * @param {number} beginOffset - TODO
	     * @param {number} endOffset - TODO
	     */

	  }, {
	    key: 'addVertices',
	    value: function addVertices(transform, vertices, beginOffset, endOffset) {
	      var matrix = transform.worldTransform;
	      var a = matrix.a;
	      var b = matrix.b;
	      var c = matrix.c;
	      var d = matrix.d;
	      var tx = matrix.tx;
	      var ty = matrix.ty;

	      var minX = this.minX;
	      var minY = this.minY;
	      var maxX = this.maxX;
	      var maxY = this.maxY;

	      for (var i = beginOffset; i < endOffset; i += 2) {
	        var rawX = vertices[i];
	        var rawY = vertices[i + 1];
	        var x = a * rawX + c * rawY + tx;
	        var y = d * rawY + b * rawX + ty;

	        minX = x < minX ? x : minX;
	        minY = y < minY ? y : minY;
	        maxX = x > maxX ? x : maxX;
	        maxY = y > maxY ? y : maxY;
	      }

	      this.minX = minX;
	      this.minY = minY;
	      this.maxX = maxX;
	      this.maxY = maxY;
	    }

	    /**
	     * Adds other Bounds
	     *
	     * @param {Tiny.Bounds} bounds - TODO
	     */

	  }, {
	    key: 'addBounds',
	    value: function addBounds(bounds) {
	      var minX = this.minX;
	      var minY = this.minY;
	      var maxX = this.maxX;
	      var maxY = this.maxY;

	      this.minX = bounds.minX < minX ? bounds.minX : minX;
	      this.minY = bounds.minY < minY ? bounds.minY : minY;
	      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
	      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
	    }

	    /**
	     * Adds other Bounds, masked with Bounds
	     *
	     * @param {Tiny.Bounds} bounds - TODO
	     * @param {Tiny.Bounds} mask - TODO
	     */

	  }, {
	    key: 'addBoundsMask',
	    value: function addBoundsMask(bounds, mask) {
	      var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
	      var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
	      var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
	      var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;

	      if (_minX <= _maxX && _minY <= _maxY) {
	        var minX = this.minX;
	        var minY = this.minY;
	        var maxX = this.maxX;
	        var maxY = this.maxY;

	        this.minX = _minX < minX ? _minX : minX;
	        this.minY = _minY < minY ? _minY : minY;
	        this.maxX = _maxX > maxX ? _maxX : maxX;
	        this.maxY = _maxY > maxY ? _maxY : maxY;
	      }
	    }

	    /**
	     * Adds other Bounds, masked with Rectangle
	     *
	     * @param {Tiny.Bounds} bounds - TODO
	     * @param {Tiny.Rectangle} area - TODO
	     */

	  }, {
	    key: 'addBoundsArea',
	    value: function addBoundsArea(bounds, area) {
	      var _minX = bounds.minX > area.x ? bounds.minX : area.x;
	      var _minY = bounds.minY > area.y ? bounds.minY : area.y;
	      var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
	      var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;

	      if (_minX <= _maxX && _minY <= _maxY) {
	        var minX = this.minX;
	        var minY = this.minY;
	        var maxX = this.maxX;
	        var maxY = this.maxY;

	        this.minX = _minX < minX ? _minX : minX;
	        this.minY = _minY < minY ? _minY : minY;
	        this.maxX = _maxX > maxX ? _maxX : maxX;
	        this.maxY = _maxY > maxY ? _maxY : maxY;
	      }
	    }
	  }]);

	  return Bounds;
	}();

	exports.default = Bounds;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _TransformStatic = __webpack_require__(47);

	var _TransformStatic2 = _interopRequireDefault(_TransformStatic);

	var _Transform = __webpack_require__(49);

	var _Transform2 = _interopRequireDefault(_Transform);

	var _Bounds = __webpack_require__(45);

	var _Bounds2 = _interopRequireDefault(_Bounds);

	var _math = __webpack_require__(8);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * `The base class for all objects that are rendered on the screen.`
	 * This is an abstract class and should not be used on its own rather it should be extended.
	 *
	 * @class
	 * @extends EventEmitter
	 * @mixes Tiny.interaction.interactiveTarget
	 * @memberof Tiny
	 */
	var DisplayObject = function (_EventEmitter) {
	  _inherits(DisplayObject, _EventEmitter);

	  /**
	   *
	   */
	  function DisplayObject() {
	    _classCallCheck(this, DisplayObject);

	    var _this = _possibleConstructorReturn(this, (DisplayObject.__proto__ || Object.getPrototypeOf(DisplayObject)).call(this));

	    var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;

	    _this.tempDisplayObjectParent = null;

	    /**
	     * World transform and local transform of this object.
	     * This will become read-only later, please do not assign anything there unless you know what are you doing
	     *
	     * @member {Tiny.TransformBase}
	     */
	    _this.transform = new TransformClass();

	    /**
	     * The opacity of the object.
	     *
	     * @member {number}
	     */
	    _this.alpha = 1;

	    /**
	     * The visibility of the object. If false the object will not be drawn, and
	     * the updateTransform function will not be called.
	     *
	     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually
	     *
	     * @member {boolean}
	     */
	    _this.visible = true;

	    /**
	     * Can this object be rendered, if false the object will not be drawn but the updateTransform
	     * methods will still be called.
	     *
	     * Only affects recursive calls from parent. You can ask for bounds manually
	     *
	     * @member {boolean}
	     */
	    _this.renderable = true;

	    /**
	     * The display object container that contains this display object.
	     *
	     * @member {Tiny.Container}
	     * @readonly
	     */
	    _this.parent = null;

	    /**
	     * The multiplied alpha of the displayObject
	     *
	     * @member {number}
	     * @readonly
	     */
	    _this.worldAlpha = 1;

	    /**
	     * The area the filter is applied to. This is used as more of an optimisation
	     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
	     *
	     * Also works as an interaction mask
	     *
	     * @member {Tiny.Rectangle}
	     */
	    _this.filterArea = null;

	    _this._filters = null;
	    _this._enabledFilters = null;

	    /**
	     * The bounds object, this is used to calculate and store the bounds of the displayObject
	     *
	     * @member {Tiny.Rectangle}
	     * @private
	     */
	    _this._bounds = new _Bounds2.default();
	    _this._boundsID = 0;
	    _this._lastBoundsID = -1;
	    _this._boundsRect = null;
	    _this._localBoundsRect = null;

	    /**
	     * The original, cached mask of the object
	     *
	     * @member {Tiny.Rectangle}
	     * @private
	     */
	    _this._mask = null;

	    _this.angle = 0;
	    return _this;
	  }

	  /**
	   * @member {Tiny.DisplayObject}
	   * @private
	   */


	  _createClass(DisplayObject, [{
	    key: 'updateTransform',


	    /**
	     * Updates the object transform for rendering
	     */
	    value: function updateTransform() {
	      this.transform.updateTransform(this.parent.transform);
	      // multiply the alphas..
	      this.worldAlpha = this.alpha * this.parent.worldAlpha;

	      this._bounds.updateID++;
	    }

	    /**
	     * recursively updates transform of all objects from the root to this one
	     * internal function for toLocal()
	     */

	  }, {
	    key: '_recursivePostUpdateTransform',
	    value: function _recursivePostUpdateTransform() {
	      if (this.parent) {
	        this.parent._recursivePostUpdateTransform();
	        this.transform.updateTransform(this.parent.transform);
	      } else {
	        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
	      }
	    }

	    /**
	     * Retrieves the bounds of the displayObject as a rectangle object.
	     *
	     * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
	     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
	     *  nice performance boost
	     * @param {Tiny.Rectangle} rect - Optional rectangle to store the result of the bounds calculation
	     * @return {Tiny.Rectangle} the rectangular bounding area
	     */

	  }, {
	    key: 'getBounds',
	    value: function getBounds(skipUpdate, rect) {
	      if (!skipUpdate) {
	        if (!this.parent) {
	          this.parent = this._tempDisplayObjectParent;
	          this.updateTransform();
	          this.parent = null;
	        } else {
	          this._recursivePostUpdateTransform();
	          this.updateTransform();
	        }
	      }

	      if (this._boundsID !== this._lastBoundsID) {
	        this.calculateBounds();
	      }

	      if (!rect) {
	        if (!this._boundsRect) {
	          this._boundsRect = new _math.Rectangle();
	        }

	        rect = this._boundsRect;
	      }

	      return this._bounds.getRectangle(rect);
	    }

	    /**
	     * Retrieves the local bounds of the displayObject as a rectangle object
	     *
	     * @param {Tiny.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation
	     * @return {Tiny.Rectangle} the rectangular bounding area
	     */

	  }, {
	    key: 'getLocalBounds',
	    value: function getLocalBounds(rect) {
	      var transformRef = this.transform;
	      var parentRef = this.parent;

	      this.parent = null;
	      this.transform = this._tempDisplayObjectParent.transform;

	      if (!rect) {
	        if (!this._localBoundsRect) {
	          this._localBoundsRect = new _math.Rectangle();
	        }

	        rect = this._localBoundsRect;
	      }

	      var bounds = this.getBounds(false, rect);

	      this.parent = parentRef;
	      this.transform = transformRef;

	      return bounds;
	    }

	    /**
	     * Calculates the global position of the display object
	     *
	     * @param {Tiny.Point} position - The world origin to calculate from
	     * @param {Tiny.Point} [point] - A Point object in which to store the value, optional
	     *  (otherwise will create a new Point)
	     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
	     * @return {Tiny.Point} A point object representing the position of this object
	     */

	  }, {
	    key: 'toGlobal',
	    value: function toGlobal(position, point) {
	      var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      if (!skipUpdate) {
	        this._recursivePostUpdateTransform();

	        // this parent check is for just in case the item is a root object.
	        // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
	        // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
	        if (!this.parent) {
	          this.parent = this._tempDisplayObjectParent;
	          this.displayObjectUpdateTransform();
	          this.parent = null;
	        } else {
	          this.displayObjectUpdateTransform();
	        }
	      }

	      // don't need to update the lot
	      return this.worldTransform.apply(position, point);
	    }

	    /**
	     * Calculates the local position of the display object relative to another point
	     *
	     * @param {Tiny.Point} position - The world origin to calculate from
	     * @param {Tiny.DisplayObject} [from] - The DisplayObject to calculate the global position from
	     * @param {Tiny.Point} [point] - A Point object in which to store the value, optional
	     *  (otherwise will create a new Point)
	     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
	     * @return {Tiny.Point} A point object representing the position of this object
	     */

	  }, {
	    key: 'toLocal',
	    value: function toLocal(position, from, point, skipUpdate) {
	      if (from) {
	        position = from.toGlobal(position, point, skipUpdate);
	      }

	      if (!skipUpdate) {
	        this._recursivePostUpdateTransform();

	        // this parent check is for just in case the item is a root object.
	        // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
	        // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
	        if (!this.parent) {
	          this.parent = this._tempDisplayObjectParent;
	          this.displayObjectUpdateTransform();
	          this.parent = null;
	        } else {
	          this.displayObjectUpdateTransform();
	        }
	      }

	      // simply apply the matrix..
	      return this.worldTransform.applyInverse(position, point);
	    }

	    /**
	     * Renders the object using the WebGL renderer
	     *
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {} // eslint-disable-line no-unused-vars
	    // OVERWRITE;


	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {} // eslint-disable-line no-unused-vars
	    // OVERWRITE;


	    /**
	     * Set the parent Container of this DisplayObject
	     *
	     * @param {Tiny.Container} container - The Container to add this DisplayObject to
	     * @return {Tiny.Container} The Container that this DisplayObject was added to
	     */

	  }, {
	    key: 'setParent',
	    value: function setParent(container) {
	      if (!container || !container.addChild) {
	        throw new Error('setParent: Argument must be a Container');
	      }

	      container.addChild(this);

	      return container;
	    }

	    /**
	     * Convenience function to set the position, scale, skew and pivot at once.
	     *
	     * @param {number} [x=0] - The X position
	     * @param {number} [y=0] - The Y position
	     * @param {number} [scaleX=1] - The X scale value
	     * @param {number} [scaleY=1] - The Y scale value
	     * @param {number} [rotation=0] - The rotation
	     * @param {number} [skewX=0] - The X skew value
	     * @param {number} [skewY=0] - The Y skew value
	     * @param {number} [pivotX=0] - The X pivot value
	     * @param {number} [pivotY=0] - The Y pivot value
	     * @return {Tiny.DisplayObject} The DisplayObject instance
	     */

	  }, {
	    key: 'setTransform',
	    value: function setTransform() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
	      var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	      var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	      var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
	      var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
	      var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

	      this.position.x = x;
	      this.position.y = y;
	      this.scale.x = !scaleX ? 1 : scaleX;
	      this.scale.y = !scaleY ? 1 : scaleY;
	      this.rotation = rotation;
	      this.skew.x = skewX;
	      this.skew.y = skewY;
	      this.pivot.x = pivotX;
	      this.pivot.y = pivotY;

	      return this;
	    }

	    /**
	     *
	     * @param b
	     */

	  }, {
	    key: 'setEventEnabled',
	    value: function setEventEnabled(b) {
	      this.interactive = !!b;
	    }
	  }, {
	    key: 'setPosition',
	    value: function setPosition(x, y) {
	      this.position.set(x, y === void 0 ? x : y);
	    }
	  }, {
	    key: 'getPosition',
	    value: function getPosition() {
	      return this.position;
	    }
	  }, {
	    key: 'setPositionX',
	    value: function setPositionX(x) {
	      this.x = x;
	    }
	  }, {
	    key: 'getPositionX',
	    value: function getPositionX() {
	      return this.x;
	    }
	  }, {
	    key: 'setPositionY',
	    value: function setPositionY(y) {
	      this.y = y;
	    }
	  }, {
	    key: 'getPositionY',
	    value: function getPositionY() {
	      return this.y;
	    }
	  }, {
	    key: 'setPivot',
	    value: function setPivot(x, y) {
	      this.pivot.set(x, y === void 0 ? x : y);
	    }
	  }, {
	    key: 'setRotation',
	    value: function setRotation(rotation) {
	      this.rotation = rotation;
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(alpha) {
	      this.alpha = alpha;
	    }
	  }, {
	    key: 'getOpacity',
	    value: function getOpacity() {
	      return this.alpha;
	    }
	  }, {
	    key: 'setVisible',
	    value: function setVisible(visible) {
	      this.visible = visible;
	    }
	  }, {
	    key: 'setScale',
	    value: function setScale(x, y) {
	      this.scale.set(x, y === void 0 ? x : y);
	    }
	  }, {
	    key: 'getNature',
	    value: function getNature() {
	      return {
	        x: this.x,
	        y: this.y,
	        angle: this.angle,
	        rotation: this.rotation,
	        visible: this.visible,
	        alpha: this.alpha,
	        scaleX: this.scale.x,
	        scaleY: this.scale.y,
	        tint: this.tint
	      };
	    }

	    /**
	     * Base destroy method for generic display objects. This will automatically
	     * remove the display object from its parent Container as well as remove
	     * all current event listeners and internal references. Do not use a DisplayObject
	     * after calling `destroy`.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.removeAllListeners();
	      if (this.parent) {
	        this.parent.removeChild(this);
	      }
	      this.transform = null;

	      this.parent = null;

	      this._bounds = null;
	      this._currentBounds = null;
	      this._mask = null;

	      this.filterArea = null;

	      this.interactive = false;
	      this.interactiveChildren = false;
	    }

	    /**
	     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
	     * An alias to position.x
	     *
	     * @member {number}
	     */

	  }, {
	    key: '_tempDisplayObjectParent',
	    get: function get() {
	      if (this.tempDisplayObjectParent === null) {
	        this.tempDisplayObjectParent = new DisplayObject();
	      }

	      return this.tempDisplayObjectParent;
	    }
	  }, {
	    key: 'x',
	    get: function get() {
	      return this.position.x;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.position.x = value;
	    }

	    /**
	     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
	     * An alias to position.y
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'y',
	    get: function get() {
	      return this.position.y;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.position.y = value;
	    }

	    /**
	     * Current transform of the object based on world (parent) factors
	     *
	     * @member {Tiny.Matrix}
	     * @readonly
	     */

	  }, {
	    key: 'worldTransform',
	    get: function get() {
	      return this.transform.worldTransform;
	    }

	    /**
	     * Current transform of the object based on local factors: position, scale, other stuff
	     *
	     * @member {Tiny.Matrix}
	     * @readonly
	     */

	  }, {
	    key: 'localTransform',
	    get: function get() {
	      return this.transform.localTransform;
	    }

	    /**
	     * The coordinate of the object relative to the local coordinates of the parent.
	     * Assignment by value since pixi-v4.
	     *
	     * @member {Tiny.Point|Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'position',
	    get: function get() {
	      return this.transform.position;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.position.copy(value);
	    }

	    /**
	     * The scale factor of the object.
	     * Assignment by value since pixi-v4.
	     *
	     * @member {Tiny.Point|Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'scale',
	    get: function get() {
	      return this.transform.scale;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.scale.copy(value);
	    }

	    /**
	     * The pivot point of the displayObject that it rotates around
	     * Assignment by value since pixi-v4.
	     *
	     * @member {Tiny.Point|Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'pivot',
	    get: function get() {
	      return this.transform.pivot;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.pivot.copy(value);
	    }

	    /**
	     * The skew factor for the object in radians.
	     * Assignment by value since pixi-v4.
	     *
	     * @member {Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'skew',
	    get: function get() {
	      return this.transform.skew;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      this.transform.skew.copy(value);
	    }

	    /**
	     * The rotation of the object in radians.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'rotation',
	    get: function get() {
	      return this.transform.rotation;
	    },
	    set: function set(value) {
	      this.transform.rotation = value;
	    }

	    /**
	     * Indicates if the object is globally visible.
	     *
	     * @member {boolean}
	     * @readonly
	     */

	  }, {
	    key: 'worldVisible',
	    get: function get() {
	      var item = this;

	      do {
	        if (!item.visible) {
	          return false;
	        }

	        item = item.parent;
	      } while (item);

	      return true;
	    }

	    /**
	     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
	     * object to the shape of the mask applied to it. In Tiny a regular mask must be a
	     * Tiny.Graphics or a Tiny.Sprite object. This allows for much faster masking in canvas as it
	     * utilises shape clipping. To remove a mask, set this property to null.
	     *
	     * @member {Tiny.Graphics|Tiny.Sprite}
	     */

	  }, {
	    key: 'mask',
	    get: function get() {
	      return this._mask;
	    },
	    set: function set(value) {
	      if (this._mask) {
	        this._mask.renderable = true;
	      }

	      this._mask = value;

	      if (this._mask) {
	        this._mask.renderable = false;
	      }
	    }

	    /**
	     * Sets the filters for the displayObject.
	     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
	     * To remove filters simply set this property to 'null'
	     *
	     * @member {Tiny.Filter[]}
	     */

	  }, {
	    key: 'filters',
	    get: function get() {
	      return this._filters && this._filters.slice();
	    },
	    set: function set(value) {
	      this._filters = value && value.slice();
	    }
	  }]);

	  return DisplayObject;
	}(_eventemitter2.default);

	// performance increase to avoid using call.. (10x faster)


	exports.default = DisplayObject;
	DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _math = __webpack_require__(8);

	var _TransformBase2 = __webpack_require__(48);

	var _TransformBase3 = _interopRequireDefault(_TransformBase2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Transform that takes care about its versions
	 *
	 * @class
	 * @extends Tiny.TransformBase
	 * @memberof Tiny
	 */
	var TransformStatic = function (_TransformBase) {
	  _inherits(TransformStatic, _TransformBase);

	  /**
	   *
	   */
	  function TransformStatic() {
	    _classCallCheck(this, TransformStatic);

	    /**
	     * The coordinate of the object relative to the local coordinates of the parent.
	     *
	     * @member {Tiny.ObservablePoint}
	     */
	    var _this = _possibleConstructorReturn(this, (TransformStatic.__proto__ || Object.getPrototypeOf(TransformStatic)).call(this));

	    _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

	    /**
	     * The scale factor of the object.
	     *
	     * @member {Tiny.ObservablePoint}
	     */
	    _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);

	    /**
	     * The pivot point of the displayObject that it rotates around
	     *
	     * @member {Tiny.ObservablePoint}
	     */
	    _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);

	    /**
	     * The skew amount, on the x and y axis.
	     *
	     * @member {Tiny.ObservablePoint}
	     */
	    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

	    _this._rotation = 0;

	    _this._cx = 1; // cos rotation + skewY;
	    _this._sx = 0; // sin rotation + skewY;
	    _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
	    _this._sy = 1; // sin rotation + Math.PI/2 - skewX;

	    _this._localID = 0;
	    _this._currentLocalID = 0;
	    return _this;
	  }

	  /**
	   * Called when a value changes.
	   *
	   * @private
	   */


	  _createClass(TransformStatic, [{
	    key: 'onChange',
	    value: function onChange() {
	      this._localID++;
	    }

	    /**
	     * Called when skew or rotation changes
	     *
	     * @private
	     */

	  }, {
	    key: 'updateSkew',
	    value: function updateSkew() {
	      this._cx = Math.cos(this._rotation + this.skew._y);
	      this._sx = Math.sin(this._rotation + this.skew._y);
	      this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
	      this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2

	      this._localID++;
	    }

	    /**
	     * Updates only local matrix
	     */

	  }, {
	    key: 'updateLocalTransform',
	    value: function updateLocalTransform() {
	      var lt = this.localTransform;

	      if (this._localID !== this._currentLocalID) {
	        // get the matrix values of the displayobject based on its transform properties..
	        lt.a = this._cx * this.scale._x;
	        lt.b = this._sx * this.scale._x;
	        lt.c = this._cy * this.scale._y;
	        lt.d = this._sy * this.scale._y;

	        lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
	        lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
	        this._currentLocalID = this._localID;

	        // force an update..
	        this._parentID = -1;
	      }
	    }

	    /**
	     * Updates the values of the object and applies the parent's transform.
	     *
	     * @param {Tiny.Transform} parentTransform - The transform of the parent of this object
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform(parentTransform) {
	      var lt = this.localTransform;

	      if (this._localID !== this._currentLocalID) {
	        // get the matrix values of the displayobject based on its transform properties..
	        lt.a = this._cx * this.scale._x;
	        lt.b = this._sx * this.scale._x;
	        lt.c = this._cy * this.scale._y;
	        lt.d = this._sy * this.scale._y;

	        lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
	        lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
	        this._currentLocalID = this._localID;

	        // force an update..
	        this._parentID = -1;
	      }

	      if (this._parentID !== parentTransform._worldID) {
	        // concat the parent matrix with the objects transform.
	        var pt = parentTransform.worldTransform;
	        var wt = this.worldTransform;

	        wt.a = lt.a * pt.a + lt.b * pt.c;
	        wt.b = lt.a * pt.b + lt.b * pt.d;
	        wt.c = lt.c * pt.a + lt.d * pt.c;
	        wt.d = lt.c * pt.b + lt.d * pt.d;
	        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
	        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

	        this._parentID = parentTransform._worldID;

	        // update the id of the transform..
	        this._worldID++;
	      }
	    }

	    /**
	     * Decomposes a matrix and sets the transforms properties based on it.
	     *
	     * @param {Tiny.Matrix} matrix - The matrix to decompose
	     */

	  }, {
	    key: 'setFromMatrix',
	    value: function setFromMatrix(matrix) {
	      matrix.decompose(this);
	      this._localID++;
	    }

	    /**
	     * The rotation of the object in radians.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'rotation',
	    get: function get() {
	      return this._rotation;
	    },
	    set: function set(value) {
	      this._rotation = value;
	      this.updateSkew();
	    }
	  }]);

	  return TransformStatic;
	}(_TransformBase3.default);

	exports.default = TransformStatic;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _math = __webpack_require__(8);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Generic class to deal with traditional 2D matrix transforms
	 *
	 * @class
	 * @memberof Tiny
	 */
	var TransformBase = function () {
	  /**
	   *
	   */
	  function TransformBase() {
	    _classCallCheck(this, TransformBase);

	    /**
	     * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
	     *
	     * @member {Tiny.Matrix}
	     */
	    this.worldTransform = new _math.Matrix();

	    /**
	     * The local matrix transform
	     *
	     * @member {Tiny.Matrix}
	     */
	    this.localTransform = new _math.Matrix();

	    this._worldID = 0;
	    this._parentID = 0;
	  }

	  /**
	   * TransformBase does not have decomposition, so this function wont do anything
	   */


	  _createClass(TransformBase, [{
	    key: 'updateLocalTransform',
	    value: function updateLocalTransform() {}
	    // empty


	    /**
	     * Updates the values of the object and applies the parent's transform.
	     *
	     * @param {Tiny.TransformBase} parentTransform - The transform of the parent of this object
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform(parentTransform) {
	      var pt = parentTransform.worldTransform;
	      var wt = this.worldTransform;
	      var lt = this.localTransform;

	      // concat the parent matrix with the objects transform.
	      wt.a = lt.a * pt.a + lt.b * pt.c;
	      wt.b = lt.a * pt.b + lt.b * pt.d;
	      wt.c = lt.c * pt.a + lt.d * pt.c;
	      wt.d = lt.c * pt.b + lt.d * pt.d;
	      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
	      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

	      this._worldID++;
	    }
	  }]);

	  return TransformBase;
	}();

	/**
	 * Updates the values of the object and applies the parent's transform.
	 * @param  parentTransform {Tiny.Transform} The transform of the parent of this object
	 *
	 */


	exports.default = TransformBase;
	TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;

	TransformBase.IDENTITY = new TransformBase();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _math = __webpack_require__(8);

	var _TransformBase2 = __webpack_require__(48);

	var _TransformBase3 = _interopRequireDefault(_TransformBase2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Generic class to deal with traditional 2D matrix transforms
	 * local transformation is calculated from position,scale,skew and rotation
	 *
	 * @class
	 * @extends Tiny.TransformBase
	 * @memberof Tiny
	 */
	var Transform = function (_TransformBase) {
	  _inherits(Transform, _TransformBase);

	  /**
	   *
	   */
	  function Transform() {
	    _classCallCheck(this, Transform);

	    /**
	     * The coordinate of the object relative to the local coordinates of the parent.
	     *
	     * @member {Tiny.Point}
	     */
	    var _this = _possibleConstructorReturn(this, (Transform.__proto__ || Object.getPrototypeOf(Transform)).call(this));

	    _this.position = new _math.Point(0, 0);

	    /**
	     * The scale factor of the object.
	     *
	     * @member {Tiny.Point}
	     */
	    _this.scale = new _math.Point(1, 1);

	    /**
	     * The skew amount, on the x and y axis.
	     *
	     * @member {Tiny.ObservablePoint}
	     */
	    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);

	    /**
	     * The pivot point of the displayObject that it rotates around
	     *
	     * @member {Tiny.Point}
	     */
	    _this.pivot = new _math.Point(0, 0);

	    /**
	     * The rotation value of the object, in radians
	     *
	     * @member {Number}
	     * @private
	     */
	    _this._rotation = 0;

	    _this._cx = 1; // cos rotation + skewY;
	    _this._sx = 0; // sin rotation + skewY;
	    _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
	    _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
	    return _this;
	  }

	  /**
	   * Updates the skew values when the skew or rotation changes.
	   *
	   * @private
	   */


	  _createClass(Transform, [{
	    key: 'updateSkew',
	    value: function updateSkew() {
	      this._cx = Math.cos(this._rotation + this.skew._y);
	      this._sx = Math.sin(this._rotation + this.skew._y);
	      this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
	      this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
	    }

	    /**
	     * Updates only local matrix
	     */

	  }, {
	    key: 'updateLocalTransform',
	    value: function updateLocalTransform() {
	      var lt = this.localTransform;

	      lt.a = this._cx * this.scale.x;
	      lt.b = this._sx * this.scale.x;
	      lt.c = this._cy * this.scale.y;
	      lt.d = this._sy * this.scale.y;

	      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
	      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
	    }

	    /**
	     * Updates the values of the object and applies the parent's transform.
	     *
	     * @param {Tiny.Transform} parentTransform - The transform of the parent of this object
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform(parentTransform) {
	      var lt = this.localTransform;

	      lt.a = this._cx * this.scale.x;
	      lt.b = this._sx * this.scale.x;
	      lt.c = this._cy * this.scale.y;
	      lt.d = this._sy * this.scale.y;

	      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
	      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);

	      // concat the parent matrix with the objects transform.
	      var pt = parentTransform.worldTransform;
	      var wt = this.worldTransform;

	      wt.a = lt.a * pt.a + lt.b * pt.c;
	      wt.b = lt.a * pt.b + lt.b * pt.d;
	      wt.c = lt.c * pt.a + lt.d * pt.c;
	      wt.d = lt.c * pt.b + lt.d * pt.d;
	      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
	      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;

	      this._worldID++;
	    }

	    /**
	     * Decomposes a matrix and sets the transforms properties based on it.
	     *
	     * @param {Tiny.Matrix} matrix - The matrix to decompose
	     */

	  }, {
	    key: 'setFromMatrix',
	    value: function setFromMatrix(matrix) {
	      matrix.decompose(this);
	    }

	    /**
	     * The rotation of the object in radians.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'rotation',
	    get: function get() {
	      return this._rotation;
	    },
	    set: function set(value) {
	      this._rotation = value;
	      this.updateSkew();
	    }
	  }]);

	  return Transform;
	}(_TransformBase3.default);

	exports.default = Transform;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _utils = __webpack_require__(18);

	var _DisplayObject2 = __webpack_require__(46);

	var _DisplayObject3 = _interopRequireDefault(_DisplayObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A Container represents a collection of display objects.
	 * It is the base class of all display objects that act as a container for other objects.
	 *
	 *```js
	 * let container = new Tiny.Container();
	 * container.addChild(sprite);
	 * ```
	 *
	 * @class
	 * @extends Tiny.DisplayObject
	 * @memberof Tiny
	 */
	var Container = function (_DisplayObject) {
	  _inherits(Container, _DisplayObject);

	  /**
	   *
	   */
	  function Container() {
	    _classCallCheck(this, Container);

	    /**
	     * The array of children of this container.
	     *
	     * @member {Tiny.DisplayObject[]}
	     * @readonly
	     */
	    var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this));

	    _this.children = [];

	    _this.actions = [];
	    return _this;
	  }

	  /**
	   * Overridable method that can be used by Container subclasses whenever the children array is modified
	   *
	   * @private
	   */


	  _createClass(Container, [{
	    key: 'onChildrenChange',
	    value: function onChildrenChange() {}
	    /* empty */


	    /**
	     * Adds one or more children to the container.
	     *
	     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
	     *
	     * @param {...Tiny.DisplayObject} child - The DisplayObject(s) to add to the container
	     * @return {Tiny.DisplayObject} The first child that was added.
	     */

	  }, {
	    key: 'addChild',
	    value: function addChild(child) {
	      var argumentsLength = arguments.length;

	      // if there is only one argument we can bypass looping through the them
	      if (argumentsLength > 1) {
	        // loop through the arguments property and add all children
	        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
	        for (var i = 0; i < argumentsLength; i++) {
	          this.addChild(arguments[i]);
	        }
	      } else {
	        // if the child has a parent then lets remove it as Tiny objects can only exist in one place
	        if (child.parent) {
	          child.parent.removeChild(child);
	        }

	        child.parent = this;

	        // ensure a transform will be recalculated..
	        this.transform._parentID = -1;
	        this._boundsID++;

	        this.children.push(child);

	        // TODO - lets either do all callbacks or all events.. not both!
	        this.onChildrenChange(this.children.length - 1);
	        child.emit('added', this);
	      }

	      return child;
	    }

	    /**
	     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
	     *
	     * @param {Tiny.DisplayObject} child - The child to add
	     * @param {number} index - The index to place the child in
	     * @return {Tiny.DisplayObject} The child that was added.
	     */

	  }, {
	    key: 'addChildAt',
	    value: function addChildAt(child, index) {
	      if (index < 0 || index > this.children.length) {
	        throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
	      }

	      if (child.parent) {
	        child.parent.removeChild(child);
	      }

	      child.parent = this;

	      this.children.splice(index, 0, child);

	      // TODO - lets either do all callbacks or all events.. not both!
	      this.onChildrenChange(index);
	      child.emit('added', this);

	      return child;
	    }

	    /**
	     * Swaps the position of 2 Display Objects within this container.
	     *
	     * @param {Tiny.DisplayObject} child - First display object to swap
	     * @param {Tiny.DisplayObject} child2 - Second display object to swap
	     */

	  }, {
	    key: 'swapChildren',
	    value: function swapChildren(child, child2) {
	      if (child === child2) {
	        return;
	      }

	      var index1 = this.getChildIndex(child);
	      var index2 = this.getChildIndex(child2);

	      this.children[index1] = child2;
	      this.children[index2] = child;
	      this.onChildrenChange(index1 < index2 ? index1 : index2);
	    }

	    /**
	     * Returns the index position of a child DisplayObject instance
	     *
	     * @param {Tiny.DisplayObject} child - The DisplayObject instance to identify
	     * @return {number} The index position of the child display object to identify
	     */

	  }, {
	    key: 'getChildIndex',
	    value: function getChildIndex(child) {
	      var index = this.children.indexOf(child);

	      if (index === -1) {
	        throw new Error('The supplied DisplayObject must be a child of the caller');
	      }

	      return index;
	    }

	    /**
	     * Changes the position of an existing child in the display object container
	     *
	     * @param {Tiny.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
	     * @param {number} index - The resulting index number for the child display object
	     */

	  }, {
	    key: 'setChildIndex',
	    value: function setChildIndex(child, index) {
	      if (index < 0 || index >= this.children.length) {
	        throw new Error('The supplied index is out of bounds');
	      }

	      var currentIndex = this.getChildIndex(child);

	      (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position
	      this.children.splice(index, 0, child); // add at new position
	      this.onChildrenChange(index);
	    }

	    /**
	     * Returns the child at the specified index
	     *
	     * @param {number} index - The index to get the child at
	     * @return {Tiny.DisplayObject} The child at the given index, if any.
	     */

	  }, {
	    key: 'getChildAt',
	    value: function getChildAt(index) {
	      if (index < 0 || index >= this.children.length) {
	        throw new Error('getChildAt: Index (' + index + ') does not exist.');
	      }

	      return this.children[index];
	    }

	    /**
	     * Removes one or more children from the container.
	     *
	     * @param {...Tiny.DisplayObject} child - The DisplayObject(s) to remove
	     * @return {Tiny.DisplayObject} The first child that was removed.
	     */

	  }, {
	    key: 'removeChild',
	    value: function removeChild(child) {
	      var argumentsLength = arguments.length;

	      // if there is only one argument we can bypass looping through the them
	      if (argumentsLength > 1) {
	        // loop through the arguments property and add all children
	        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
	        for (var i = 0; i < argumentsLength; i++) {
	          this.removeChild(arguments[i]);
	        }
	      } else {
	        var index = this.children.indexOf(child);

	        if (index === -1) return null;

	        child.parent = null;
	        (0, _utils.removeItems)(this.children, index, 1);

	        // ensure a transform will be recalculated..
	        this.transform._parentID = -1;
	        this._boundsID++;

	        // TODO - lets either do all callbacks or all events.. not both!
	        this.onChildrenChange(index);
	        child.emit('removed', this);
	      }

	      return child;
	    }

	    /**
	     * Removes a child from the specified index position.
	     *
	     * @param {number} index - The index to get the child from
	     * @return {Tiny.DisplayObject} The child that was removed.
	     */

	  }, {
	    key: 'removeChildAt',
	    value: function removeChildAt(index) {
	      var child = this.getChildAt(index);

	      child.parent = null;
	      (0, _utils.removeItems)(this.children, index, 1);

	      // TODO - lets either do all callbacks or all events.. not both!
	      this.onChildrenChange(index);
	      child.emit('removed', this);

	      return child;
	    }

	    /**
	     * Removes all children from this container that are within the begin and end indexes.
	     *
	     * @param {number} [beginIndex=0] - The beginning position.
	     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
	     * @return {DisplayObject[]} List of removed children
	     */

	  }, {
	    key: 'removeChildren',
	    value: function removeChildren() {
	      var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var endIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var begin = beginIndex;
	      var end = typeof endIndex === 'number' ? endIndex : this.children.length;
	      var range = end - begin;
	      var removed = void 0;

	      if (range > 0 && range <= end) {
	        removed = this.children.splice(begin, range);

	        for (var i = 0; i < removed.length; ++i) {
	          removed[i].parent = null;
	        }

	        this.onChildrenChange(beginIndex);

	        for (var _i = 0; _i < removed.length; ++_i) {
	          removed[_i].emit('removed', this);
	        }

	        return removed;
	      } else if (range === 0 && this.children.length === 0) {
	        return [];
	      }

	      throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
	    }

	    /**
	     * Updates the transform on all children of this container for rendering
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform() {
	      this._boundsID++;

	      this.transform.updateTransform(this.parent.transform);

	      // TODO: check render flags, how to process stuff here
	      this.worldAlpha = this.alpha * this.parent.worldAlpha;

	      for (var i = 0, j = this.children.length; i < j; ++i) {
	        var child = this.children[i];

	        if (child.visible) {
	          child.updateTransform();
	        }
	      }
	    }

	    /**
	     * Recalculates the bounds of the container.
	     *
	     */

	  }, {
	    key: 'calculateBounds',
	    value: function calculateBounds() {
	      this._bounds.clear();

	      this._calculateBounds();

	      for (var i = 0; i < this.children.length; i++) {
	        var child = this.children[i];

	        if (!child.visible || !child.renderable) {
	          continue;
	        }

	        child.calculateBounds();

	        // TODO: filter+mask, need to mask both somehow
	        if (child._mask) {
	          child._mask.calculateBounds();
	          this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
	        } else if (child.filterArea) {
	          this._bounds.addBoundsArea(child._bounds, child.filterArea);
	        } else {
	          this._bounds.addBounds(child._bounds);
	        }
	      }

	      this._lastBoundsID = this._boundsID;
	    }

	    /**
	     * Recalculates the bounds of the object. Override this to
	     * calculate the bounds of the specific object (not including children).
	     *
	     */

	  }, {
	    key: '_calculateBounds',
	    value: function _calculateBounds() {}
	    // FILL IN//


	    /**
	     * Renders the object using the WebGL renderer
	     *
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      // if the object is not visible or the alpha is 0 then no need to render this element
	      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
	        return;
	      }

	      // do a quick check to see if this element has a mask or a filter.
	      if (this._mask || this._filters) {
	        this.renderAdvancedWebGL(renderer);
	      } else {
	        this._renderWebGL(renderer);

	        // simple render children!
	        for (var i = 0, j = this.children.length; i < j; ++i) {
	          this.children[i].renderWebGL(renderer);
	        }
	      }
	    }

	    /**
	     * Render the object using the WebGL renderer and advanced features.
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderAdvancedWebGL',
	    value: function renderAdvancedWebGL(renderer) {
	      renderer.flush();

	      var filters = this._filters;
	      var mask = this._mask;

	      // push filter first as we need to ensure the stencil buffer is correct for any masking
	      if (filters) {
	        if (!this._enabledFilters) {
	          this._enabledFilters = [];
	        }

	        this._enabledFilters.length = 0;

	        for (var i = 0; i < filters.length; i++) {
	          if (filters[i].enabled) {
	            this._enabledFilters.push(filters[i]);
	          }
	        }

	        if (this._enabledFilters.length) {
	          renderer.filterManager.pushFilter(this, this._enabledFilters);
	        }
	      }

	      if (mask) {
	        renderer.maskManager.pushMask(this, this._mask);
	      }

	      // add this object to the batch, only rendered if it has a texture.
	      this._renderWebGL(renderer);

	      // now loop through the children and make sure they get rendered
	      for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {
	        this.children[_i2].renderWebGL(renderer);
	      }

	      renderer.flush();

	      if (mask) {
	        renderer.maskManager.popMask(this, this._mask);
	      }

	      if (filters && this._enabledFilters && this._enabledFilters.length) {
	        renderer.filterManager.popFilter();
	      }
	    }

	    /**
	     * To be overridden by the subclasses.
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {} // eslint-disable-line no-unused-vars
	    // this is where content itself gets rendered...


	    /**
	     * To be overridden by the subclass
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {} // eslint-disable-line no-unused-vars
	    // this is where content itself gets rendered...


	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      // if not visible or the alpha is 0 then no need to render this
	      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
	        return;
	      }

	      if (this._mask) {
	        renderer.maskManager.pushMask(this._mask);
	      }

	      this._renderCanvas(renderer);
	      for (var i = 0, j = this.children.length; i < j; ++i) {
	        this.children[i].renderCanvas(renderer);
	      }

	      if (this._mask) {
	        renderer.maskManager.popMask(renderer);
	      }
	    }

	    /**
	     * Removes all internal references and listeners as well as removes children from the display list.
	     * Do not use a Container after calling `destroy`.
	     *
	     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
	     *  have been set to that value
	     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
	     *  method called as well. 'options' will be passed on to those calls.
	     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the texture of the child sprite
	     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the base texture of the child sprite
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(options) {
	      _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'destroy', this).call(this);

	      var destroyChildren = typeof options === 'boolean' ? options : options && options.children;

	      var oldChildren = this.removeChildren(0, this.children.length);

	      if (destroyChildren) {
	        for (var i = 0; i < oldChildren.length; ++i) {
	          oldChildren[i].destroy(options);
	        }
	      }
	    }

	    /**
	     * The width of the Container, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      return this.scale.x * this.getLocalBounds().width;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      var width = this.getLocalBounds().width;

	      if (width !== 0) {
	        this.scale.x = value / width;
	      } else {
	        this.scale.x = 1;
	      }

	      this._width = value;
	    }

	    /**
	     * The height of the Container, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      return this.scale.y * this.getLocalBounds().height;
	    },
	    set: function set(value) {
	      // eslint-disable-line require-jsdoc
	      var height = this.getLocalBounds().height;

	      if (height !== 0) {
	        this.scale.y = value / height;
	      } else {
	        this.scale.y = 1;
	      }

	      this._height = value;
	    }
	  }]);

	  return Container;
	}(_DisplayObject3.default);

	// performance increase to avoid using call.. (10x faster)


	exports.default = Container;
	Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _math = __webpack_require__(8);

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	var _Texture = __webpack_require__(52);

	var _Texture2 = _interopRequireDefault(_Texture);

	var _Container2 = __webpack_require__(50);

	var _Container3 = _interopRequireDefault(_Container2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var tempPoint = new _math.Point();

	/**
	 * The Sprite object is the base for all textured objects that are rendered to the screen
	 *
	 * A sprite can be created directly from an image like this:
	 *
	 * ```js
	 * let sprite = new Tiny.Sprite.fromImage('assets/image.png');
	 * ```
	 *
	 * @class
	 * @extends Tiny.Container
	 * @memberof Tiny
	 */

	var Sprite = function (_Container) {
	  _inherits(Sprite, _Container);

	  /**
	   * @param {Tiny.Texture} texture - The texture for this sprite
	   */
	  function Sprite(texture) {
	    _classCallCheck(this, Sprite);

	    /**
	     * The anchor sets the origin point of the texture.
	     * The default is 0,0 this means the texture's origin is the top left
	     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
	     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
	     *
	     * @member {Tiny.ObservablePoint}
	     * @private
	     */
	    var _this = _possibleConstructorReturn(this, (Sprite.__proto__ || Object.getPrototypeOf(Sprite)).call(this));

	    _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this);

	    /**
	     * The texture that the sprite is using
	     *
	     * @private
	     * @member {Tiny.Texture}
	     */
	    _this._texture = null;

	    /**
	     * The width of the sprite (this is initially set by the texture)
	     *
	     * @private
	     * @member {number}
	     */
	    _this._width = 0;

	    /**
	     * The height of the sprite (this is initially set by the texture)
	     *
	     * @private
	     * @member {number}
	     */
	    _this._height = 0;

	    /**
	     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
	     *
	     * @private
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    _this._tint = null;
	    _this._tintRGB = null;
	    _this.tint = 0xFFFFFF;

	    /**
	     * The blend mode to be applied to the sprite. Apply a value of `Tiny.BLEND_MODES.NORMAL` to reset the blend mode.
	     *
	     * @member {number}
	     * @default Tiny.BLEND_MODES.NORMAL
	     * @see Tiny.BLEND_MODES
	     */
	    _this.blendMode = _const.BLEND_MODES.NORMAL;

	    /**
	     * The shader that will be used to render the sprite. Set to null to remove a current shader.
	     *
	     * @member {Tiny.Filter|Tiny.Shader}
	     */
	    _this.shader = null;

	    /**
	     * An internal cached value of the tint.
	     *
	     * @private
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    _this.cachedTint = 0xFFFFFF;

	    // call texture setter
	    _this.texture = texture || _Texture2.default.EMPTY;

	    /**
	     * this is used to store the vertex data of the sprite (basically a quad)
	     *
	     * @private
	     * @member {Float32Array}
	     */
	    _this.vertexData = new Float32Array(8);

	    /**
	     * This is used to calculate the bounds of the object IF it is a trimmed sprite
	     *
	     * @private
	     * @member {Float32Array}
	     */
	    _this.vertexTrimmedData = null;

	    _this._transformID = -1;
	    _this._textureID = -1;

	    _this._transformTrimmedID = -1;
	    _this._textureTrimmedID = -1;

	    /**
	     * Plugin that is responsible for rendering this element.
	     * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
	     *
	     * @member {string}
	     * @default 'sprite'
	     */
	    _this.pluginName = 'sprite';
	    return _this;
	  }

	  /**
	   * When the texture is updated, this event will fire to update the scale and frame
	   *
	   * @private
	   */


	  _createClass(Sprite, [{
	    key: '_onTextureUpdate',
	    value: function _onTextureUpdate() {
	      this._textureID = -1;
	      this._textureTrimmedID = -1;

	      // so if _width is 0 then width was not set..
	      if (this._width) {
	        this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this.texture.orig.width;
	      }

	      if (this._height) {
	        this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this.texture.orig.height;
	      }
	    }

	    /**
	     * Called when the anchor position updates.
	     *
	     * @private
	     */

	  }, {
	    key: '_onAnchorUpdate',
	    value: function _onAnchorUpdate() {
	      this._transformID = -1;
	      this._transformTrimmedID = -1;
	    }

	    /**
	     * calculates worldTransform * vertices, store it in vertexData
	     */

	  }, {
	    key: 'calculateVertices',
	    value: function calculateVertices() {
	      if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) {
	        return;
	      }

	      this._transformID = this.transform._worldID;
	      this._textureID = this._texture._updateID;

	      // set the vertex data

	      var texture = this._texture;
	      var wt = this.transform.worldTransform;
	      var a = wt.a;
	      var b = wt.b;
	      var c = wt.c;
	      var d = wt.d;
	      var tx = wt.tx;
	      var ty = wt.ty;
	      var vertexData = this.vertexData;
	      var trim = texture.trim;
	      var orig = texture.orig;
	      var anchor = this._anchor;

	      var w0 = 0;
	      var w1 = 0;
	      var h0 = 0;
	      var h1 = 0;

	      if (trim) {
	        // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
	        // space before transforming the sprite coords.
	        w1 = trim.x - anchor._x * orig.width;
	        w0 = w1 + trim.width;

	        h1 = trim.y - anchor._y * orig.height;
	        h0 = h1 + trim.height;
	      } else {
	        w0 = orig.width * (1 - anchor._x);
	        w1 = orig.width * -anchor._x;

	        h0 = orig.height * (1 - anchor._y);
	        h1 = orig.height * -anchor._y;
	      }

	      // xy
	      vertexData[0] = a * w1 + c * h1 + tx;
	      vertexData[1] = d * h1 + b * w1 + ty;

	      // xy
	      vertexData[2] = a * w0 + c * h1 + tx;
	      vertexData[3] = d * h1 + b * w0 + ty;

	      // xy
	      vertexData[4] = a * w0 + c * h0 + tx;
	      vertexData[5] = d * h0 + b * w0 + ty;

	      // xy
	      vertexData[6] = a * w1 + c * h0 + tx;
	      vertexData[7] = d * h0 + b * w1 + ty;
	    }

	    /**
	     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
	     * This is used to ensure that the true width and height of a trimmed texture is respected
	     */

	  }, {
	    key: 'calculateTrimmedVertices',
	    value: function calculateTrimmedVertices() {
	      if (!this.vertexTrimmedData) {
	        this.vertexTrimmedData = new Float32Array(8);
	      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
	        return;
	      }

	      this._transformTrimmedID = this.transform._worldID;
	      this._textureTrimmedID = this._texture._updateID;

	      // lets do some special trim code!
	      var texture = this._texture;
	      var vertexData = this.vertexTrimmedData;
	      var orig = texture.orig;
	      var anchor = this._anchor;

	      // lets calculate the new untrimmed bounds..
	      var wt = this.transform.worldTransform;
	      var a = wt.a;
	      var b = wt.b;
	      var c = wt.c;
	      var d = wt.d;
	      var tx = wt.tx;
	      var ty = wt.ty;

	      var w0 = orig.width * (1 - anchor._x);
	      var w1 = orig.width * -anchor._x;

	      var h0 = orig.height * (1 - anchor._y);
	      var h1 = orig.height * -anchor._y;

	      // xy
	      vertexData[0] = a * w1 + c * h1 + tx;
	      vertexData[1] = d * h1 + b * w1 + ty;

	      // xy
	      vertexData[2] = a * w0 + c * h1 + tx;
	      vertexData[3] = d * h1 + b * w0 + ty;

	      // xy
	      vertexData[4] = a * w0 + c * h0 + tx;
	      vertexData[5] = d * h0 + b * w0 + ty;

	      // xy
	      vertexData[6] = a * w1 + c * h0 + tx;
	      vertexData[7] = d * h0 + b * w1 + ty;
	    }

	    /**
	     *
	     * Renders the object using the WebGL renderer
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The webgl renderer to use.
	     */

	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      this.calculateVertices();

	      renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
	      renderer.plugins[this.pluginName].render(this);
	    }

	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      renderer.plugins[this.pluginName].render(this);
	    }

	    /**
	     * Updates the bounds of the sprite.
	     *
	     * @private
	     */

	  }, {
	    key: '_calculateBounds',
	    value: function _calculateBounds() {
	      var trim = this._texture.trim;
	      var orig = this._texture.orig;

	      // First lets check to see if the current texture has a trim..
	      if (!trim || trim.width === orig.width && trim.height === orig.height) {
	        // no trim! lets use the usual calculations..
	        this.calculateVertices();
	        this._bounds.addQuad(this.vertexData);
	      } else {
	        // lets calculate a special trimmed bounds...
	        this.calculateTrimmedVertices();
	        this._bounds.addQuad(this.vertexTrimmedData);
	      }
	    }

	    /**
	     * Gets the local bounds of the sprite object.
	     *
	     * @param {Rectangle} rect - The output rectangle.
	     * @return {Rectangle} The bounds.
	     */

	  }, {
	    key: 'getLocalBounds',
	    value: function getLocalBounds(rect) {
	      // we can do a fast local bounds if the sprite has no children!
	      if (this.children.length === 0) {
	        this._bounds.minX = this._texture.orig.width * -this._anchor._x;
	        this._bounds.minY = this._texture.orig.height * -this._anchor._y;
	        this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
	        this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._x);

	        if (!rect) {
	          if (!this._localBoundsRect) {
	            this._localBoundsRect = new _math.Rectangle();
	          }

	          rect = this._localBoundsRect;
	        }

	        return this._bounds.getRectangle(rect);
	      }

	      return _get(Sprite.prototype.__proto__ || Object.getPrototypeOf(Sprite.prototype), 'getLocalBounds', this).call(this, rect);
	    }

	    /**
	     * Tests if a point is inside this sprite
	     *
	     * @param {Tiny.Point} point - the point to test
	     * @return {boolean} the result of the test
	     */

	  }, {
	    key: 'containsPoint',
	    value: function containsPoint(point) {
	      this.worldTransform.applyInverse(point, tempPoint);

	      var width = this._texture.orig.width;
	      var height = this._texture.orig.height;
	      var x1 = -width * this.anchor.x;
	      var y1 = 0;

	      if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
	        y1 = -height * this.anchor.y;

	        if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
	          return true;
	        }
	      }

	      return false;
	    }

	    /**
	     * Destroys this sprite and optionally its texture and children
	     *
	     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
	     *  have been set to that value
	     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
	     *      method called as well. 'options' will be passed on to those calls.
	     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
	     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(options) {
	      _get(Sprite.prototype.__proto__ || Object.getPrototypeOf(Sprite.prototype), 'destroy', this).call(this, options);

	      this._anchor = null;

	      var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;

	      if (destroyTexture) {
	        var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;

	        this._texture.destroy(!!destroyBaseTexture);
	      }

	      this._texture = null;
	      this.shader = null;
	    }

	    // some helper functions..

	    /**
	     * Helper function that creates a new sprite based on the source you provide.
	     * The source can be - frame id, image url, video url, canvas element, video element, base texture
	     *
	     * @static
	     * @param {number|string|Tiny.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'setPivot',
	    value: function setPivot(x, y) {
	      this.anchor.set(x, y === void 0 ? x : y);
	    }

	    /**
	     * The width of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      return Math.abs(this.scale.x) * this._texture.orig.width;
	    },
	    set: function set(value) {
	      var s = (0, _utils.sign)(this.scale.x) || 1;

	      this.scale.x = s * value / this._texture.orig.width;
	      this._width = value;
	    }

	    /**
	     * The height of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      return Math.abs(this.scale.y) * this._texture.orig.height;
	    },
	    set: function set(value) {
	      var s = (0, _utils.sign)(this.scale.y) || 1;

	      this.scale.y = s * value / this._texture.orig.height;
	      this._height = value;
	    }

	    /**
	     * The anchor sets the origin point of the texture.
	     * The default is 0,0 this means the texture's origin is the top left
	     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
	     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
	     *
	     * @member {Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'anchor',
	    get: function get() {
	      return this._anchor;
	    },
	    set: function set(value) {
	      this._anchor.copy(value);
	    }

	    /**
	     * The tint applied to the sprite. This is a hex value. A value of
	     * 0xFFFFFF will remove any tint effect.
	     *
	     * @member {number}
	     * @default 0xFFFFFF
	     */

	  }, {
	    key: 'tint',
	    get: function get() {
	      return this._tint;
	    },
	    set: function set(value) {
	      this._tint = value;
	      this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
	    }

	    /**
	     * The texture that the sprite is using
	     *
	     * @member {Tiny.Texture}
	     */

	  }, {
	    key: 'texture',
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(value) {
	      if (this._texture === value) {
	        return;
	      }

	      this._texture = value;
	      this.cachedTint = 0xFFFFFF;

	      this._textureID = -1;
	      this._textureTrimmedID = -1;

	      if (value) {
	        // wait for the texture to load
	        if (value.baseTexture.hasLoaded) {
	          this._onTextureUpdate();
	        } else {
	          value.once('update', this._onTextureUpdate, this);
	        }
	      }
	    }
	  }], [{
	    key: 'from',
	    value: function from(source) {
	      return new Sprite(_Texture2.default.from(source));
	    }

	    /**
	     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	     * The frame ids are created when a Texture packer file has been loaded
	     *
	     * @static
	     * @param {string} frameId - The frame Id of the texture in the cache
	     * @return {Tiny.Sprite} A new Sprite using a texture from the texture cache matching the frameId
	     */

	  }, {
	    key: 'fromFrame',
	    value: function fromFrame(frameId) {
	      var texture = _utils.TextureCache[frameId];

	      if (!texture) {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
	      }

	      return new Sprite(texture);
	    }

	    /**
	     * Helper function that creates a sprite that will contain a texture based on an image url
	     * If the image is not in the texture cache it will be loaded
	     *
	     * @static
	     * @param {string} imageId - The image url of the texture
	     * @param {boolean} [crossorigin=(auto)] - if you want to specify the cross-origin parameter
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - if you want to specify the scale mode,
	     *  see {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.Sprite} A new Sprite using a texture from the texture cache matching the image id
	     */

	  }, {
	    key: 'fromImage',
	    value: function fromImage(imageId, crossorigin, scaleMode) {
	      return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode));
	    }
	  }]);

	  return Sprite;
	}(_Container3.default);

	exports.default = Sprite;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _BaseTexture = __webpack_require__(53);

	var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

	var _VideoBaseTexture = __webpack_require__(64);

	var _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);

	var _TextureUvs = __webpack_require__(67);

	var _TextureUvs2 = _interopRequireDefault(_TextureUvs);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _math = __webpack_require__(8);

	var _utils = __webpack_require__(18);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided
	 * then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * let texture = Tiny.Texture.fromImage('assets/image.png');
	 * let sprite1 = new Tiny.Sprite(texture);
	 * let sprite2 = new Tiny.Sprite(texture);
	 * ```
	 *
	 * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
	 * You can check for this by checking the sprite's _textureID property.
	 * ```js
	 * var texture = Tiny.Texture.fromImage('assets/image.svg');
	 * var sprite1 = new Tiny.Sprite(texture);
	 * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
	 * ```
	 * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
	 *
	 * @class
	 * @extends EventEmitter
	 * @memberof Tiny
	 */
	var Texture = function (_EventEmitter) {
	  _inherits(Texture, _EventEmitter);

	  /**
	   * @param {Tiny.BaseTexture} baseTexture - The base texture source to create the texture from
	   * @param {Tiny.Rectangle} [frame] - The rectangle frame of the texture to show
	   * @param {Tiny.Rectangle} [orig] - The area of original texture
	   * @param {Tiny.Rectangle} [trim] - Trimmed rectangle of original texture
	   * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link Tiny.GroupD8}
	   */
	  function Texture(baseTexture, frame, orig, trim, rotate) {
	    _classCallCheck(this, Texture);

	    /**
	     * Does this Texture have any frame data assigned to it?
	     *
	     * @member {boolean}
	     */
	    var _this = _possibleConstructorReturn(this, (Texture.__proto__ || Object.getPrototypeOf(Texture)).call(this));

	    _this.noFrame = false;

	    if (!frame) {
	      _this.noFrame = true;
	      frame = new _math.Rectangle(0, 0, 1, 1);
	    }

	    if (baseTexture instanceof Texture) {
	      baseTexture = baseTexture.baseTexture;
	    }

	    /**
	     * The base texture that this texture uses.
	     *
	     * @member {Tiny.BaseTexture}
	     */
	    _this.baseTexture = baseTexture;

	    /**
	     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
	     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
	     *
	     * @member {Tiny.Rectangle}
	     */
	    _this._frame = frame;

	    /**
	     * This is the trimmed area of original texture, before it was put in atlas
	     *
	     * @member {Tiny.Rectangle}
	     */
	    _this.trim = trim;

	    /**
	     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	     *
	     * @member {boolean}
	     */
	    _this.valid = false;

	    /**
	     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
	     *
	     * @member {boolean}
	     */
	    _this.requiresUpdate = false;

	    /**
	     * The WebGL UV data cache.
	     *
	     * @member {Tiny.TextureUvs}
	     * @private
	     */
	    _this._uvs = null;

	    /**
	     * This is the area of original texture, before it was put in atlas
	     *
	     * @member {Tiny.Rectangle}
	     */
	    _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);

	    _this._rotate = Number(rotate || 0);

	    if (rotate === true) {
	      // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
	      _this._rotate = 2;
	    } else if (_this._rotate % 2 !== 0) {
	      throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
	    }

	    if (baseTexture.hasLoaded) {
	      if (_this.noFrame) {
	        frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);

	        // if there is no frame we should monitor for any base texture changes..
	        baseTexture.on('update', _this.onBaseTextureUpdated, _this);
	      }
	      _this.frame = frame;
	    } else {
	      baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);
	    }

	    /**
	     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
	     *
	     * @event update
	     * @memberof Tiny.Texture#
	     * @protected
	     */

	    _this._updateID = 0;

	    /**
	     * Extra field for extra plugins. May contain clamp settings and some matrices
	     * @type {Object}
	     */
	    _this.transform = null;
	    return _this;
	  }

	  /**
	   * Updates this texture on the gpu.
	   *
	   */


	  _createClass(Texture, [{
	    key: 'update',
	    value: function update() {
	      this.baseTexture.update();
	    }

	    /**
	     * Called when the base texture is loaded
	     *
	     * @private
	     * @param {Tiny.BaseTexture} baseTexture - The base texture.
	     */

	  }, {
	    key: 'onBaseTextureLoaded',
	    value: function onBaseTextureLoaded(baseTexture) {
	      this._updateID++;

	      // TODO this code looks confusing.. boo to abusing getters and setters!
	      if (this.noFrame) {
	        this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
	      } else {
	        this.frame = this._frame;
	      }

	      this.baseTexture.on('update', this.onBaseTextureUpdated, this);
	      this.emit('update', this);
	    }

	    /**
	     * Called when the base texture is updated
	     *
	     * @private
	     * @param {Tiny.BaseTexture} baseTexture - The base texture.
	     */

	  }, {
	    key: 'onBaseTextureUpdated',
	    value: function onBaseTextureUpdated(baseTexture) {
	      this._updateID++;

	      this._frame.width = baseTexture.width;
	      this._frame.height = baseTexture.height;

	      this.emit('update', this);
	    }

	    /**
	     * Destroys this texture
	     *
	     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(destroyBase) {
	      if (this.baseTexture) {
	        if (destroyBase) {
	          // delete the texture if it exists in the texture cache..
	          // this only needs to be removed if the base texture is actually destroyed too..
	          if (_utils.TextureCache[this.baseTexture.imageUrl]) {
	            delete _utils.TextureCache[this.baseTexture.imageUrl];
	          }

	          this.baseTexture.destroy();
	        }

	        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
	        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);

	        this.baseTexture = null;
	      }

	      this._frame = null;
	      this._uvs = null;
	      this.trim = null;
	      this.orig = null;

	      this.valid = false;

	      this.off('dispose', this.dispose, this);
	      this.off('update', this.update, this);
	    }

	    /**
	     * Creates a new texture object that acts the same as this one.
	     *
	     * @return {Tiny.Texture} The new texture
	     */

	  }, {
	    key: 'clone',
	    value: function clone() {
	      return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate);
	    }

	    /**
	     * Updates the internal WebGL UV cache.
	     *
	     * @protected
	     */

	  }, {
	    key: '_updateUvs',
	    value: function _updateUvs() {
	      if (!this._uvs) {
	        this._uvs = new _TextureUvs2.default();
	      }

	      this._uvs.set(this._frame, this.baseTexture, this.rotate);

	      this._updateID++;
	    }

	    /**
	     * Helper function that creates a Texture object from the given image url.
	     * If the image is not in the texture cache it will be  created and loaded.
	     *
	     * @static
	     * @param {string} imageUrl - The image url of the texture
	     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'frame',


	    /**
	     * The frame specifies the region of the base texture that this texture uses.
	     *
	     * @member {Tiny.Rectangle}
	     */
	    get: function get() {
	      return this._frame;
	    },
	    set: function set(frame) {
	      this._frame = frame;

	      this.noFrame = false;

	      if (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height) {
	        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
	      }

	      // this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
	      this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

	      if (!this.trim && !this.rotate) {
	        this.orig = frame;
	      }

	      if (this.valid) {
	        this._updateUvs();
	      }
	    }

	    /**
	     * Indicates whether the texture is rotated inside the atlas
	     * set to 2 to compensate for texture packer rotation
	     * set to 6 to compensate for spine packer rotation
	     * can be used to rotate or mirror sprites
	     * See {@link Tiny.GroupD8} for explanation
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'rotate',
	    get: function get() {
	      return this._rotate;
	    },
	    set: function set(rotate) {
	      this._rotate = rotate;
	      if (this.valid) {
	        this._updateUvs();
	      }
	    }

	    /**
	     * The width of the Texture in pixels.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      return this.orig.width;
	    }

	    /**
	     * The height of the Texture in pixels.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      return this.orig.height;
	    }
	  }], [{
	    key: 'fromImage',
	    value: function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
	      var texture = _utils.TextureCache[imageUrl];

	      if (!texture) {
	        texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
	        _utils.TextureCache[imageUrl] = texture;
	      }

	      return texture;
	    }

	    /**
	     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	     * The frame ids are created when a Texture packer file has been loaded
	     *
	     * @static
	     * @param {string} frameId - The frame Id of the texture in the cache
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'fromFrame',
	    value: function fromFrame(frameId) {
	      var texture = _utils.TextureCache[frameId];

	      if (!texture) {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
	      }

	      return texture;
	    }

	    /**
	     * Helper function that creates a new Texture based on the given canvas element.
	     *
	     * @static
	     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'fromCanvas',
	    value: function fromCanvas(canvas, scaleMode) {
	      return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode));
	    }

	    /**
	     * Helper function that creates a new Texture based on the given video element.
	     *
	     * @static
	     * @param {HTMLVideoElement|string} video - The URL or actual element of the video
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'fromVideo',
	    value: function fromVideo(video, scaleMode) {
	      if (typeof video === 'string') {
	        return Texture.fromVideoUrl(video, scaleMode);
	      }

	      return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode));
	    }

	    /**
	     * Helper function that creates a new Texture based on the video url.
	     *
	     * @static
	     * @param {string} videoUrl - URL of the video
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'fromVideoUrl',
	    value: function fromVideoUrl(videoUrl, scaleMode) {
	      return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode));
	    }

	    /**
	     * Helper function that creates a new Texture based on the source you provide.
	     * The source can be - frame id, image url, video url, canvas element, video element, base texture
	     *
	     * @static
	     * @param {number|string|Tiny.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'from',
	    value: function from(source) {
	      // TODO auto detect cross origin..
	      // TODO pass in scale mode?
	      if (typeof source === 'string') {
	        var texture = _utils.TextureCache[source];

	        if (!texture) {
	          // check if its a video..
	          var isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;

	          if (isVideo) {
	            return Texture.fromVideoUrl(source);
	          }

	          return Texture.fromImage(source);
	        }

	        return texture;
	      } else if (source instanceof HTMLImageElement) {
	        return new Texture(new _BaseTexture2.default(source));
	      } else if (source instanceof HTMLCanvasElement) {
	        return Texture.fromCanvas(source);
	      } else if (source instanceof HTMLVideoElement) {
	        return Texture.fromVideo(source);
	      } else if (source instanceof _BaseTexture2.default) {
	        return new Texture(source);
	      }

	      // lets assume its a texture!
	      return source;
	    }

	    /**
	     * Adds a texture to the global TextureCache. This cache is shared across the whole Tiny object.
	     *
	     * @static
	     * @param {Tiny.Texture} texture - The Texture to add to the cache.
	     * @param {string} id - The id that the texture will be stored against.
	     */

	  }, {
	    key: 'addTextureToCache',
	    value: function addTextureToCache(texture, id) {
	      _utils.TextureCache[id] = texture;
	    }

	    /**
	     * Remove a texture from the global TextureCache.
	     *
	     * @static
	     * @param {string} id - The id of the texture to be removed
	     * @return {Tiny.Texture} The texture that was removed
	     */

	  }, {
	    key: 'removeTextureFromCache',
	    value: function removeTextureFromCache(id) {
	      var texture = _utils.TextureCache[id];

	      delete _utils.TextureCache[id];
	      delete _utils.BaseTextureCache[id];

	      return texture;
	    }
	  }]);

	  return Texture;
	}(_eventemitter2.default);

	/**
	 * An empty texture, used often to not have to create multiple empty textures.
	 * Can not be destroyed.
	 *
	 * @static
	 * @constant
	 */


	exports.default = Texture;
	Texture.EMPTY = new Texture(new _BaseTexture2.default());
	Texture.EMPTY.destroy = function _emptyDestroy() {/* empty */
	};
	Texture.EMPTY.on = function _emptyOn() {/* empty */
	};
	Texture.EMPTY.once = function _emptyOnce() {/* empty */
	};
	Texture.EMPTY.emit = function _emptyEmit() {/* empty */
	};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(18);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _determineCrossOrigin = __webpack_require__(54);

	var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);

	var _bitTwiddle = __webpack_require__(63);

	var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @extends EventEmitter
	 * @memberof Tiny
	 */
	var BaseTexture = function (_EventEmitter) {
	  _inherits(BaseTexture, _EventEmitter);

	  /**
	   * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.
	   * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture
	   */
	  function BaseTexture(source, scaleMode, resolution) {
	    _classCallCheck(this, BaseTexture);

	    var _this = _possibleConstructorReturn(this, (BaseTexture.__proto__ || Object.getPrototypeOf(BaseTexture)).call(this));

	    _this.uid = (0, _utils.uid)();

	    _this.touched = 0;

	    /**
	     * The resolution / device pixel ratio of the texture
	     *
	     * @member {number}
	     * @default 1
	     */
	    _this.resolution = resolution || _settings2.default.RESOLUTION;

	    /**
	     * The width of the base texture set when the image has loaded
	     *
	     * @readonly
	     * @member {number}
	     */
	    _this.width = 100;

	    /**
	     * The height of the base texture set when the image has loaded
	     *
	     * @readonly
	     * @member {number}
	     */
	    _this.height = 100;

	    // TODO docs
	    // used to store the actual dimensions of the source
	    /**
	     * Used to store the actual width of the source of this texture
	     *
	     * @readonly
	     * @member {number}
	     */
	    _this.realWidth = 100;
	    /**
	     * Used to store the actual height of the source of this texture
	     *
	     * @readonly
	     * @member {number}
	     */
	    _this.realHeight = 100;

	    /**
	     * The scale mode to apply when scaling this texture
	     *
	     * @member {number}
	     * @default Tiny.settings.SCALE_MODE
	     * @see Tiny.SCALE_MODES
	     */
	    _this.scaleMode = scaleMode || _settings2.default.SCALE_MODE;

	    /**
	     * Set to true once the base texture has successfully loaded.
	     *
	     * This is never true if the underlying source fails to load or has no texture data.
	     *
	     * @readonly
	     * @member {boolean}
	     */
	    _this.hasLoaded = false;

	    /**
	     * Set to true if the source is currently loading.
	     *
	     * If an Image source is loading the 'loaded' or 'error' event will be
	     * dispatched when the operation ends. An underyling source that is
	     * immediately-available bypasses loading entirely.
	     *
	     * @readonly
	     * @member {boolean}
	     */
	    _this.isLoading = false;

	    /**
	     * The image source that is used to create the texture.
	     *
	     * TODO: Make this a setter that calls loadSource();
	     *
	     * @readonly
	     * @member {HTMLImageElement|HTMLCanvasElement}
	     */
	    _this.source = null; // set in loadSource, if at all

	    /**
	     * The image source that is used to create the texture. This is used to
	     * store the original Svg source when it is replaced with a canvas element.
	     *
	     * TODO: Currently not in use but could be used when re-scaling svg.
	     *
	     * @readonly
	     * @member {Image}
	     */
	    _this.origSource = null; // set in loadSvg, if at all

	    /**
	     * Type of image defined in source, eg. `png` or `svg`
	     *
	     * @readonly
	     * @member {string}
	     */
	    _this.imageType = null; // set in updateImageType

	    /**
	     * Scale for source image. Used with Svg images to scale them before rasterization.
	     *
	     * @readonly
	     * @member {number}
	     */
	    _this.sourceScale = 1.0;

	    /**
	     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
	     * All blend modes, and shaders written for default value. Change it on your own risk.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    _this.premultipliedAlpha = true;

	    /**
	     * The image url of the texture
	     *
	     * @member {string}
	     */
	    _this.imageUrl = null;

	    /**
	     * Whether or not the texture is a power of two, try to use power of two textures as much
	     * as you can
	     *
	     * @private
	     * @member {boolean}
	     */
	    _this.isPowerOfTwo = false;

	    // used for webGL

	    /**
	     *
	     * Set this to true if a mipmap of this texture needs to be generated. This value needs
	     * to be set before the texture is used
	     * Also the texture must be a power of two size to work
	     *
	     * @member {boolean}
	     * @see Tiny.MIPMAP_TEXTURES
	     */
	    _this.mipmap = _settings2.default.MIPMAP_TEXTURES;

	    /**
	     *
	     * WebGL Texture wrap mode
	     *
	     * @member {number}
	     * @see Tiny.WRAP_MODES
	     */
	    _this.wrapMode = _settings2.default.WRAP_MODE;

	    /**
	     * A map of renderer IDs to webgl textures
	     *
	     * @private
	     * @member {object<number, WebGLTexture>}
	     */
	    _this._glTextures = {};

	    _this._enabled = 0;
	    _this._virtalBoundId = -1;

	    // if no source passed don't try to load
	    if (source) {
	      _this.loadSource(source);
	    }

	    /**
	     * Fired when a not-immediately-available source finishes loading.
	     *
	     * @protected
	     * @event loaded
	     * @memberof Tiny.BaseTexture#
	     */

	    /**
	     * Fired when a not-immediately-available source fails to load.
	     *
	     * @protected
	     * @event error
	     * @memberof PIXI.BaseTexture#
	     */
	    return _this;
	  }

	  /**
	   * Updates the texture on all the webgl renderers, this also assumes the src has changed.
	   *
	   * @fires update
	   */


	  _createClass(BaseTexture, [{
	    key: 'update',
	    value: function update() {
	      // Svg size is handled during load
	      if (this.imageType !== 'svg') {
	        this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
	        this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;

	        this.width = this.realWidth / this.resolution;
	        this.height = this.realHeight / this.resolution;

	        this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);
	      }

	      this.emit('update', this);
	    }

	    /**
	     * Load a source.
	     *
	     * If the source is not-immediately-available, such as an image that needs to be
	     * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
	     * and `hasLoaded` will remain false after this call.
	     *
	     * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
	     *
	     *     if (texture.hasLoaded) {
	       *        // texture ready for use
	       *     } else if (texture.isLoading) {
	       *        // listen to 'loaded' and/or 'error' events on texture
	       *     } else {
	       *        // not loading, not going to load UNLESS the source is reloaded
	       *        // (it may still make sense to listen to the events)
	       *     }
	     *
	     * @protected
	     * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.
	     */

	  }, {
	    key: 'loadSource',
	    value: function loadSource(source) {
	      var wasLoading = this.isLoading;

	      this.hasLoaded = false;
	      this.isLoading = false;

	      if (wasLoading && this.source) {
	        this.source.onload = null;
	        this.source.onerror = null;
	      }

	      var firstSourceLoaded = !this.source;

	      this.source = source;

	      // Apply source if loaded. Otherwise setup appropriate loading monitors.
	      if ((source.src && source.complete || source.getContext) && source.width && source.height) {
	        this._updateImageType();

	        if (this.imageType === 'svg') {
	          this._loadSvgSource();
	        } else {
	          this._sourceLoaded();
	        }

	        if (firstSourceLoaded) {
	          // send loaded event if previous source was null and we have been passed a pre-loaded IMG element
	          this.emit('loaded', this);
	        }
	      } else if (!source.getContext) {
	        // Image fail / not ready
	        this.isLoading = true;

	        var scope = this;

	        source.onload = function () {
	          scope._updateImageType();
	          source.onload = null;
	          source.onerror = null;

	          if (!scope.isLoading) {
	            return;
	          }

	          scope.isLoading = false;
	          scope._sourceLoaded();

	          if (scope.imageType === 'svg') {
	            scope._loadSvgSource();

	            return;
	          }

	          scope.emit('loaded', scope);
	        };

	        source.onerror = function () {
	          source.onload = null;
	          source.onerror = null;

	          if (!scope.isLoading) {
	            return;
	          }

	          scope.isLoading = false;
	          scope.emit('error', scope);
	        };

	        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
	        //   "The value of `complete` can thus change while a script is executing."
	        // So complete needs to be re-checked after the callbacks have been added..
	        // NOTE: complete will be true if the image has no src so best to check if the src is set.
	        if (source.complete && source.src) {
	          // ..and if we're complete now, no need for callbacks
	          source.onload = null;
	          source.onerror = null;

	          if (scope.imageType === 'svg') {
	            scope._loadSvgSource();

	            return;
	          }

	          this.isLoading = false;

	          if (source.width && source.height) {
	            this._sourceLoaded();

	            // If any previous subscribers possible
	            if (wasLoading) {
	              this.emit('loaded', this);
	            }
	          } else if (wasLoading) {
	            // If any previous subscribers possible
	            this.emit('error', this);
	          }
	        }
	      }
	    }

	    /**
	     * Updates type of the source image.
	     */

	  }, {
	    key: '_updateImageType',
	    value: function _updateImageType() {
	      if (!this.imageUrl) {
	        return;
	      }

	      var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
	      var imageType = void 0;

	      if (dataUri && dataUri.mediaType === 'image') {
	        // Check for subType validity
	        var firstSubType = dataUri.subType.split('+')[0];

	        imageType = (0, _utils.getUrlFileExtension)('.' + firstSubType);

	        if (!imageType) {
	          throw new Error('Invalid image type in data URI.');
	        }
	      } else {
	        imageType = (0, _utils.getUrlFileExtension)(this.imageUrl);

	        if (!imageType) {
	          imageType = 'png';
	        }
	      }

	      this.imageType = imageType;
	    }

	    /**
	     * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls
	     * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.
	     */

	  }, {
	    key: '_loadSvgSource',
	    value: function _loadSvgSource() {
	      if (this.imageType !== 'svg') {
	        // Do nothing if source is not svg
	        return;
	      }

	      var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);

	      if (dataUri) {
	        this._loadSvgSourceUsingDataUri(dataUri);
	      } else {
	        // We got an URL, so we need to do an XHR to check the svg size
	        this._loadSvgSourceUsingXhr();
	      }
	    }

	    /**
	     * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.
	     *
	     * @param {string} dataUri - The data uri to load from.
	     */

	  }, {
	    key: '_loadSvgSourceUsingDataUri',
	    value: function _loadSvgSourceUsingDataUri(dataUri) {
	      var svgString = void 0;

	      if (dataUri.encoding === 'base64') {
	        if (!atob) {
	          throw new Error('Your browser doesn\'t support base64 conversions.');
	        }
	        svgString = atob(dataUri.data);
	      } else {
	        svgString = dataUri.data;
	      }

	      this._loadSvgSourceUsingString(svgString);
	    }

	    /**
	     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.
	     */

	  }, {
	    key: '_loadSvgSourceUsingXhr',
	    value: function _loadSvgSourceUsingXhr() {
	      var _this2 = this;

	      var svgXhr = new XMLHttpRequest();

	      // This throws error on IE, so SVG Document can't be used
	      // svgXhr.responseType = 'document';

	      // This is not needed since we load the svg as string (breaks IE too)
	      // but overrideMimeType() can be used to force the response to be parsed as XML
	      // svgXhr.overrideMimeType('image/svg+xml');

	      svgXhr.onload = function () {
	        if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
	          throw new Error('Failed to load SVG using XHR.');
	        }

	        _this2._loadSvgSourceUsingString(svgXhr.response);
	      };

	      svgXhr.onerror = function () {
	        return _this2.emit('error', _this2);
	      };

	      svgXhr.open('GET', this.imageUrl, true);
	      svgXhr.send();
	    }

	    /**
	     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
	     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
	     * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.
	     *
	     * @param  {string} svgString SVG source as string
	     *
	     * @fires loaded
	     */

	  }, {
	    key: '_loadSvgSourceUsingString',
	    value: function _loadSvgSourceUsingString(svgString) {
	      var svgSize = (0, _utils.getSvgSize)(svgString);

	      var svgWidth = svgSize.width;
	      var svgHeight = svgSize.height;

	      if (!svgWidth || !svgHeight) {
	        throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
	      }

	      // Scale realWidth and realHeight
	      this.realWidth = Math.round(svgWidth * this.sourceScale);
	      this.realHeight = Math.round(svgHeight * this.sourceScale);

	      this.width = this.realWidth / this.resolution;
	      this.height = this.realHeight / this.resolution;

	      // Check pow2 after scale
	      this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);

	      // Create a canvas element
	      var canvas = document.createElement('canvas');

	      canvas.width = this.realWidth;
	      canvas.height = this.realHeight;
	      canvas._tinyId = 'canvas_' + (0, _utils.uid)();

	      // Draw the Svg to the canvas
	      canvas.getContext('2d').drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);

	      // Replace the original source image with the canvas
	      this.origSource = this.source;
	      this.source = canvas;

	      // Add also the canvas in cache (destroy clears by `imageUrl` and `source._tinyId`)
	      _utils.BaseTextureCache[canvas._tinyId] = this;

	      this.isLoading = false;
	      this._sourceLoaded();
	      this.emit('loaded', this);
	    }

	    /**
	     * Used internally to update the width, height, and some other tracking vars once
	     * a source has successfully loaded.
	     *
	     * @private
	     */

	  }, {
	    key: '_sourceLoaded',
	    value: function _sourceLoaded() {
	      this.hasLoaded = true;
	      this.update();
	    }

	    /**
	     * Destroys this base texture
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this.imageUrl) {
	        delete _utils.BaseTextureCache[this.imageUrl];
	        delete _utils.TextureCache[this.imageUrl];

	        this.imageUrl = null;

	        if (!navigator.isCocoonJS) {
	          this.source.src = '';
	        }
	      }
	      // An svg source has both `imageUrl` and `__tinyId`, so no `else if` here
	      if (this.source && this.source._tinyId) {
	        delete _utils.BaseTextureCache[this.source._tinyId];
	      }

	      this.source = null;

	      this.dispose();
	    }

	    /**
	     * Frees the texture from WebGL memory without destroying this texture object.
	     * This means you can still use the texture later which will upload it to GPU
	     * memory again.
	     *
	     */

	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.emit('dispose', this);
	    }

	    /**
	     * Changes the source image of the texture.
	     * The original source must be an Image element.
	     *
	     * @param {string} newSrc - the path of the image
	     */

	  }, {
	    key: 'updateSourceImage',
	    value: function updateSourceImage(newSrc) {
	      this.source.src = newSrc;

	      this.loadSource(this.source);
	    }

	    /**
	     * Helper function that creates a base texture from the given image url.
	     * If the image is not in the base texture cache it will be created and loaded.
	     *
	     * @static
	     * @param {string} imageUrl - The image url of the texture
	     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
	     * @return {Tiny.BaseTexture} The new base texture.
	     */

	  }], [{
	    key: 'fromImage',
	    value: function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
	      var baseTexture = _utils.BaseTextureCache[imageUrl];

	      if (!baseTexture) {
	        // new Image() breaks tex loading in some versions of Chrome.
	        // See https://code.google.com/p/chromium/issues/detail?id=238071
	        var image = new Image(); // document.createElement('img');

	        if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {
	          image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl);
	        }

	        baseTexture = new BaseTexture(image, scaleMode);
	        baseTexture.imageUrl = imageUrl;

	        if (sourceScale) {
	          baseTexture.sourceScale = sourceScale;
	        }

	        // if there is an @2x at the end of the url we are going to assume its a highres image
	        baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);

	        image.src = imageUrl; // Setting this triggers load

	        _utils.BaseTextureCache[imageUrl] = baseTexture;
	      }

	      return baseTexture;
	    }

	    /**
	     * Helper function that creates a base texture from the given canvas element.
	     *
	     * @static
	     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
	     * @param {number} scaleMode - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.BaseTexture} The new base texture.
	     */

	  }, {
	    key: 'fromCanvas',
	    value: function fromCanvas(canvas, scaleMode) {
	      if (!canvas._tinyId) {
	        canvas._tinyId = 'canvas_' + (0, _utils.uid)();
	      }

	      var baseTexture = _utils.BaseTextureCache[canvas._tinyId];

	      if (!baseTexture) {
	        baseTexture = new BaseTexture(canvas, scaleMode);
	        _utils.BaseTextureCache[canvas._tinyId] = baseTexture;
	      }

	      return baseTexture;
	    }
	  }]);

	  return BaseTexture;
	}(_eventemitter2.default);

	exports.default = BaseTexture;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = determineCrossOrigin;

	var _url2 = __webpack_require__(55);

	var _url3 = _interopRequireDefault(_url2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tempAnchor = void 0;

	/**
	 * Sets the `crossOrigin` property for this resource based on if the url
	 * for this resource is cross-origin. If crossOrigin was manually set, this
	 * function does nothing.
	 * Nipped from the resource loader!
	 *
	 * @ignore
	 * @param {string} url - The url to test.
	 * @param {object} [loc=window.location] - The location object to test against.
	 * @return {string} The crossOrigin value to use (or empty string for none).
	 */
	function determineCrossOrigin(url) {
	  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;

	  // data: and javascript: urls are considered same-origin
	  if (url.indexOf('data:') === 0) {
	    return '';
	  }

	  // default is window.location
	  loc = loc || window.location;

	  if (!tempAnchor) {
	    tempAnchor = document.createElement('a');
	  }

	  // let the browser determine the full href for the url of this resource and then
	  // parse with the node url lib, we can't use the properties of the anchor element
	  // because they don't work in IE9 :(
	  tempAnchor.href = url;
	  url = _url3.default.parse(tempAnchor.href);

	  var samePort = !url.port && loc.port === '' || url.port === loc.port;

	  // if cross origin
	  if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
	    return 'anonymous';
	  }

	  return '';
	}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var punycode = __webpack_require__(56);
	var util = __webpack_require__(59);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,


	// Special case for a simple path URL
	simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


	// RFC 2396: characters reserved for delimiting URLs.
	// We actually just auto-escape these.
	delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


	// RFC 2396: characters not allowed for various reasons.
	unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


	// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	autoEscape = ['\''].concat(unwise),

	// Characters that are never ever allowed in a hostname.
	// Note that any invalid chars are also handled, but these
	// are the ones that are *expected* to be seen, so we fast-path
	// them.
	nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

	// protocols that can allow "unsafe" and "unwise" chars.
	unsafeProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that never have a hostname.
	hostlessProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that always contain a // bit.
	slashedProtocol = {
	  'http': true,
	  'https': true,
	  'ftp': true,
	  'gopher': true,
	  'file': true,
	  'http:': true,
	  'https:': true,
	  'ftp:': true,
	  'gopher:': true,
	  'file:': true
	},
	    querystring = __webpack_require__(60);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;

	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
	  }

	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || query && '?' + query || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function (relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol') result[rkey] = relative[rkey];
	    }

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) {}
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || result.host && srcPath.length;

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function (root) {

		/** Detect free variables */
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
			root = freeGlobal;
		}

		/**
	  * The `punycode` object.
	  * @name punycode
	  * @type Object
	  */
		var punycode,


		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647,
		    // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		    tMin = 1,
		    tMax = 26,
		    skew = 38,
		    damp = 700,
		    initialBias = 72,
		    initialN = 128,
		    // 0x80
		delimiter = '-',
		    // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		    regexNonASCII = /[^\x20-\x7E]/,
		    // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
		    // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},


		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		    floor = Math.floor,
		    stringFromCharCode = String.fromCharCode,


		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
	  * A generic error utility function.
	  * @private
	  * @param {String} type The error type.
	  * @returns {Error} Throws a `RangeError` with the applicable error message.
	  */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
	  * A generic `Array#map` utility function.
	  * @private
	  * @param {Array} array The array to iterate over.
	  * @param {Function} callback The function that gets called for every array
	  * item.
	  * @returns {Array} A new array of values returned by the callback function.
	  */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
	  * A simple `Array#map`-like wrapper to work with domain name strings or email
	  * addresses.
	  * @private
	  * @param {String} domain The domain name or email address.
	  * @param {Function} callback The function that gets called for every
	  * character.
	  * @returns {Array} A new string of characters returned by the callback
	  * function.
	  */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
	  * Creates an array containing the numeric code points of each Unicode
	  * character in the string. While JavaScript uses UCS-2 internally,
	  * this function will convert a pair of surrogate halves (each of which
	  * UCS-2 exposes as separate characters) into a single code point,
	  * matching UTF-16.
	  * @see `punycode.ucs2.encode`
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode.ucs2
	  * @name decode
	  * @param {String} string The Unicode input string (UCS-2).
	  * @returns {Array} The new array of code points.
	  */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
	  * Creates a string based on an array of numeric code points.
	  * @see `punycode.ucs2.decode`
	  * @memberOf punycode.ucs2
	  * @name encode
	  * @param {Array} codePoints The array of numeric code points.
	  * @returns {String} The new Unicode string (UCS-2).
	  */
		function ucs2encode(array) {
			return map(array, function (value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
	  * Converts a basic code point into a digit/integer.
	  * @see `digitToBasic()`
	  * @private
	  * @param {Number} codePoint The basic numeric code point value.
	  * @returns {Number} The numeric value of a basic code point (for use in
	  * representing integers) in the range `0` to `base - 1`, or `base` if
	  * the code point does not represent a value.
	  */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
	  * Converts a digit/integer into a basic code point.
	  * @see `basicToDigit()`
	  * @private
	  * @param {Number} digit The numeric value of a basic code point.
	  * @returns {Number} The basic code point whose value (when used for
	  * representing integers) is `digit`, which needs to be in the range
	  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  * used; else, the lowercase form is used. The behavior is undefined
	  * if `flag` is non-zero and `digit` has no uppercase form.
	  */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
	  * Bias adaptation function as per section 3.4 of RFC 3492.
	  * http://tools.ietf.org/html/rfc3492#section-3.4
	  * @private
	  */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
	  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  * symbols.
	  * @memberOf punycode
	  * @param {String} input The Punycode string of ASCII-only symbols.
	  * @returns {String} The resulting string of Unicode symbols.
	  */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,

			/** Cached calculation results */
			baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;
				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
			}

			return ucs2encode(output);
		}

		/**
	  * Converts a string of Unicode symbols (e.g. a domain name label) to a
	  * Punycode string of ASCII-only symbols.
	  * @memberOf punycode
	  * @param {String} input The string of Unicode symbols.
	  * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],

			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,

			/** Cached calculation results */
			handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base;; /* no condition */k += base) {
							t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;
			}
			return output.join('');
		}

		/**
	  * Converts a Punycode string representing a domain name or an email address
	  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	  * it doesn't matter if you call it on a string that has already been
	  * converted to Unicode.
	  * @memberOf punycode
	  * @param {String} input The Punycoded domain name or email address to
	  * convert to Unicode.
	  * @returns {String} The Unicode representation of the given Punycode
	  * string.
	  */
		function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		}

		/**
	  * Converts a Unicode string representing a domain name or an email address to
	  * Punycode. Only the non-ASCII parts of the domain name will be converted,
	  * i.e. it doesn't matter if you call it with a domain that's already in
	  * ASCII.
	  * @memberOf punycode
	  * @param {String} input The domain name or email address to convert, as a
	  * Unicode string.
	  * @returns {String} The Punycode representation of the given domain name or
	  * email address.
	  */
		function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */
			'version': '1.3.2',
			/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(58)) == 'object' && __webpack_require__(58)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)(module), (function() { return this; }())))

/***/ }),
/* 57 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 58 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	module.exports = {
	  isString: function isString(arg) {
	    return typeof arg === 'string';
	  },
	  isObject: function isObject(arg) {
	    return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	  },
	  isNull: function isNull(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function isNullOrUndefined(arg) {
	    return arg == null;
	  }
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(61);
	exports.encode = exports.stringify = __webpack_require__(62);

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function (qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr,
	        vstr,
	        k,
	        v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return Object.keys(obj).map(function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	/**
	 * Bit twiddling hacks for JavaScript.
	 *
	 * Author: Mikola Lysenko
	 *
	 * Ported from Stanford bit twiddling hack library:
	 *    http://graphics.stanford.edu/~seander/bithacks.html
	 */

	"use strict";"use restrict";

	//Number of bits in an integer

	var INT_BITS = 32;

	//Constants
	exports.INT_BITS = INT_BITS;
	exports.INT_MAX = 0x7fffffff;
	exports.INT_MIN = -1 << INT_BITS - 1;

	//Returns -1, 0, +1 depending on sign of x
	exports.sign = function (v) {
	  return (v > 0) - (v < 0);
	};

	//Computes absolute value of integer
	exports.abs = function (v) {
	  var mask = v >> INT_BITS - 1;
	  return (v ^ mask) - mask;
	};

	//Computes minimum of integers x and y
	exports.min = function (x, y) {
	  return y ^ (x ^ y) & -(x < y);
	};

	//Computes maximum of integers x and y
	exports.max = function (x, y) {
	  return x ^ (x ^ y) & -(x < y);
	};

	//Checks if a number is a power of two
	exports.isPow2 = function (v) {
	  return !(v & v - 1) && !!v;
	};

	//Computes log base 2 of v
	exports.log2 = function (v) {
	  var r, shift;
	  r = (v > 0xFFFF) << 4;v >>>= r;
	  shift = (v > 0xFF) << 3;v >>>= shift;r |= shift;
	  shift = (v > 0xF) << 2;v >>>= shift;r |= shift;
	  shift = (v > 0x3) << 1;v >>>= shift;r |= shift;
	  return r | v >> 1;
	};

	//Computes log base 10 of v
	exports.log10 = function (v) {
	  return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
	};

	//Counts number of bits
	exports.popCount = function (v) {
	  v = v - (v >>> 1 & 0x55555555);
	  v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
	  return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
	};

	//Counts number of trailing zeros
	function countTrailingZeros(v) {
	  var c = 32;
	  v &= -v;
	  if (v) c--;
	  if (v & 0x0000FFFF) c -= 16;
	  if (v & 0x00FF00FF) c -= 8;
	  if (v & 0x0F0F0F0F) c -= 4;
	  if (v & 0x33333333) c -= 2;
	  if (v & 0x55555555) c -= 1;
	  return c;
	}
	exports.countTrailingZeros = countTrailingZeros;

	//Rounds to next power of 2
	exports.nextPow2 = function (v) {
	  v += v === 0;
	  --v;
	  v |= v >>> 1;
	  v |= v >>> 2;
	  v |= v >>> 4;
	  v |= v >>> 8;
	  v |= v >>> 16;
	  return v + 1;
	};

	//Rounds down to previous power of 2
	exports.prevPow2 = function (v) {
	  v |= v >>> 1;
	  v |= v >>> 2;
	  v |= v >>> 4;
	  v |= v >>> 8;
	  v |= v >>> 16;
	  return v - (v >>> 1);
	};

	//Computes parity of word
	exports.parity = function (v) {
	  v ^= v >>> 16;
	  v ^= v >>> 8;
	  v ^= v >>> 4;
	  v &= 0xf;
	  return 0x6996 >>> v & 1;
	};

	var REVERSE_TABLE = new Array(256);

	(function (tab) {
	  for (var i = 0; i < 256; ++i) {
	    var v = i,
	        r = i,
	        s = 7;
	    for (v >>>= 1; v; v >>>= 1) {
	      r <<= 1;
	      r |= v & 1;
	      --s;
	    }
	    tab[i] = r << s & 0xff;
	  }
	})(REVERSE_TABLE);

	//Reverse bits in a 32 bit word
	exports.reverse = function (v) {
	  return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
	};

	//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
	exports.interleave2 = function (x, y) {
	  x &= 0xFFFF;
	  x = (x | x << 8) & 0x00FF00FF;
	  x = (x | x << 4) & 0x0F0F0F0F;
	  x = (x | x << 2) & 0x33333333;
	  x = (x | x << 1) & 0x55555555;

	  y &= 0xFFFF;
	  y = (y | y << 8) & 0x00FF00FF;
	  y = (y | y << 4) & 0x0F0F0F0F;
	  y = (y | y << 2) & 0x33333333;
	  y = (y | y << 1) & 0x55555555;

	  return x | y << 1;
	};

	//Extracts the nth interleaved component
	exports.deinterleave2 = function (v, n) {
	  v = v >>> n & 0x55555555;
	  v = (v | v >>> 1) & 0x33333333;
	  v = (v | v >>> 2) & 0x0F0F0F0F;
	  v = (v | v >>> 4) & 0x00FF00FF;
	  v = (v | v >>> 16) & 0x000FFFF;
	  return v << 16 >> 16;
	};

	//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
	exports.interleave3 = function (x, y, z) {
	  x &= 0x3FF;
	  x = (x | x << 16) & 4278190335;
	  x = (x | x << 8) & 251719695;
	  x = (x | x << 4) & 3272356035;
	  x = (x | x << 2) & 1227133513;

	  y &= 0x3FF;
	  y = (y | y << 16) & 4278190335;
	  y = (y | y << 8) & 251719695;
	  y = (y | y << 4) & 3272356035;
	  y = (y | y << 2) & 1227133513;
	  x |= y << 1;

	  z &= 0x3FF;
	  z = (z | z << 16) & 4278190335;
	  z = (z | z << 8) & 251719695;
	  z = (z | z << 4) & 3272356035;
	  z = (z | z << 2) & 1227133513;

	  return x | z << 2;
	};

	//Extracts nth interleaved component of a 3-tuple
	exports.deinterleave3 = function (v, n) {
	  v = v >>> n & 1227133513;
	  v = (v | v >>> 2) & 3272356035;
	  v = (v | v >>> 4) & 251719695;
	  v = (v | v >>> 8) & 4278190335;
	  v = (v | v >>> 16) & 0x3FF;
	  return v << 22 >> 22;
	};

	//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
	exports.nextCombination = function (v) {
	  var t = v | v - 1;
	  return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
	};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _BaseTexture2 = __webpack_require__(53);

	var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

	var _utils = __webpack_require__(18);

	var _ticker = __webpack_require__(65);

	var ticker = _interopRequireWildcard(_ticker);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A texture of a [playing] Video.
	 *
	 * Video base textures mimic Tiny BaseTexture.from.... method in their creation process.
	 *
	 * This can be used in several ways, such as:
	 *
	 * ```js
	 * let texture = Tiny.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * let texture = Tiny.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * let texture = Tiny.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * let texture = Tiny.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
	 *
	 * @class
	 * @extends Tiny.BaseTexture
	 * @memberof Tiny
	 */
	var VideoBaseTexture = function (_BaseTexture) {
	  _inherits(VideoBaseTexture, _BaseTexture);

	  /**
	   * @param {HTMLVideoElement} source - Video source
	   * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	   */
	  function VideoBaseTexture(source, scaleMode) {
	    _classCallCheck(this, VideoBaseTexture);

	    if (!source) {
	      throw new Error('No video source element specified.');
	    }

	    // hook in here to check if video is already available.
	    // BaseTexture looks for a source.complete boolean, plus width & height.

	    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
	      source.complete = true;
	    }

	    var _this = _possibleConstructorReturn(this, (VideoBaseTexture.__proto__ || Object.getPrototypeOf(VideoBaseTexture)).call(this, source, scaleMode));

	    _this.width = source.videoWidth;
	    _this.height = source.videoHeight;

	    _this._autoUpdate = true;
	    _this._isAutoUpdating = false;

	    /**
	     * When set to true will automatically play videos used by this texture once
	     * they are loaded. If false, it will not modify the playing state.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    _this.autoPlay = true;

	    _this.update = _this.update.bind(_this);
	    _this._onCanPlay = _this._onCanPlay.bind(_this);

	    source.addEventListener('play', _this._onPlayStart.bind(_this));
	    source.addEventListener('pause', _this._onPlayStop.bind(_this));
	    _this.hasLoaded = false;
	    _this.__loaded = false;

	    if (!_this._isSourceReady()) {
	      source.addEventListener('canplay', _this._onCanPlay);
	      source.addEventListener('canplaythrough', _this._onCanPlay);
	    } else {
	      _this._onCanPlay();
	    }
	    return _this;
	  }

	  /**
	   * Returns true if the underlying source is playing.
	   *
	   * @private
	   * @return {boolean} True if playing.
	   */


	  _createClass(VideoBaseTexture, [{
	    key: '_isSourcePlaying',
	    value: function _isSourcePlaying() {
	      var source = this.source;

	      return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
	    }

	    /**
	     * Returns true if the underlying source is ready for playing.
	     *
	     * @private
	     * @return {boolean} True if ready.
	     */

	  }, {
	    key: '_isSourceReady',
	    value: function _isSourceReady() {
	      return this.source.readyState === 3 || this.source.readyState === 4;
	    }

	    /**
	     * Runs the update loop when the video is ready to play
	     *
	     * @private
	     */

	  }, {
	    key: '_onPlayStart',
	    value: function _onPlayStart() {
	      // Just in case the video has not received its can play even yet..
	      if (!this.hasLoaded) {
	        this._onCanPlay();
	      }

	      if (!this._isAutoUpdating && this.autoUpdate) {
	        ticker.shared.add(this.update, this);
	        this._isAutoUpdating = true;
	      }
	    }

	    /**
	     * Fired when a pause event is triggered, stops the update loop
	     *
	     * @private
	     */

	  }, {
	    key: '_onPlayStop',
	    value: function _onPlayStop() {
	      if (this._isAutoUpdating) {
	        ticker.shared.remove(this.update, this);
	        this._isAutoUpdating = false;
	      }
	    }

	    /**
	     * Fired when the video is loaded and ready to play
	     *
	     * @private
	     */

	  }, {
	    key: '_onCanPlay',
	    value: function _onCanPlay() {
	      this.hasLoaded = true;

	      if (this.source) {
	        this.source.removeEventListener('canplay', this._onCanPlay);
	        this.source.removeEventListener('canplaythrough', this._onCanPlay);

	        this.width = this.source.videoWidth;
	        this.height = this.source.videoHeight;

	        // prevent multiple loaded dispatches..
	        if (!this.__loaded) {
	          this.__loaded = true;
	          this.emit('loaded', this);
	        }

	        if (this._isSourcePlaying()) {
	          this._onPlayStart();
	        } else if (this.autoPlay) {
	          this.source.play();
	        }
	      }
	    }

	    /**
	     * Destroys this texture
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this._isAutoUpdating) {
	        ticker.shared.remove(this.update, this);
	      }

	      if (this.source && this.source._tinyId) {
	        delete _utils.BaseTextureCache[this.source._tinyId];
	        delete this.source._tinyId;
	      }

	      _get(VideoBaseTexture.prototype.__proto__ || Object.getPrototypeOf(VideoBaseTexture.prototype), 'destroy', this).call(this);
	    }

	    /**
	     * Mimic Tiny BaseTexture.from.... method.
	     *
	     * @static
	     * @param {HTMLVideoElement} video - Video to create texture from
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.VideoBaseTexture} Newly created VideoBaseTexture
	     */

	  }, {
	    key: 'autoUpdate',


	    /**
	     * Should the base texture automatically update itself, set to true by default
	     *
	     * @member {boolean}
	     */
	    get: function get() {
	      return this._autoUpdate;
	    },
	    set: function set(value) {
	      if (value !== this._autoUpdate) {
	        this._autoUpdate = value;

	        if (!this._autoUpdate && this._isAutoUpdating) {
	          ticker.shared.remove(this.update, this);
	          this._isAutoUpdating = false;
	        } else if (this._autoUpdate && !this._isAutoUpdating) {
	          ticker.shared.add(this.update, this);
	          this._isAutoUpdating = true;
	        }
	      }
	    }
	  }], [{
	    key: 'fromVideo',
	    value: function fromVideo(video, scaleMode) {
	      if (!video._tinyId) {
	        video._tinyId = 'video_' + (0, _utils.uid)();
	      }

	      var baseTexture = _utils.BaseTextureCache[video._tinyId];

	      if (!baseTexture) {
	        baseTexture = new VideoBaseTexture(video, scaleMode);
	        _utils.BaseTextureCache[video._tinyId] = baseTexture;
	      }

	      return baseTexture;
	    }

	    /**
	     * Helper function that creates a new BaseTexture based on the given video element.
	     * This BaseTexture can then be used to create a texture
	     *
	     * @static
	     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.
	     * @param {string} [videoSrc.src] - One of the source urls for the video
	     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified
	     *  the url's extension will be used as the second part of the mime type.
	     * @param {number} scaleMode - See {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.VideoBaseTexture} Newly created VideoBaseTexture
	     */

	  }, {
	    key: 'fromUrl',
	    value: function fromUrl(videoSrc, scaleMode) {
	      var video = document.createElement('video');

	      video.setAttribute('webkit-playsinline', '');
	      video.setAttribute('playsinline', '');

	      // array of objects or strings
	      if (Array.isArray(videoSrc)) {
	        for (var i = 0; i < videoSrc.length; ++i) {
	          video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
	        }
	      } else {
	        // single object or string
	        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
	      }

	      video.load();

	      return VideoBaseTexture.fromVideo(video, scaleMode);
	    }
	  }]);

	  return VideoBaseTexture;
	}(_BaseTexture3.default);

	exports.default = VideoBaseTexture;


	VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

	function createSource(path, type) {
	  if (!type) {
	    type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
	  }

	  var source = document.createElement('source');

	  source.src = path;
	  source.type = type;

	  return source;
	}

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Ticker = exports.shared = undefined;

	var _Ticker = __webpack_require__(66);

	var _Ticker2 = _interopRequireDefault(_Ticker);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The shared ticker instance used by {@link PIXI.extras.AnimatedSprite}.
	 * and by {@link Tiny.interaction.InteractionManager}.
	 * The property {@link Tiny.ticker.Ticker#autoStart} is set to `true`
	 * for this instance. Please follow the examples for usage, including
	 * how to opt-out of auto-starting the shared ticker.
	 *
	 * @example
	 * let ticker = Tiny.ticker.shared;
	 * // Set this to prevent starting this ticker when listeners are added.
	 * // By default this is true only for the Tiny.ticker.shared instance.
	 * ticker.autoStart = false;
	 * // FYI, call this to ensure the ticker is stopped. It should be stopped
	 * // if you have not attempted to render anything yet.
	 * ticker.stop();
	 * // Call this when you are ready for a running shared ticker.
	 * ticker.start();
	 *
	 * @example
	 * // You may use the shared ticker to render...
	 * let renderer = Tiny.autoDetectRenderer(800, 600);
	 * let stage = new Tiny.Container();
	 * let interactionManager = Tiny.interaction.InteractionManager(renderer);
	 * document.body.appendChild(renderer.view);
	 * ticker.add(function (time) {
	 *     renderer.render(stage);
	 * });
	 *
	 * @example
	 * // Or you can just update it manually.
	 * ticker.autoStart = false;
	 * ticker.stop();
	 * function animate(time) {
	 *     ticker.update(time);
	 *     renderer.render(stage);
	 *     requestAnimationFrame(animate);
	 * }
	 * animate(performance.now());
	 *
	 * @type {Tiny.ticker.Ticker}
	 * @memberof Tiny.ticker
	 */
	var shared = new _Ticker2.default();

	shared.autoStart = true;

	/**
	 * @namespace Tiny.ticker
	 */
	exports.shared = shared;
	exports.Ticker = _Ticker2.default;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Internal event used by composed emitter
	var TICK = 'tick';

	/**
	 * A Ticker class that runs an update loop that other objects listen to.
	 * This class is composed around an EventEmitter object to add listeners
	 * meant for execution on the next requested animation frame.
	 * Animation frames are requested only when necessary,
	 * e.g. When the ticker is started and the emitter has listeners.
	 *
	 * @class
	 * @memberof Tiny.ticker
	 */

	var Ticker = function () {
	  /**
	   *
	   */
	  function Ticker() {
	    var _this = this;

	    _classCallCheck(this, Ticker);

	    /**
	     * Internal emitter used to fire 'tick' event
	     * @private
	     */
	    this._emitter = new _eventemitter2.default();

	    /**
	     * Internal current frame request ID
	     * @private
	     */
	    this._requestId = null;

	    /**
	     * Internal value managed by minFPS property setter and getter.
	     * This is the maximum allowed milliseconds between updates.
	     * @private
	     */
	    this._maxElapsedMS = 100;

	    /**
	     * Whether or not this ticker should invoke the method
	     * {@link Tiny.ticker.Ticker#start} automatically
	     * when a listener is added.
	     *
	     * @member {boolean}
	     * @default false
	     */
	    this.autoStart = false;

	    /**
	     * Scalar time value from last frame to this frame.
	     * This value is capped by setting {@link Tiny.ticker.Ticker#minFPS}
	     * and is scaled with {@link Tiny.ticker.Ticker#speed}.
	     * **Note:** The cap may be exceeded by scaling.
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.deltaTime = 1;

	    /**
	     * Time elapsed in milliseconds from last frame to this frame.
	     * Opposed to what the scalar {@link Tiny.ticker.Ticker#deltaTime}
	     * is based, this value is neither capped nor scaled.
	     * If the platform supports DOMHighResTimeStamp,
	     * this value will have a precision of 1 µs.
	     *
	     * @member {number}
	     * @default 1 / TARGET_FPMS
	     */
	    this.elapsedMS = 1 / _settings2.default.TARGET_FPMS; // default to target frame time

	    /**
	     * The last time {@link Tiny.ticker.Ticker#update} was invoked.
	     * This value is also reset internally outside of invoking
	     * update, but only when a new animation frame is requested.
	     * If the platform supports DOMHighResTimeStamp,
	     * this value will have a precision of 1 µs.
	     *
	     * @member {number}
	     * @default 0
	     */
	    this.lastTime = 0;

	    /**
	     * Factor of current {@link Tiny.ticker.Ticker#deltaTime}.
	     * @example
	     * // Scales ticker.deltaTime to what would be
	     * // the equivalent of approximately 120 FPS
	     * ticker.speed = 2;
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.speed = 1;

	    /**
	     * Whether or not this ticker has been started.
	     * `true` if {@link Tiny.ticker.Ticker#start} has been called.
	     * `false` if {@link Tiny.ticker.Ticker#stop} has been called.
	     * While `false`, this value may change to `true` in the
	     * event of {@link Tiny.ticker.Ticker#autoStart} being `true`
	     * and a listener is added.
	     *
	     * @member {boolean}
	     * @default false
	     */
	    this.started = false;

	    /**
	     * Internal tick method bound to ticker instance.
	     * This is because in early 2015, Function.bind
	     * is still 60% slower in high performance scenarios.
	     * Also separating frame requests from update method
	     * so listeners may be called at any time and with
	     * any animation API, just invoke ticker.update(time).
	     *
	     * @private
	     * @param {number} time - Time since last tick.
	     */
	    this._tick = function (time) {
	      _this._requestId = null;

	      if (_this.started) {
	        // Invoke listeners now
	        _this.update(time);
	        // Listener side effects may have modified ticker state.
	        if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true)) {
	          _this._requestId = requestAnimationFrame(_this._tick);
	        }
	      }
	    };
	  }

	  /**
	   * Conditionally requests a new animation frame.
	   * If a frame has not already been requested, and if the internal
	   * emitter has listeners, a new frame is requested.
	   *
	   * @private
	   */


	  _createClass(Ticker, [{
	    key: '_requestIfNeeded',
	    value: function _requestIfNeeded() {
	      if (this._requestId === null && this._emitter.listeners(TICK, true)) {
	        // ensure callbacks get correct delta
	        this.lastTime = performance.now();
	        this._requestId = requestAnimationFrame(this._tick);
	      }
	    }

	    /**
	     * Conditionally cancels a pending animation frame.
	     *
	     * @private
	     */

	  }, {
	    key: '_cancelIfNeeded',
	    value: function _cancelIfNeeded() {
	      if (this._requestId !== null) {
	        cancelAnimationFrame(this._requestId);
	        this._requestId = null;
	      }
	    }

	    /**
	     * Conditionally requests a new animation frame.
	     * If the ticker has been started it checks if a frame has not already
	     * been requested, and if the internal emitter has listeners. If these
	     * conditions are met, a new frame is requested. If the ticker has not
	     * been started, but autoStart is `true`, then the ticker starts now,
	     * and continues with the previous conditions to request a new frame.
	     *
	     * @private
	     */

	  }, {
	    key: '_startIfPossible',
	    value: function _startIfPossible() {
	      if (this.started) {
	        this._requestIfNeeded();
	      } else if (this.autoStart) {
	        this.start();
	      }
	    }

	    /**
	     * Calls {@link module:eventemitter3.EventEmitter#on} internally for the
	     * internal 'tick' event. It checks if the emitter has listeners,
	     * and if so it requests a new animation frame at this point.
	     *
	     * @param {Function} fn - The listener function to be added for updates
	     * @param {Function} [context] - The listener context
	     * @return {Tiny.ticker.Ticker} This instance of a ticker
	     */

	  }, {
	    key: 'add',
	    value: function add(fn, context) {
	      this._emitter.on(TICK, fn, context);

	      this._startIfPossible();

	      return this;
	    }

	    /**
	     * Calls {@link module:eventemitter3.EventEmitter#once} internally for the
	     * internal 'tick' event. It checks if the emitter has listeners,
	     * and if so it requests a new animation frame at this point.
	     *
	     * @param {Function} fn - The listener function to be added for one update
	     * @param {Function} [context] - The listener context
	     * @return {Tiny.ticker.Ticker} This instance of a ticker
	     */

	  }, {
	    key: 'addOnce',
	    value: function addOnce(fn, context) {
	      this._emitter.once(TICK, fn, context);

	      this._startIfPossible();

	      return this;
	    }

	    /**
	     * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.
	     * It checks if the emitter has listeners for 'tick' event.
	     * If it does, then it cancels the animation frame.
	     *
	     * @param {Function} [fn] - The listener function to be removed
	     * @param {Function} [context] - The listener context to be removed
	     * @return {Tiny.ticker.Ticker} This instance of a ticker
	     */

	  }, {
	    key: 'remove',
	    value: function remove(fn, context) {
	      this._emitter.off(TICK, fn, context);

	      if (!this._emitter.listeners(TICK, true)) {
	        this._cancelIfNeeded();
	      }

	      return this;
	    }

	    /**
	     * Starts the ticker. If the ticker has listeners
	     * a new animation frame is requested at this point.
	     */

	  }, {
	    key: 'start',
	    value: function start() {
	      if (!this.started) {
	        this.started = true;
	        this._requestIfNeeded();
	      }
	    }

	    /**
	     * Stops the ticker. If the ticker has requested
	     * an animation frame it is canceled at this point.
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      if (this.started) {
	        this.started = false;
	        this._cancelIfNeeded();
	      }
	    }

	    /**
	     * Triggers an update. An update entails setting the
	     * current {@link Tiny.ticker.Ticker#elapsedMS},
	     * the current {@link Tiny.ticker.Ticker#deltaTime},
	     * invoking all listeners with current deltaTime,
	     * and then finally setting {@link Tiny.ticker.Ticker#lastTime}
	     * with the value of currentTime that was provided.
	     * This method will be called automatically by animation
	     * frame callbacks if the ticker instance has been started
	     * and listeners are added.
	     *
	     * @param {number} [currentTime=performance.now()] - the current time of execution
	     */

	  }, {
	    key: 'update',
	    value: function update() {
	      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();

	      var elapsedMS = void 0;

	      // If the difference in time is zero or negative, we ignore most of the work done here.
	      // If there is no valid difference, then should be no reason to let anyone know about it.
	      // A zero delta, is exactly that, nothing should update.
	      //
	      // The difference in time can be negative, and no this does not mean time traveling.
	      // This can be the result of a race condition between when an animation frame is requested
	      // on the current JavaScript engine event loop, and when the ticker's start method is invoked
	      // (which invokes the internal _requestIfNeeded method). If a frame is requested before
	      // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
	      // can receive a time argument that can be less than the lastTime value that was set within
	      // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
	      //
	      // This check covers this browser engine timing issue, as well as if consumers pass an invalid
	      // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
	      if (currentTime > this.lastTime) {
	        // Save uncapped elapsedMS for measurement
	        elapsedMS = this.elapsedMS = currentTime - this.lastTime;

	        // cap the milliseconds elapsed used for deltaTime
	        if (elapsedMS > this._maxElapsedMS) {
	          elapsedMS = this._maxElapsedMS;
	        }

	        this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;

	        // Invoke listeners added to internal emitter
	        this._emitter.emit(TICK, this.deltaTime);
	      } else {
	        this.deltaTime = this.elapsedMS = 0;
	      }

	      this.lastTime = currentTime;
	    }

	    /**
	     * The frames per second at which this ticker is running.
	     * The default is approximately 60 in most modern browsers.
	     * **Note:** This does not factor in the value of
	     * {@link Tiny.ticker.Ticker#speed}, which is specific
	     * to scaling {@link Tiny.ticker.Ticker#deltaTime}.
	     *
	     * @member {number}
	     * @readonly
	     */

	  }, {
	    key: 'FPS',
	    get: function get() {
	      return 1000 / this.elapsedMS;
	    }

	    /**
	     * Manages the maximum amount of milliseconds allowed to
	     * elapse between invoking {@link Tiny.ticker.Ticker#update}.
	     * This value is used to cap {@link Tiny.ticker.Ticker#deltaTime},
	     * but does not effect the measured value of {@link Tiny.ticker.Ticker#FPS}.
	     * When setting this property it is clamped to a value between
	     * `0` and `Tiny.settings.TARGET_FPMS * 1000`.
	     *
	     * @member {number}
	     * @default 10
	     */

	  }, {
	    key: 'minFPS',
	    get: function get() {
	      return 1000 / this._maxElapsedMS;
	    },
	    set: function set(fps) {
	      // Clamp: 0 to TARGET_FPMS
	      var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);

	      this._maxElapsedMS = 1 / minFPMS;
	    }
	  }]);

	  return Ticker;
	}();

	exports.default = Ticker;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _GroupD = __webpack_require__(12);

	var _GroupD2 = _interopRequireDefault(_GroupD);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A standard object to store the Uvs of a texture
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */
	var TextureUvs = function () {
	  /**
	   *
	   */
	  function TextureUvs() {
	    _classCallCheck(this, TextureUvs);

	    this.x0 = 0;
	    this.y0 = 0;

	    this.x1 = 1;
	    this.y1 = 0;

	    this.x2 = 1;
	    this.y2 = 1;

	    this.x3 = 0;
	    this.y3 = 1;

	    this.uvsUint32 = new Uint32Array(4);
	  }

	  /**
	   * Sets the texture Uvs based on the given frame information.
	   *
	   * @private
	   * @param {Tiny.Rectangle} frame - The frame of the texture
	   * @param {Tiny.Rectangle} baseFrame - The base frame of the texture
	   * @param {number} rotate - Rotation of frame, see {@link Tiny.GroupD8}
	   */


	  _createClass(TextureUvs, [{
	    key: 'set',
	    value: function set(frame, baseFrame, rotate) {
	      var tw = baseFrame.width;
	      var th = baseFrame.height;

	      if (rotate) {
	        // width and height div 2 div baseFrame size
	        var w2 = frame.width / 2 / tw;
	        var h2 = frame.height / 2 / th;

	        // coordinates of center
	        var cX = frame.x / tw + w2;
	        var cY = frame.y / th + h2;

	        rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner
	        this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
	        this.y0 = cY + h2 * _GroupD2.default.uY(rotate);

	        rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise
	        this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
	        this.y1 = cY + h2 * _GroupD2.default.uY(rotate);

	        rotate = _GroupD2.default.add(rotate, 2);
	        this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
	        this.y2 = cY + h2 * _GroupD2.default.uY(rotate);

	        rotate = _GroupD2.default.add(rotate, 2);
	        this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
	        this.y3 = cY + h2 * _GroupD2.default.uY(rotate);
	      } else {
	        this.x0 = frame.x / tw;
	        this.y0 = frame.y / th;

	        this.x1 = (frame.x + frame.width) / tw;
	        this.y1 = frame.y / th;

	        this.x2 = (frame.x + frame.width) / tw;
	        this.y2 = (frame.y + frame.height) / th;

	        this.x3 = frame.x / tw;
	        this.y3 = (frame.y + frame.height) / th;
	      }

	      this.uvsUint32[0] = (this.y0 * 65535 & 0xFFFF) << 16 | this.x0 * 65535 & 0xFFFF;
	      this.uvsUint32[1] = (this.y1 * 65535 & 0xFFFF) << 16 | this.x1 * 65535 & 0xFFFF;
	      this.uvsUint32[2] = (this.y2 * 65535 & 0xFFFF) << 16 | this.x2 * 65535 & 0xFFFF;
	      this.uvsUint32[3] = (this.y3 * 65535 & 0xFFFF) << 16 | this.x3 * 65535 & 0xFFFF;
	    }
	  }]);

	  return TextureUvs;
	}();

	exports.default = TextureUvs;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @typedef FrameObject
	 * @type {object}
	 * @property {Tiny.Texture} texture - The {@link Tiny.Texture} of the frame
	 * @property {number} time - the duration of the frame in ms
	 */

	/**
	 * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.
	 *
	 * ```js
	 * let alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
	 * let textureArray = [];
	 *
	 * for (let i=0; i < 4; i++)
	 * {
	 *      let texture = Tiny.Texture.fromImage(alienImages[i]);
	 *      textureArray.push(texture);
	 * };
	 *
	 * let mc = new Tiny.AnimatedSprite(textureArray);
	 * ```
	 *
	 * @class
	 * @extends Tiny.Sprite
	 * @memberof Tiny
	 */
	var AnimatedSprite = function (_core$Sprite) {
	  _inherits(AnimatedSprite, _core$Sprite);

	  /**
	   * @param {Tiny.Texture[]|FrameObject[]} textures - an array of {@link Tiny.Texture} or frame
	   *  objects that make up the animation
	   * @param {boolean} [autoUpdate=true] - Whether use Tiny.ticker.shared to auto update animation time.
	   */
	  function AnimatedSprite(textures, autoUpdate) {
	    _classCallCheck(this, AnimatedSprite);

	    /**
	     * @private
	     */
	    var _this = _possibleConstructorReturn(this, (AnimatedSprite.__proto__ || Object.getPrototypeOf(AnimatedSprite)).call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture));

	    _this._textures = null;

	    /**
	     * @private
	     */
	    _this._durations = null;

	    _this.textures = textures;

	    /**
	     * `true` uses Tiny.ticker.shared to auto update animation time.
	     * @type {boolean}
	     * @default true
	     * @private
	     */
	    _this._autoUpdate = autoUpdate !== false;

	    /**
	     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower
	     *
	     * @member {number}
	     * @default 1
	     */
	    _this.animationSpeed = 1;

	    /**
	     * Whether or not the animate sprite repeats after playing.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    _this.loop = true;

	    /**
	     * Function to call when a AnimatedSprite finishes playing
	     *
	     * @member {Function}
	     */
	    _this.onComplete = null;

	    /**
	     * Function to call when a AnimatedSprite changes which texture is being rendered
	     *
	     * @member {Function}
	     */
	    _this.onFrameChange = null;

	    /**
	     * Elapsed time since animation has been started, used internally to display current texture
	     *
	     * @member {number}
	     * @private
	     */
	    _this._currentTime = 0;

	    /**
	     * Indicates if the AnimatedSprite is currently playing
	     *
	     * @member {boolean}
	     * @readonly
	     */
	    _this.playing = false;
	    return _this;
	  }

	  /**
	   * Stops the AnimatedSprite
	   *
	   */


	  _createClass(AnimatedSprite, [{
	    key: 'stop',
	    value: function stop() {
	      if (!this.playing) {
	        return;
	      }

	      this.playing = false;
	      if (this._autoUpdate) {
	        core.ticker.shared.remove(this._update, this);
	      }
	    }

	    /**
	     * Plays the AnimatedSprite
	     *
	     */

	  }, {
	    key: 'play',
	    value: function play() {
	      if (this.playing) {
	        return;
	      }

	      this.playing = true;
	      if (this._autoUpdate) {
	        core.ticker.shared.add(this._update, this);
	      }
	    }

	    /**
	     * Stops the AnimatedSprite and goes to a specific frame
	     *
	     * @param {number} frameNumber - frame index to stop at
	     */

	  }, {
	    key: 'gotoAndStop',
	    value: function gotoAndStop(frameNumber) {
	      this.stop();

	      var previousFrame = this.currentFrame;

	      this._currentTime = frameNumber;

	      if (previousFrame !== this.currentFrame) {
	        this.updateTexture();
	      }
	    }

	    /**
	     * Goes to a specific frame and begins playing the AnimatedSprite
	     *
	     * @param {number} frameNumber - frame index to start at
	     */

	  }, {
	    key: 'gotoAndPlay',
	    value: function gotoAndPlay(frameNumber) {
	      var previousFrame = this.currentFrame;

	      this._currentTime = frameNumber;

	      if (previousFrame !== this.currentFrame) {
	        this.updateTexture();
	      }

	      this.play();
	    }

	    /**
	     * Updates the object transform for rendering.
	     *
	     * @private
	     * @param {number} deltaTime - Time since last tick.
	     */

	  }, {
	    key: '_update',
	    value: function _update(deltaTime) {
	      var elapsed = this.animationSpeed * deltaTime;
	      var previousFrame = this.currentFrame;

	      if (this._durations !== null) {
	        var lag = this._currentTime % 1 * this._durations[this.currentFrame];

	        lag += elapsed / 60 * 1000;

	        while (lag < 0) {
	          this._currentTime--;
	          lag += this._durations[this.currentFrame];
	        }

	        var sign = Math.sign(this.animationSpeed * deltaTime);

	        this._currentTime = Math.floor(this._currentTime);

	        while (lag >= this._durations[this.currentFrame]) {
	          lag -= this._durations[this.currentFrame] * sign;
	          this._currentTime += sign;
	        }

	        this._currentTime += lag / this._durations[this.currentFrame];
	      } else {
	        this._currentTime += elapsed;
	      }
	      if (this._currentTime < 0 && !this.loop) {
	        this.gotoAndStop(0);

	        if (this.onComplete) {
	          this.onComplete();
	        }
	      } else if (this._currentTime >= this._textures.length && !this.loop) {
	        this.gotoAndStop(this._textures.length - 1);

	        if (this.onComplete) {
	          this.onComplete();
	        }
	      } else if (previousFrame !== this.currentFrame) {
	        this.updateTexture();
	      }
	    }

	    /**
	     * Updates the displayed texture to match the current frame index
	     *
	     * @private
	     */

	  }, {
	    key: 'updateTexture',
	    value: function updateTexture() {
	      this._texture = this._textures[this.currentFrame];
	      this._textureID = -1;

	      if (this.onFrameChange) {
	        this.onFrameChange(this.currentFrame);
	      }
	    }

	    /**
	     * Stops the AnimatedSprite and destroys it
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.stop();
	      _get(AnimatedSprite.prototype.__proto__ || Object.getPrototypeOf(AnimatedSprite.prototype), 'destroy', this).call(this);
	    }

	    /**
	     * A short hand way of creating a movieclip from an array of frame ids
	     *
	     * @static
	     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames
	     * @return {AnimatedSprite} The new animated sprite with the specified frames.
	     */

	  }, {
	    key: 'totalFrames',


	    /**
	     * totalFrames is the total number of frames in the AnimatedSprite. This is the same as number of textures
	     * assigned to the AnimatedSprite.
	     *
	     * @readonly
	     * @member {number}
	     * @default 0
	     */
	    get: function get() {
	      return this._textures.length;
	    }

	    /**
	     * The array of textures used for this AnimatedSprite
	     *
	     * @member {Tiny.Texture[]}
	     */

	  }, {
	    key: 'textures',
	    get: function get() {
	      return this._textures;
	    },
	    set: function set(value) {
	      if (value[0] instanceof core.Texture) {
	        this._textures = value;
	        this._durations = null;
	      } else {
	        this._textures = [];
	        this._durations = [];

	        for (var i = 0; i < value.length; i++) {
	          this._textures.push(value[i].texture);
	          this._durations.push(value[i].time);
	        }
	      }
	    }

	    /**
	     * The AnimatedSprites current frame index
	     *
	     * @member {number}
	     * @readonly
	     */

	  }, {
	    key: 'currentFrame',
	    get: function get() {
	      var currentFrame = Math.floor(this._currentTime) % this._textures.length;

	      if (currentFrame < 0) {
	        currentFrame += this._textures.length;
	      }

	      return currentFrame;
	    }
	  }], [{
	    key: 'fromFrames',
	    value: function fromFrames(frames) {
	      var textures = [];

	      for (var i = 0; i < frames.length; ++i) {
	        textures.push(core.Texture.fromFrame(frames[i]));
	      }

	      return new AnimatedSprite(textures);
	    }

	    /**
	     * A short hand way of creating a movieclip from an array of image ids
	     *
	     * @static
	     * @param {string[]} images - the array of image urls the movieclip will use as its texture frames
	     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
	     */

	  }, {
	    key: 'fromImages',
	    value: function fromImages(images) {
	      var textures = [];

	      for (var i = 0; i < images.length; ++i) {
	        textures.push(core.Texture.fromImage(images[i]));
	      }

	      return new AnimatedSprite(textures);
	    }
	  }]);

	  return AnimatedSprite;
	}(core.Sprite);

	exports.default = AnimatedSprite;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CanvasRenderer = __webpack_require__(70);

	var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

	var _const = __webpack_require__(7);

	var _math = __webpack_require__(8);

	var _CanvasTinter = __webpack_require__(78);

	var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var canvasRenderWorldTransform = new _math.Matrix();

	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
	 * share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's CanvasSpriteRenderer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java
	 */

	/**
	 * Renderer dedicated to drawing and batching sprites.
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */

	var CanvasSpriteRenderer = function () {
	  /**
	   * @param {Tiny.WebGLRenderer} renderer -The renderer sprite this batch works for.
	   */
	  function CanvasSpriteRenderer(renderer) {
	    _classCallCheck(this, CanvasSpriteRenderer);

	    this.renderer = renderer;
	  }

	  /**
	   * Renders the sprite object.
	   *
	   * @param {Tiny.Sprite} sprite - the sprite to render when using this spritebatch
	   */


	  _createClass(CanvasSpriteRenderer, [{
	    key: 'render',
	    value: function render(sprite) {
	      var texture = sprite._texture;
	      var renderer = this.renderer;

	      var width = texture._frame.width;
	      var height = texture._frame.height;

	      var wt = sprite.transform.worldTransform;
	      var dx = 0;
	      var dy = 0;

	      if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {
	        return;
	      }

	      renderer.setBlendMode(sprite.blendMode);

	      //  Ignore null sources
	      if (texture.valid) {
	        renderer.context.globalAlpha = sprite.worldAlpha;

	        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
	        var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;

	        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
	          renderer.context[renderer.smoothProperty] = smoothingEnabled;
	        }

	        if (texture.trim) {
	          dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
	          dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
	        } else {
	          dx = (0.5 - sprite.anchor.x) * texture.orig.width;
	          dy = (0.5 - sprite.anchor.y) * texture.orig.height;
	        }

	        if (texture.rotate) {
	          wt.copy(canvasRenderWorldTransform);
	          wt = canvasRenderWorldTransform;
	          _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
	          // the anchor has already been applied above, so lets set it to zero
	          dx = 0;
	          dy = 0;
	        }

	        dx -= width / 2;
	        dy -= height / 2;

	        // Allow for pixel rounding
	        if (renderer.roundPixels) {
	          renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);

	          dx = dx | 0;
	          dy = dy | 0;
	        } else {
	          renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
	        }

	        var resolution = texture.baseTexture.resolution;

	        if (sprite.tint !== 0xFFFFFF) {
	          if (sprite.cachedTint !== sprite.tint) {
	            sprite.cachedTint = sprite.tint;

	            // TODO clean up caching - how to clean up the caches?
	            sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);
	          }

	          renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
	        } else {
	          renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
	        }
	      }
	    }

	    /**
	     * destroy the sprite object.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.renderer = null;
	    }
	  }]);

	  return CanvasSpriteRenderer;
	}();

	exports.default = CanvasSpriteRenderer;


	_CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SystemRenderer2 = __webpack_require__(71);

	var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

	var _CanvasMaskManager = __webpack_require__(74);

	var _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);

	var _CanvasRenderTarget = __webpack_require__(75);

	var _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);

	var _mapCanvasBlendModesToTiny = __webpack_require__(76);

	var _mapCanvasBlendModesToTiny2 = _interopRequireDefault(_mapCanvasBlendModesToTiny);

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should
	 * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to
	 * your DOM or you will not see anything :)
	 *
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.SystemRenderer
	 */
	var CanvasRenderer = function (_SystemRenderer) {
	  _inherits(CanvasRenderer, _SystemRenderer);

	  /**
	   * @param {number} [width=800] - the width of the canvas view
	   * @param {number} [height=600] - the height of the canvas view
	   * @param {object} [options] - The optional renderer parameters
	   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
	   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
	   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
	   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
	   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
	   *  resolution of the renderer retina would be 2.
	   * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
	   *      not before the new render pass.
	   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
	   *  (shown if not transparent).
	   * @param {boolean} [options.roundPixels=false] - If true Tiny will Math.floor() x/y values when rendering,
	   *  stopping pixel interpolation.
	   */
	  function CanvasRenderer(width, height) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    _classCallCheck(this, CanvasRenderer);

	    var _this = _possibleConstructorReturn(this, (CanvasRenderer.__proto__ || Object.getPrototypeOf(CanvasRenderer)).call(this, 'Canvas', width, height, options));

	    _this.type = _const.RENDERER_TYPE.CANVAS;

	    /**
	     * The canvas 2d context that everything is drawn with.
	     *
	     * @member {CanvasRenderingContext2D}
	     */
	    _this.rootContext = _this.view.getContext('2d', { alpha: _this.transparent });

	    /**
	     * Boolean flag controlling canvas refresh.
	     *
	     * @member {boolean}
	     */
	    _this.refresh = true;

	    /**
	     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
	     *
	     * @member {Tiny.CanvasMaskManager}
	     */
	    _this.maskManager = new _CanvasMaskManager2.default(_this);

	    /**
	     * The canvas property used to set the canvas smoothing property.
	     *
	     * @member {string}
	     */
	    _this.smoothProperty = 'imageSmoothingEnabled';

	    if (!_this.rootContext.imageSmoothingEnabled) {
	      if (_this.rootContext.webkitImageSmoothingEnabled) {
	        _this.smoothProperty = 'webkitImageSmoothingEnabled';
	      } else if (_this.rootContext.mozImageSmoothingEnabled) {
	        _this.smoothProperty = 'mozImageSmoothingEnabled';
	      } else if (_this.rootContext.oImageSmoothingEnabled) {
	        _this.smoothProperty = 'oImageSmoothingEnabled';
	      } else if (_this.rootContext.msImageSmoothingEnabled) {
	        _this.smoothProperty = 'msImageSmoothingEnabled';
	      }
	    }

	    _this.initPlugins();

	    _this.blendModes = (0, _mapCanvasBlendModesToTiny2.default)();
	    _this._activeBlendMode = null;

	    _this.context = null;
	    _this.renderingToScreen = false;

	    _this.resize(width, height);
	    return _this;
	  }

	  /**
	   * Renders the object to this canvas view
	   *
	   * @param {Tiny.DisplayObject} displayObject - The object to be rendered
	   * @param {Tiny.RenderTexture} [renderTexture] - A render texture to be rendered to.
	   *  If unset, it will render to the root context.
	   * @param {boolean} [clear=false] - Whether to clear the canvas before drawing
	   * @param {Tiny.Transform} [transform] - A transformation to be applied
	   * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform
	   */


	  _createClass(CanvasRenderer, [{
	    key: 'render',
	    value: function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
	      if (!this.view) {
	        return;
	      }

	      // can be handy to know!
	      this.renderingToScreen = !renderTexture;

	      this.emit('prerender');

	      var rootResolution = this.resolution;

	      if (renderTexture) {
	        renderTexture = renderTexture.baseTexture || renderTexture;

	        if (!renderTexture._canvasRenderTarget) {
	          renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);
	          renderTexture.source = renderTexture._canvasRenderTarget.canvas;
	          renderTexture.valid = true;
	        }

	        this.context = renderTexture._canvasRenderTarget.context;
	        this.resolution = renderTexture._canvasRenderTarget.resolution;
	      } else {
	        this.context = this.rootContext;
	      }

	      var context = this.context;

	      if (!renderTexture) {
	        this._lastObjectRendered = displayObject;
	      }

	      if (!skipUpdateTransform) {
	        // update the scene graph
	        var cacheParent = displayObject.parent;
	        var tempWt = this._tempDisplayObjectParent.transform.worldTransform;

	        if (transform) {
	          transform.copy(tempWt);
	        } else {
	          tempWt.identity();
	        }

	        displayObject.parent = this._tempDisplayObjectParent;
	        displayObject.updateTransform();
	        displayObject.parent = cacheParent;
	        // displayObject.hitArea = //TODO add a temp hit area
	      }

	      context.setTransform(1, 0, 0, 1, 0, 0);
	      context.globalAlpha = 1;
	      context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];

	      if (navigator.isCocoonJS && this.view.screencanvas) {
	        context.fillStyle = 'black';
	        context.clear();
	      }

	      if (clear !== undefined ? clear : this.clearBeforeRender) {
	        if (this.renderingToScreen) {
	          if (this.transparent) {
	            context.clearRect(0, 0, this.width, this.height);
	          } else {
	            context.fillStyle = this._backgroundColorString;
	            context.fillRect(0, 0, this.width, this.height);
	          }
	        } // else {
	        // TODO: implement background for CanvasRenderTarget or RenderTexture?
	        // }
	      }

	      // TODO RENDER TARGET STUFF HERE..
	      var tempContext = this.context;

	      this.context = context;
	      displayObject.renderCanvas(this);
	      this.context = tempContext;

	      this.resolution = rootResolution;

	      this.emit('postrender');
	    }

	    /**
	     * Clear the canvas of renderer.
	     *
	     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.
	     */

	  }, {
	    key: 'clear',
	    value: function clear(clearColor) {
	      var context = this.context;

	      clearColor = clearColor || this._backgroundColorString;

	      if (!this.transparent && clearColor) {
	        context.fillStyle = clearColor;
	        context.fillRect(0, 0, this.width, this.height);
	      } else {
	        context.clearRect(0, 0, this.width, this.height);
	      }
	    }

	    /**
	     * Sets the blend mode of the renderer.
	     *
	     * @param {number} blendMode - See {@link Tiny.BLEND_MODES} for valid values.
	     */

	  }, {
	    key: 'setBlendMode',
	    value: function setBlendMode(blendMode) {
	      if (this._activeBlendMode === blendMode) {
	        return;
	      }

	      this._activeBlendMode = blendMode;
	      this.context.globalCompositeOperation = this.blendModes[blendMode];
	    }

	    /**
	     * Removes everything from the renderer and optionally removes the Canvas DOM element.
	     *
	     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(removeView) {
	      this.destroyPlugins();

	      // call the base destroy
	      _get(CanvasRenderer.prototype.__proto__ || Object.getPrototypeOf(CanvasRenderer.prototype), 'destroy', this).call(this, removeView);

	      this.context = null;

	      this.refresh = true;

	      this.maskManager.destroy();
	      this.maskManager = null;

	      this.smoothProperty = null;
	    }

	    /**
	     * Resizes the canvas view to the specified width and height.
	     *
	     * @extends Tiny.SystemRenderer#resize
	     *
	     * @param {number} width - The new width of the canvas view
	     * @param {number} height - The new height of the canvas view
	     */

	  }, {
	    key: 'resize',
	    value: function resize(width, height) {
	      _get(CanvasRenderer.prototype.__proto__ || Object.getPrototypeOf(CanvasRenderer.prototype), 'resize', this).call(this, width, height);

	      // reset the scale mode.. oddly this seems to be reset when the canvas is resized.
	      // surely a browser bug?? Let Tiny fix that for you..
	      if (this.smoothProperty) {
	        this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;
	      }
	    }
	  }]);

	  return CanvasRenderer;
	}(_SystemRenderer3.default);

	exports.default = CanvasRenderer;


	_utils.pluginTarget.mixin(CanvasRenderer);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(18);

	var _math = __webpack_require__(8);

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _Container = __webpack_require__(50);

	var _Container2 = _interopRequireDefault(_Container);

	var _RenderTexture = __webpack_require__(72);

	var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var tempMatrix = new _math.Matrix();

	/**
	 * The SystemRenderer is the base for a Tiny Renderer. It is extended by the {@link Tiny.CanvasRenderer}
	 * and {@link Tiny.WebGLRenderer} which can be used for rendering a Tiny scene.
	 *
	 * @abstract
	 * @class
	 * @extends EventEmitter
	 * @memberof Tiny
	 */

	var SystemRenderer = function (_EventEmitter) {
	  _inherits(SystemRenderer, _EventEmitter);

	  /**
	   * @param {string} system - The name of the system this renderer is for.
	   * @param {number} [width=800] - the width of the canvas view
	   * @param {number} [height=600] - the height of the canvas view
	   * @param {object} [options] - The optional renderer parameters
	   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
	   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
	   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
	   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
	   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
	   *  resolution of the renderer retina would be 2.
	   * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
	   *      not before the new render pass.
	   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
	   *  (shown if not transparent).
	   * @param {boolean} [options.roundPixels=false] - If true Tiny will Math.floor() x/y values when rendering,
	   *  stopping pixel interpolation.
	   */
	  function SystemRenderer(system, width, height, options) {
	    _classCallCheck(this, SystemRenderer);

	    // prepare options
	    var _this = _possibleConstructorReturn(this, (SystemRenderer.__proto__ || Object.getPrototypeOf(SystemRenderer)).call(this));

	    if (options) {
	      for (var i in _settings2.default.RENDER_OPTIONS) {
	        if (typeof options[i] === 'undefined') {
	          options[i] = _settings2.default.RENDER_OPTIONS[i];
	        }
	      }
	    } else {
	      options = _settings2.default.RENDER_OPTIONS;
	    }
	    console.log(options);

	    /**
	     * The type of the renderer.
	     *
	     * @member {number}
	     * @default Tiny.RENDERER_TYPE.UNKNOWN
	     * @see Tiny.RENDERER_TYPE
	     */
	    _this.type = _const.RENDERER_TYPE.UNKNOWN;

	    /**
	     * The width of the canvas view
	     *
	     * @member {number}
	     * @default 800
	     */
	    _this.width = width || 800;

	    /**
	     * The height of the canvas view
	     *
	     * @member {number}
	     * @default 600
	     */
	    _this.height = height || 600;

	    /**
	     * The canvas element that everything is drawn to
	     *
	     * @member {HTMLCanvasElement}
	     */
	    _this.view = options.view;

	    /**
	     * The resolution / device pixel ratio of the renderer
	     *
	     * @member {number}
	     * @default 1
	     */
	    _this.resolution = options.resolution || _settings2.default.RESOLUTION;

	    /**
	     * Whether the render view is transparent
	     *
	     * @member {boolean}
	     */
	    _this.transparent = options.transparent;

	    /**
	     * Whether the render view should be resized automatically
	     *
	     * @member {boolean}
	     */
	    _this.autoResize = options.autoResize || false;

	    /**
	     * Tracks the blend modes useful for this renderer.
	     *
	     * @member {object<string, mixed>}
	     */
	    _this.blendModes = null;

	    /**
	     * The value of the preserveDrawingBuffer flag affects whether or not the contents of
	     * the stencil buffer is retained after rendering.
	     *
	     * @member {boolean}
	     */
	    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;

	    /**
	     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
	     * If the scene is NOT transparent Tiny will use a canvas sized fillRect operation every
	     * frame to set the canvas background color. If the scene is transparent Tiny will use clearRect
	     * to clear the canvas every frame. Disable this by setting this to false. For example if
	     * your game has a canvas filling background image you often don't need this set.
	     *
	     * @member {boolean}
	     * @default
	     */
	    _this.clearBeforeRender = options.clearBeforeRender;

	    /**
	     * If true Tiny will Math.floor() x/y values when rendering, stopping pixel interpolation.
	     * Handy for crisp pixel art and speed on legacy devices.
	     *
	     * @member {boolean}
	     */
	    _this.roundPixels = options.roundPixels;

	    /**
	     * The background color as a number.
	     *
	     * @member {number}
	     * @private
	     */
	    _this._backgroundColor = 0x000000;

	    /**
	     * The background color as an [R, G, B] array.
	     *
	     * @member {number[]}
	     * @private
	     */
	    _this._backgroundColorRgba = [0, 0, 0, 0];

	    /**
	     * The background color as a string.
	     *
	     * @member {string}
	     * @private
	     */
	    _this._backgroundColorString = '#000000';

	    _this.backgroundColor = options.backgroundColor || _this._backgroundColor; // run bg color setter

	    /**
	     * This temporary display object used as the parent of the currently being rendered item
	     *
	     * @member {Tiny.DisplayObject}
	     * @private
	     */
	    _this._tempDisplayObjectParent = new _Container2.default();

	    /**
	     * The last root object that the renderer tried to render.
	     *
	     * @member {Tiny.DisplayObject}
	     * @private
	     */
	    _this._lastObjectRendered = _this._tempDisplayObjectParent;
	    return _this;
	  }

	  /**
	   * Resizes the canvas view to the specified width and height
	   *
	   * @param {number} width - the new width of the canvas view
	   * @param {number} height - the new height of the canvas view
	   */


	  _createClass(SystemRenderer, [{
	    key: 'resize',
	    value: function resize(width, height) {
	      this.width = width * this.resolution;
	      this.height = height * this.resolution;

	      this.view.width = this.width;
	      this.view.height = this.height;

	      if (this.autoResize) {
	        this.view.style.width = this.width / this.resolution + 'px';
	        this.view.style.height = this.height / this.resolution + 'px';
	      }
	    }

	    /**
	     * Useful function that returns a texture of the display object that can then be used to create sprites
	     * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
	     *
	     * @param {Tiny.DisplayObject} displayObject - The displayObject the object will be generated from
	     * @param {number} scaleMode - Should be one of the scaleMode consts
	     * @param {number} resolution - The resolution / device pixel ratio of the texture being generated
	     * @return {Tiny.Texture} a texture of the graphics object
	     */

	  }, {
	    key: 'generateTexture',
	    value: function generateTexture(displayObject, scaleMode, resolution) {
	      var bounds = displayObject.getLocalBounds();

	      var renderTexture = _RenderTexture2.default.create(bounds.width | 0, bounds.height | 0, scaleMode, resolution);

	      tempMatrix.tx = -bounds.x;
	      tempMatrix.ty = -bounds.y;

	      this.render(displayObject, renderTexture, false, tempMatrix, true);

	      return renderTexture;
	    }

	    /**
	     * Removes everything from the renderer and optionally removes the Canvas DOM element.
	     *
	     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(removeView) {
	      if (removeView && this.view.parentNode) {
	        this.view.parentNode.removeChild(this.view);
	      }

	      this.type = _const.RENDERER_TYPE.UNKNOWN;

	      this.width = 0;
	      this.height = 0;

	      this.view = null;

	      this.resolution = 0;

	      this.transparent = false;

	      this.autoResize = false;

	      this.blendModes = null;

	      this.preserveDrawingBuffer = false;
	      this.clearBeforeRender = false;

	      this.roundPixels = false;

	      this._backgroundColor = 0;
	      this._backgroundColorRgba = null;
	      this._backgroundColorString = null;

	      this.backgroundColor = 0;
	      this._tempDisplayObjectParent = null;
	      this._lastObjectRendered = null;
	    }

	    /**
	     * The background color to fill if not transparent
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'backgroundColor',
	    get: function get() {
	      return this._backgroundColor;
	    },
	    set: function set(value) {
	      this._backgroundColor = value;
	      this._backgroundColorString = (0, _utils.hex2string)(value);
	      (0, _utils.hex2rgb)(value, this._backgroundColorRgba);
	    }
	  }]);

	  return SystemRenderer;
	}(_eventemitter2.default);

	exports.default = SystemRenderer;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _BaseRenderTexture = __webpack_require__(73);

	var _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);

	var _Texture2 = __webpack_require__(52);

	var _Texture3 = _interopRequireDefault(_Texture2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
	 *
	 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
	 * otherwise black rectangles will be drawn instead.
	 *
	 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
	 *
	 * ```js
	 * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
	 * let renderTexture = PIXI.RenderTexture.create(800, 600);
	 * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
	 *
	 * sprite.position.x = 800/2;
	 * sprite.position.y = 600/2;
	 * sprite.anchor.x = 0.5;
	 * sprite.anchor.y = 0.5;
	 *
	 * renderer.render(sprite, renderTexture);
	 * ```
	 *
	 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
	 * you can clear the transform
	 *
	 * ```js
	 *
	 * sprite.setTransform()
	 *
	 * let renderTexture = new Tiny.RenderTexture.create(100, 100);
	 *
	 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
	 * ```
	 *
	 * @class
	 * @extends Tiny.Texture
	 * @memberof Tiny
	 */
	var RenderTexture = function (_Texture) {
	  _inherits(RenderTexture, _Texture);

	  /**
	   * @param {Tiny.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture
	   * @param {Tiny.Rectangle} [frame] - The rectangle frame of the texture to show
	   */
	  function RenderTexture(baseRenderTexture, frame) {
	    _classCallCheck(this, RenderTexture);

	    // support for legacy..
	    var _legacyRenderer = null;

	    if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {
	      /* eslint-disable prefer-rest-params, no-console */
	      var width = arguments[1];
	      var height = arguments[2];
	      var scaleMode = arguments[3] || 0;
	      var resolution = arguments[4] || 1;

	      // we have an old render texture..
	      console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');
	      _legacyRenderer = arguments[0];
	      /* eslint-enable prefer-rest-params, no-console */

	      frame = null;
	      baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);
	    }

	    /**
	     * The base texture object that this texture uses
	     *
	     * @member {BaseTexture}
	     */

	    var _this = _possibleConstructorReturn(this, (RenderTexture.__proto__ || Object.getPrototypeOf(RenderTexture)).call(this, baseRenderTexture, frame));

	    _this.legacyRenderer = _legacyRenderer;

	    /**
	     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	     *
	     * @member {boolean}
	     */
	    _this.valid = true;

	    _this._updateUvs();
	    return _this;
	  }

	  /**
	   * Resizes the RenderTexture.
	   *
	   * @param {number} width - The width to resize to.
	   * @param {number} height - The height to resize to.
	   * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?
	   */


	  _createClass(RenderTexture, [{
	    key: 'resize',
	    value: function resize(width, height, doNotResizeBaseTexture) {
	      // TODO - could be not required..
	      this.valid = width > 0 && height > 0;

	      this._frame.width = this.orig.width = width;
	      this._frame.height = this.orig.height = height;

	      if (!doNotResizeBaseTexture) {
	        this.baseTexture.resize(width, height);
	      }

	      this._updateUvs();
	    }

	    /**
	     * A short hand way of creating a render texture.
	     *
	     * @param {number} [width=100] - The width of the render texture
	     * @param {number} [height=100] - The height of the render texture
	     * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
	     * @return {Tiny.RenderTexture} The new render texture
	     */

	  }], [{
	    key: 'create',
	    value: function create(width, height, scaleMode, resolution) {
	      return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));
	    }
	  }]);

	  return RenderTexture;
	}(_Texture3.default);

	exports.default = RenderTexture;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _BaseTexture2 = __webpack_require__(53);

	var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RESOLUTION = _settings2.default.RESOLUTION,
	    SCALE_MODE = _settings2.default.SCALE_MODE;

	/**
	 * A BaseRenderTexture is a special texture that allows any Pixi display object to be rendered to it.
	 *
	 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
	 * otherwise black rectangles will be drawn instead.
	 *
	 * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
	 * and rotation of the given Display Objects is ignored. For example:
	 *
	 * ```js
	 * let renderer = Tiny.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
	 * let baseRenderTexture = new Tiny.BaseRenderTexture(renderer, 800, 600);
	 * let sprite = Tiny.Sprite.fromImage("spinObj_01.png");
	 *
	 * sprite.position.x = 800/2;
	 * sprite.position.y = 600/2;
	 * sprite.anchor.x = 0.5;
	 * sprite.anchor.y = 0.5;
	 *
	 * baseRenderTexture.render(sprite);
	 * ```
	 *
	 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
	 * you can clear the transform
	 *
	 * ```js
	 *
	 * sprite.setTransform()
	 *
	 * let baseRenderTexture = new Tiny.BaseRenderTexture(100, 100);
	 * let renderTexture = new Tiny.RenderTexture(baseRenderTexture);
	 *
	 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
	 * ```
	 *
	 * @class
	 * @extends Tiny.BaseTexture
	 * @memberof Tiny
	 */

	var BaseRenderTexture = function (_BaseTexture) {
	  _inherits(BaseRenderTexture, _BaseTexture);

	  /**
	   * @param {number} [width=100] - The width of the base render texture
	   * @param {number} [height=100] - The height of the base render texture
	   * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
	   */
	  function BaseRenderTexture() {
	    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
	    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
	    var scaleMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var resolution = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

	    _classCallCheck(this, BaseRenderTexture);

	    var _this = _possibleConstructorReturn(this, (BaseRenderTexture.__proto__ || Object.getPrototypeOf(BaseRenderTexture)).call(this, null, scaleMode));

	    _this.resolution = resolution || RESOLUTION;

	    _this.width = width;
	    _this.height = height;

	    _this.realWidth = _this.width * _this.resolution;
	    _this.realHeight = _this.height * _this.resolution;

	    _this.scaleMode = scaleMode || SCALE_MODE;
	    _this.hasLoaded = true;

	    /**
	     * A map of renderer IDs to webgl renderTargets
	     *
	     * @private
	     * @member {object<number, WebGLTexture>}
	     */
	    _this._glRenderTargets = {};

	    /**
	     * A reference to the canvas render target (we only need one as this can be shared across renderers)
	     *
	     * @private
	     * @member {object<number, WebGLTexture>}
	     */
	    _this._canvasRenderTarget = null;

	    /**
	     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	     *
	     * @member {boolean}
	     */
	    _this.valid = false;
	    return _this;
	  }

	  /**
	   * Resizes the BaseRenderTexture.
	   *
	   * @param {number} width - The width to resize to.
	   * @param {number} height - The height to resize to.
	   */


	  _createClass(BaseRenderTexture, [{
	    key: 'resize',
	    value: function resize(width, height) {
	      if (width === this.width && height === this.height) {
	        return;
	      }

	      this.valid = width > 0 && height > 0;

	      this.width = width;
	      this.height = height;

	      this.realWidth = this.width * this.resolution;
	      this.realHeight = this.height * this.resolution;

	      if (!this.valid) {
	        return;
	      }

	      this.emit('update', this);
	    }

	    /**
	     * Destroys this texture
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      _get(BaseRenderTexture.prototype.__proto__ || Object.getPrototypeOf(BaseRenderTexture.prototype), 'destroy', this).call(this, true);
	      this.renderer = null;
	    }
	  }]);

	  return BaseRenderTexture;
	}(_BaseTexture3.default);

	exports.default = BaseRenderTexture;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _const = __webpack_require__(7);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A set of functions used to handle masking.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var CanvasMaskManager = function () {
	  /**
	   * @param {Tiny.CanvasRenderer} renderer - The canvas renderer.
	   */
	  function CanvasMaskManager(renderer) {
	    _classCallCheck(this, CanvasMaskManager);

	    this.renderer = renderer;
	  }

	  /**
	   * This method adds it to the current stack of masks.
	   *
	   * @param {object} maskData - the maskData that will be pushed
	   */


	  _createClass(CanvasMaskManager, [{
	    key: 'pushMask',
	    value: function pushMask(maskData) {
	      var renderer = this.renderer;

	      renderer.context.save();

	      var cacheAlpha = maskData.alpha;
	      var transform = maskData.transform.worldTransform;
	      var resolution = renderer.resolution;

	      renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

	      // TODO suport sprite alpha masks??
	      // lots of effort required. If demand is great enough..
	      if (!maskData._texture) {
	        this.renderGraphicsShape(maskData);
	        renderer.context.clip();
	      }

	      maskData.worldAlpha = cacheAlpha;
	    }

	    /**
	     * Renders a Tiny.Graphics shape.
	     *
	     * @param {Tiny.Graphics} graphics - The object to render.
	     */

	  }, {
	    key: 'renderGraphicsShape',
	    value: function renderGraphicsShape(graphics) {
	      var context = this.renderer.context;
	      var len = graphics.graphicsData.length;

	      if (len === 0) {
	        return;
	      }

	      context.beginPath();

	      for (var i = 0; i < len; i++) {
	        var data = graphics.graphicsData[i];
	        var shape = data.shape;

	        if (data.type === _const.SHAPES.POLY) {
	          var points = shape.points;

	          context.moveTo(points[0], points[1]);

	          for (var j = 1; j < points.length / 2; j++) {
	            context.lineTo(points[j * 2], points[j * 2 + 1]);
	          }

	          // if the first and last point are the same close the path - much neater :)
	          if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
	            context.closePath();
	          }
	        } else if (data.type === _const.SHAPES.RECT) {
	          context.rect(shape.x, shape.y, shape.width, shape.height);
	          context.closePath();
	        } else if (data.type === _const.SHAPES.CIRC) {
	          // TODO - need to be Undefined!
	          context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
	          context.closePath();
	        } else if (data.type === _const.SHAPES.ELIP) {
	          // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

	          var w = shape.width * 2;
	          var h = shape.height * 2;

	          var x = shape.x - w / 2;
	          var y = shape.y - h / 2;

	          var kappa = 0.5522848;
	          var ox = w / 2 * kappa; // control point offset horizontal
	          var oy = h / 2 * kappa; // control point offset vertical
	          var xe = x + w; // x-end
	          var ye = y + h; // y-end
	          var xm = x + w / 2; // x-middle
	          var ym = y + h / 2; // y-middle

	          context.moveTo(x, ym);
	          context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
	          context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
	          context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
	          context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
	          context.closePath();
	        } else if (data.type === _const.SHAPES.RREC) {
	          var rx = shape.x;
	          var ry = shape.y;
	          var width = shape.width;
	          var height = shape.height;
	          var radius = shape.radius;

	          var maxRadius = Math.min(width, height) / 2 | 0;

	          radius = radius > maxRadius ? maxRadius : radius;

	          context.moveTo(rx, ry + radius);
	          context.lineTo(rx, ry + height - radius);
	          context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
	          context.lineTo(rx + width - radius, ry + height);
	          context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
	          context.lineTo(rx + width, ry + radius);
	          context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
	          context.lineTo(rx + radius, ry);
	          context.quadraticCurveTo(rx, ry, rx, ry + radius);
	          context.closePath();
	        }
	      }
	    }

	    /**
	     * Restores the current drawing context to the state it was before the mask was applied.
	     *
	     * @param {Tiny.CanvasRenderer} renderer - The renderer context to use.
	     */

	  }, {
	    key: 'popMask',
	    value: function popMask(renderer) {
	      renderer.context.restore();
	    }

	    /**
	     * Destroys this canvas mask manager.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      /* empty */
	    }
	  }]);

	  return CanvasMaskManager;
	}();

	exports.default = CanvasMaskManager;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var RESOLUTION = _settings2.default.RESOLUTION;

	/**
	 * Creates a Canvas element of the given size.
	 *
	 * @class
	 * @memberof Tiny
	 */

	var CanvasRenderTarget = function () {
	  /**
	   * @param {number} width - the width for the newly created canvas
	   * @param {number} height - the height for the newly created canvas
	   * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
	   */
	  function CanvasRenderTarget(width, height, resolution) {
	    _classCallCheck(this, CanvasRenderTarget);

	    /**
	     * The Canvas object that belongs to this CanvasRenderTarget.
	     *
	     * @member {HTMLCanvasElement}
	     */
	    this.canvas = document.createElement('canvas');

	    /**
	     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
	     *
	     * @member {CanvasRenderingContext2D}
	     */
	    this.context = this.canvas.getContext('2d');

	    this.resolution = resolution || RESOLUTION;

	    this.resize(width, height);
	  }

	  /**
	   * Clears the canvas that was created by the CanvasRenderTarget class.
	   *
	   * @private
	   */


	  _createClass(CanvasRenderTarget, [{
	    key: 'clear',
	    value: function clear() {
	      this.context.setTransform(1, 0, 0, 1, 0, 0);
	      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	    }

	    /**
	     * Resizes the canvas to the specified width and height.
	     *
	     * @param {number} width - the new width of the canvas
	     * @param {number} height - the new height of the canvas
	     */

	  }, {
	    key: 'resize',
	    value: function resize(width, height) {
	      this.canvas.width = width * this.resolution;
	      this.canvas.height = height * this.resolution;
	    }

	    /**
	     * Destroys this canvas.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.context = null;
	      this.canvas = null;
	    }

	    /**
	     * The width of the canvas buffer in pixels.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      return this.canvas.width;
	    },
	    set: function set(val) {
	      this.canvas.width = val;
	    }

	    /**
	     * The height of the canvas buffer in pixels.
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      return this.canvas.height;
	    },
	    set: function set(val) {
	      this.canvas.height = val;
	    }
	  }]);

	  return CanvasRenderTarget;
	}();

	exports.default = CanvasRenderTarget;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = mapCanvasBlendModesToTiny;

	var _const = __webpack_require__(7);

	var _canUseNewCanvasBlendModes = __webpack_require__(77);

	var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Maps blend combinations to Canvas.
	 *
	 * @memberof Tiny
	 * @function mapCanvasBlendModesToTiny
	 * @private
	 * @param {string[]} [array=[]] - The array to output into.
	 * @return {string[]} Mapped modes.
	 */
	function mapCanvasBlendModesToTiny() {
	  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

	  if ((0, _canUseNewCanvasBlendModes2.default)()) {
	    array[_const.BLEND_MODES.NORMAL] = 'source-over';
	    array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
	    array[_const.BLEND_MODES.MULTIPLY] = 'multiply';
	    array[_const.BLEND_MODES.SCREEN] = 'screen';
	    array[_const.BLEND_MODES.OVERLAY] = 'overlay';
	    array[_const.BLEND_MODES.DARKEN] = 'darken';
	    array[_const.BLEND_MODES.LIGHTEN] = 'lighten';
	    array[_const.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
	    array[_const.BLEND_MODES.COLOR_BURN] = 'color-burn';
	    array[_const.BLEND_MODES.HARD_LIGHT] = 'hard-light';
	    array[_const.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
	    array[_const.BLEND_MODES.DIFFERENCE] = 'difference';
	    array[_const.BLEND_MODES.EXCLUSION] = 'exclusion';
	    array[_const.BLEND_MODES.HUE] = 'hue';
	    array[_const.BLEND_MODES.SATURATION] = 'saturate';
	    array[_const.BLEND_MODES.COLOR] = 'color';
	    array[_const.BLEND_MODES.LUMINOSITY] = 'luminosity';
	  } else {
	    // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
	    array[_const.BLEND_MODES.NORMAL] = 'source-over';
	    array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
	    array[_const.BLEND_MODES.MULTIPLY] = 'source-over';
	    array[_const.BLEND_MODES.SCREEN] = 'source-over';
	    array[_const.BLEND_MODES.OVERLAY] = 'source-over';
	    array[_const.BLEND_MODES.DARKEN] = 'source-over';
	    array[_const.BLEND_MODES.LIGHTEN] = 'source-over';
	    array[_const.BLEND_MODES.COLOR_DODGE] = 'source-over';
	    array[_const.BLEND_MODES.COLOR_BURN] = 'source-over';
	    array[_const.BLEND_MODES.HARD_LIGHT] = 'source-over';
	    array[_const.BLEND_MODES.SOFT_LIGHT] = 'source-over';
	    array[_const.BLEND_MODES.DIFFERENCE] = 'source-over';
	    array[_const.BLEND_MODES.EXCLUSION] = 'source-over';
	    array[_const.BLEND_MODES.HUE] = 'source-over';
	    array[_const.BLEND_MODES.SATURATION] = 'source-over';
	    array[_const.BLEND_MODES.COLOR] = 'source-over';
	    array[_const.BLEND_MODES.LUMINOSITY] = 'source-over';
	  }

	  return array;
	}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = canUseNewCanvasBlendModes;
	/**
	 * Creates a little colored canvas
	 *
	 * @ignore
	 * @param {string} color - The color to make the canvas
	 * @return {canvas} a small canvas element
	 */
	function createColoredCanvas(color) {
	  var canvas = document.createElement('canvas');

	  canvas.width = 6;
	  canvas.height = 1;

	  var context = canvas.getContext('2d');

	  context.fillStyle = color;
	  context.fillRect(0, 0, 6, 1);

	  return canvas;
	}

	/**
	 * Checks whether the Canvas BlendModes are supported by the current browser
	 *
	 * @return {boolean} whether they are supported
	 */
	function canUseNewCanvasBlendModes() {
	  if (typeof document === 'undefined') {
	    return false;
	  }

	  var magenta = createColoredCanvas('#ff00ff');
	  var yellow = createColoredCanvas('#ffff00');

	  var canvas = document.createElement('canvas');

	  canvas.width = 6;
	  canvas.height = 1;

	  var context = canvas.getContext('2d');

	  context.globalCompositeOperation = 'multiply';
	  context.drawImage(magenta, 0, 0);
	  context.drawImage(yellow, 2, 0);

	  var imageData = context.getImageData(2, 0, 1, 1);

	  if (!imageData) {
	    return false;
	  }

	  var data = imageData.data;

	  return data[0] === 255 && data[1] === 0 && data[2] === 0;
	}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _utils = __webpack_require__(18);

	var _canUseNewCanvasBlendModes = __webpack_require__(77);

	var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Utility methods for Sprite/Texture tinting.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var CanvasTinter = {
	  /**
	   * Basically this method just needs a sprite and a color and tints the sprite with the given color.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @param {Tiny.Sprite} sprite - the sprite to tint
	   * @param {number} color - the color to use to tint the sprite with
	   * @return {HTMLCanvasElement} The tinted canvas
	   */
	  getTintedTexture: function getTintedTexture(sprite, color) {
	    var texture = sprite.texture;

	    color = CanvasTinter.roundColor(color);

	    var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

	    texture.tintCache = texture.tintCache || {};

	    if (texture.tintCache[stringColor]) {
	      return texture.tintCache[stringColor];
	    }

	    // clone texture..
	    var canvas = CanvasTinter.canvas || document.createElement('canvas');

	    // CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
	    CanvasTinter.tintMethod(texture, color, canvas);

	    if (CanvasTinter.convertTintToImage) {
	      // is this better?
	      var tintImage = new Image();

	      tintImage.src = canvas.toDataURL();

	      texture.tintCache[stringColor] = tintImage;
	    } else {
	      texture.tintCache[stringColor] = canvas;
	      // if we are not converting the texture to an image then we need to lose the reference to the canvas
	      CanvasTinter.canvas = null;
	    }

	    return canvas;
	  },

	  /**
	   * Tint a texture using the 'multiply' operation.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @param {Tiny.Texture} texture - the texture to tint
	   * @param {number} color - the color to use to tint the sprite with
	   * @param {HTMLCanvasElement} canvas - the current canvas
	   */
	  tintWithMultiply: function tintWithMultiply(texture, color, canvas) {
	    var context = canvas.getContext('2d');
	    var crop = texture._frame.clone();
	    var resolution = texture.baseTexture.resolution;

	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;

	    canvas.width = crop.width;
	    canvas.height = crop.height;

	    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);

	    context.fillRect(0, 0, crop.width, crop.height);

	    context.globalCompositeOperation = 'multiply';

	    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

	    context.globalCompositeOperation = 'destination-atop';

	    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
	  },

	  /**
	   * Tint a texture using the 'overlay' operation.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @param {Tiny.Texture} texture - the texture to tint
	   * @param {number} color - the color to use to tint the sprite with
	   * @param {HTMLCanvasElement} canvas - the current canvas
	   */
	  tintWithOverlay: function tintWithOverlay(texture, color, canvas) {
	    var context = canvas.getContext('2d');
	    var crop = texture._frame.clone();
	    var resolution = texture.baseTexture.resolution;

	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;

	    canvas.width = crop.width;
	    canvas.height = crop.height;

	    context.globalCompositeOperation = 'copy';
	    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
	    context.fillRect(0, 0, crop.width, crop.height);

	    context.globalCompositeOperation = 'destination-atop';
	    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

	    // context.globalCompositeOperation = 'copy';
	  },

	  /**
	   * Tint a texture pixel per pixel.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @param {Tiny.Texture} texture - the texture to tint
	   * @param {number} color - the color to use to tint the sprite with
	   * @param {HTMLCanvasElement} canvas - the current canvas
	   */
	  tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
	    var context = canvas.getContext('2d');
	    var crop = texture._frame.clone();
	    var resolution = texture.baseTexture.resolution;

	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;

	    canvas.width = crop.width;
	    canvas.height = crop.height;

	    context.globalCompositeOperation = 'copy';
	    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

	    var rgbValues = (0, _utils.hex2rgb)(color);
	    var r = rgbValues[0];
	    var g = rgbValues[1];
	    var b = rgbValues[2];

	    var pixelData = context.getImageData(0, 0, crop.width, crop.height);

	    var pixels = pixelData.data;

	    for (var i = 0; i < pixels.length; i += 4) {
	      pixels[i + 0] *= r;
	      pixels[i + 1] *= g;
	      pixels[i + 2] *= b;
	    }

	    context.putImageData(pixelData, 0, 0);
	  },

	  /**
	   * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @param {number} color - the color to round, should be a hex color
	   * @return {number} The rounded color.
	   */
	  roundColor: function roundColor(color) {
	    var step = CanvasTinter.cacheStepsPerColorChannel;

	    var rgbValues = (0, _utils.hex2rgb)(color);

	    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
	    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
	    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);

	    return (0, _utils.rgb2hex)(rgbValues);
	  },

	  /**
	   * Number of steps which will be used as a cap when rounding colors.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @type {number}
	   */
	  cacheStepsPerColorChannel: 8,

	  /**
	   * Tint cache boolean flag.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @type {boolean}
	   */
	  convertTintToImage: false,

	  /**
	   * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @type {boolean}
	   */
	  canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),

	  /**
	   * The tinting method that will be used.
	   *
	   * @memberof Tiny.CanvasTinter
	   * @type {tintMethodFunctionType}
	   */
	  tintMethod: 0
	};

	CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;

	/**
	 * The tintMethod type.
	 *
	 * @memberof Tiny.CanvasTinter
	 * @callback tintMethodFunctionType
	 * @param texture {Tiny.Texture} the texture to tint
	 * @param color {number} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas
	 */

	exports.default = CanvasTinter;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _ObjectRenderer2 = __webpack_require__(80);

	var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

	var _WebGLRenderer = __webpack_require__(82);

	var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

	var _createIndicesForQuads = __webpack_require__(92);

	var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

	var _generateMultiTextureShader = __webpack_require__(101);

	var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);

	var _checkMaxIfStatmentsInShader = __webpack_require__(102);

	var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);

	var _BatchBuffer = __webpack_require__(103);

	var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	var _bitTwiddle = __webpack_require__(63);

	var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TICK = 0;
	var TEXTURE_TICK = 0;

	/**
	 * Renderer dedicated to drawing and batching sprites.
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 * @extends Tiny.ObjectRenderer
	 */

	var SpriteRenderer = function (_ObjectRenderer) {
	  _inherits(SpriteRenderer, _ObjectRenderer);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this sprite batch works for.
	   */
	  function SpriteRenderer(renderer) {
	    _classCallCheck(this, SpriteRenderer);

	    /**
	     * Number of values sent in the vertex buffer.
	     * positionX, positionY, colorR, colorG, colorB = 5
	     *
	     * @member {number}
	     */
	    var _this = _possibleConstructorReturn(this, (SpriteRenderer.__proto__ || Object.getPrototypeOf(SpriteRenderer)).call(this, renderer));

	    _this.vertSize = 5;

	    /**
	     * The size of the vertex information in bytes.
	     *
	     * @member {number}
	     */
	    _this.vertByteSize = _this.vertSize * 4;

	    /**
	     * The number of images in the SpriteRenderer before it flushes.
	     *
	     * @member {number}
	     */
	    _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

	    // the total number of bytes in our batch
	    // let numVerts = this.size * 4 * this.vertByteSize;

	    _this.buffers = [];
	    for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {
	      _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));
	    }

	    /**
	     * Holds the indices of the geometry (quads) to draw
	     *
	     * @member {Uint16Array}
	     */
	    _this.indices = (0, _createIndicesForQuads2.default)(_this.size);

	    /**
	     * The default shaders that is used if a sprite doesn't have a more specific one.
	     * there is a shader for each number of textures that can be rendererd.
	     * These shaders will also be generated on the fly as required.
	     * @member {Tiny.Shader[]}
	     */
	    _this.shader = null;

	    _this.currentIndex = 0;
	    TICK = 0;
	    _this.groups = [];

	    for (var k = 0; k < _this.size; k++) {
	      _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };
	    }

	    _this.sprites = [];

	    _this.vertexBuffers = [];
	    _this.vaos = [];

	    _this.vaoMax = 2;
	    _this.vertexCount = 0;

	    _this.renderer.on('prerender', _this.onPrerender, _this);
	    return _this;
	  }

	  /**
	   * Sets up the renderer context and necessary buffers.
	   *
	   * @private
	   */


	  _createClass(SpriteRenderer, [{
	    key: 'onContextChange',
	    value: function onContextChange() {
	      var gl = this.renderer.gl;

	      // step 1: first check max textures the GPU can handle.
	      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);

	      // step 2: check the maximum number of if statements the shader can have too..
	      this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);

	      var shader = this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);

	      // create a couple of buffers
	      this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

	      // we use the second shader as the first one depending on your browser may omit aTextureId
	      // as it is not used by the shader so is optimized out.

	      this.renderer.bindVao(null);

	      for (var i = 0; i < this.vaoMax; i++) {
	        this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);

	        /* eslint-disable max-len */

	        // build the vao object that will render..
	        this.vaos[i] = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(this.vertexBuffers[i], shader.attributes.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(this.vertexBuffers[i], shader.attributes.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(this.vertexBuffers[i], shader.attributes.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4).addAttribute(this.vertexBuffers[i], shader.attributes.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);

	        /* eslint-enable max-len */
	      }

	      this.vao = this.vaos[0];
	      this.currentBlendMode = 99999;

	      this.boundTextures = new Array(this.MAX_TEXTURES);
	    }

	    /**
	     * Called before the renderer starts rendering.
	     *
	     */

	  }, {
	    key: 'onPrerender',
	    value: function onPrerender() {
	      this.vertexCount = 0;
	    }

	    /**
	     * Renders the sprite object.
	     *
	     * @param {Tiny.Sprite} sprite - the sprite to render when using this spritebatch
	     */

	  }, {
	    key: 'render',
	    value: function render(sprite) {
	      // TODO set blend modes..
	      // check texture..
	      if (this.currentIndex >= this.size) {
	        this.flush();
	      }

	      // get the uvs for the texture

	      // if the uvs have not updated then no point rendering just yet!
	      if (!sprite._texture._uvs) {
	        return;
	      }

	      // push a texture.
	      // increment the batchsize
	      this.sprites[this.currentIndex++] = sprite;
	    }

	    /**
	     * Renders the content and empties the current batch.
	     *
	     */

	  }, {
	    key: 'flush',
	    value: function flush() {
	      if (this.currentIndex === 0) {
	        return;
	      }

	      var gl = this.renderer.gl;
	      var MAX_TEXTURES = this.MAX_TEXTURES;

	      var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
	      var log2 = _bitTwiddle2.default.log2(np2);
	      var buffer = this.buffers[log2];

	      var sprites = this.sprites;
	      var groups = this.groups;

	      var float32View = buffer.float32View;
	      var uint32View = buffer.uint32View;

	      var boundTextures = this.boundTextures;
	      var rendererBoundTextures = this.renderer.boundTextures;
	      var touch = this.renderer.textureGC.count;

	      var index = 0;
	      var nextTexture = void 0;
	      var currentTexture = void 0;
	      var groupCount = 1;
	      var textureCount = 0;
	      var currentGroup = groups[0];
	      var vertexData = void 0;
	      var uvs = void 0;
	      var blendMode = sprites[0].blendMode;

	      currentGroup.textureCount = 0;
	      currentGroup.start = 0;
	      currentGroup.blend = blendMode;

	      TICK++;

	      var i = void 0;

	      // copy textures..
	      for (i = 0; i < MAX_TEXTURES; ++i) {
	        boundTextures[i] = rendererBoundTextures[i];
	        boundTextures[i]._virtalBoundId = i;
	      }

	      for (i = 0; i < this.currentIndex; ++i) {
	        // upload the sprite elemetns...
	        // they have all ready been calculated so we just need to push them into the buffer.
	        var sprite = sprites[i];

	        nextTexture = sprite._texture.baseTexture;

	        if (blendMode !== sprite.blendMode) {
	          // finish a group..
	          blendMode = sprite.blendMode;

	          // force the batch to break!
	          currentTexture = null;
	          textureCount = MAX_TEXTURES;
	          TICK++;
	        }

	        if (currentTexture !== nextTexture) {
	          currentTexture = nextTexture;

	          if (nextTexture._enabled !== TICK) {
	            if (textureCount === MAX_TEXTURES) {
	              TICK++;

	              currentGroup.size = i - currentGroup.start;

	              textureCount = 0;

	              currentGroup = groups[groupCount++];
	              currentGroup.blend = blendMode;
	              currentGroup.textureCount = 0;
	              currentGroup.start = i;
	            }

	            nextTexture.touched = touch;

	            if (nextTexture._virtalBoundId === -1) {
	              for (var j = 0; j < MAX_TEXTURES; ++j) {
	                var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;

	                var t = boundTextures[tIndex];

	                if (t._enabled !== TICK) {
	                  TEXTURE_TICK++;

	                  t._virtalBoundId = -1;

	                  nextTexture._virtalBoundId = tIndex;

	                  boundTextures[tIndex] = nextTexture;
	                  break;
	                }
	              }
	            }

	            nextTexture._enabled = TICK;

	            currentGroup.textureCount++;
	            currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
	            currentGroup.textures[textureCount++] = nextTexture;
	          }
	        }

	        vertexData = sprite.vertexData;

	        // TODO this sum does not need to be set each frame..
	        uvs = sprite._texture._uvs.uvsUint32;

	        if (this.renderer.roundPixels) {
	          var resolution = this.renderer.resolution;

	          // xy
	          float32View[index] = (vertexData[0] * resolution | 0) / resolution;
	          float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;

	          // xy
	          float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;
	          float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;

	          // xy
	          float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;
	          float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;

	          // xy
	          float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;
	          float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;
	        } else {
	          // xy
	          float32View[index] = vertexData[0];
	          float32View[index + 1] = vertexData[1];

	          // xy
	          float32View[index + 5] = vertexData[2];
	          float32View[index + 6] = vertexData[3];

	          // xy
	          float32View[index + 10] = vertexData[4];
	          float32View[index + 11] = vertexData[5];

	          // xy
	          float32View[index + 15] = vertexData[6];
	          float32View[index + 16] = vertexData[7];
	        }

	        uint32View[index + 2] = uvs[0];
	        uint32View[index + 7] = uvs[1];
	        uint32View[index + 12] = uvs[2];
	        uint32View[index + 17] = uvs[3];

	        /* eslint-disable max-len */
	        uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = sprite._tintRGB + (Math.min(sprite.worldAlpha, 1) * 255 << 24);

	        float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
	        /* eslint-enable max-len */

	        index += 20;
	      }

	      currentGroup.size = i - currentGroup.start;

	      if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
	        // this is still needed for IOS performance..
	        // it really does not like uploading to the same buffer in a single frame!
	        if (this.vaoMax <= this.vertexCount) {
	          this.vaoMax++;
	          this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);

	          /* eslint-disable max-len */

	          // build the vao object that will render..
	          this.vaos[this.vertexCount] = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4).addAttribute(this.vertexBuffers[this.vertexCount], this.shader.attributes.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);

	          /* eslint-enable max-len */
	        }

	        this.renderer.bindVao(this.vaos[this.vertexCount]);

	        this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);

	        this.vertexCount++;
	      } else {
	        // lets use the faster option, always use buffer number 0
	        this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);
	      }

	      for (i = 0; i < MAX_TEXTURES; ++i) {
	        rendererBoundTextures[i]._virtalBoundId = -1;
	      }

	      // render the groups..
	      for (i = 0; i < groupCount; ++i) {
	        var group = groups[i];
	        var groupTextureCount = group.textureCount;

	        for (var _j = 0; _j < groupTextureCount; _j++) {
	          currentTexture = group.textures[_j];

	          // reset virtual ids..
	          // lets do a quick check..
	          if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {
	            this.renderer.bindTexture(currentTexture, group.ids[_j], true);
	          }

	          // reset the virtualId..
	          currentTexture._virtalBoundId = -1;
	        }

	        // set the blend mode..
	        this.renderer.state.setBlendMode(group.blend);

	        gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
	      }

	      // reset elements for the next flush
	      this.currentIndex = 0;
	    }

	    /**
	     * Starts a new sprite batch.
	     */

	  }, {
	    key: 'start',
	    value: function start() {
	      this.renderer.bindShader(this.shader);

	      if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
	        // bind buffer #0, we don't need others
	        this.renderer.bindVao(this.vaos[this.vertexCount]);

	        this.vertexBuffers[this.vertexCount].bind();
	      }
	    }

	    /**
	     * Stops and flushes the current batch.
	     *
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.flush();
	    }

	    /**
	     * Destroys the SpriteRenderer.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      for (var i = 0; i < this.vaoMax; i++) {
	        if (this.vertexBuffers[i]) {
	          this.vertexBuffers[i].destroy();
	        }
	        if (this.vaos[i]) {
	          this.vaos[i].destroy();
	        }
	      }

	      if (this.indexBuffer) {
	        this.indexBuffer.destroy();
	      }

	      this.renderer.off('prerender', this.onPrerender, this);

	      _get(SpriteRenderer.prototype.__proto__ || Object.getPrototypeOf(SpriteRenderer.prototype), 'destroy', this).call(this);

	      if (this.shader) {
	        this.shader.destroy();
	        this.shader = null;
	      }

	      this.vertexBuffers = null;
	      this.vaos = null;
	      this.indexBuffer = null;
	      this.indices = null;

	      this.sprites = null;

	      for (var _i = 0; _i < this.buffers.length; ++_i) {
	        this.buffers[_i].destroy();
	      }
	    }
	  }]);

	  return SpriteRenderer;
	}(_ObjectRenderer3.default);

	exports.default = SpriteRenderer;


	_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _WebGLManager2 = __webpack_require__(81);

	var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Base for a common object renderer that can be used as a system renderer plugin.
	 *
	 * @class
	 * @extends Tiny.WebGLManager
	 * @memberof Tiny
	 */
	var ObjectRenderer = function (_WebGLManager) {
	  _inherits(ObjectRenderer, _WebGLManager);

	  function ObjectRenderer() {
	    _classCallCheck(this, ObjectRenderer);

	    return _possibleConstructorReturn(this, (ObjectRenderer.__proto__ || Object.getPrototypeOf(ObjectRenderer)).apply(this, arguments));
	  }

	  _createClass(ObjectRenderer, [{
	    key: 'start',

	    /**
	     * Starts the renderer and sets the shader
	     *
	     */
	    value: function start() {}
	    // set the shader..


	    /**
	     * Stops the renderer
	     *
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.flush();
	    }

	    /**
	     * Stub method for rendering content and emptying the current batch.
	     *
	     */

	  }, {
	    key: 'flush',
	    value: function flush() {}
	    // flush!


	    /**
	     * Renders an object
	     *
	     * @param {Tiny.DisplayObject} object - The object to render.
	     */

	  }, {
	    key: 'render',
	    value: function render(object) // eslint-disable-line no-unused-vars
	    {
	      // render the object
	    }
	  }]);

	  return ObjectRenderer;
	}(_WebGLManager3.default);

	exports.default = ObjectRenderer;

/***/ }),
/* 81 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var WebGLManager = function () {
	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this manager works for.
	   */
	  function WebGLManager(renderer) {
	    _classCallCheck(this, WebGLManager);

	    /**
	     * The renderer this manager works for.
	     *
	     * @member {Tiny.WebGLRenderer}
	     */
	    this.renderer = renderer;

	    this.renderer.on('context', this.onContextChange, this);
	  }

	  /**
	   * Generic method called when there is a WebGL context change.
	   *
	   */


	  _createClass(WebGLManager, [{
	    key: 'onContextChange',
	    value: function onContextChange() {}
	    // do some codes init!


	    /**
	     * Generic destroy methods to be overridden by the subclass
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.renderer.off('context', this.onContextChange, this);

	      this.renderer = null;
	    }
	  }]);

	  return WebGLManager;
	}();

	exports.default = WebGLManager;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SystemRenderer2 = __webpack_require__(71);

	var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);

	var _MaskManager = __webpack_require__(83);

	var _MaskManager2 = _interopRequireDefault(_MaskManager);

	var _StencilManager = __webpack_require__(88);

	var _StencilManager2 = _interopRequireDefault(_StencilManager);

	var _FilterManager = __webpack_require__(89);

	var _FilterManager2 = _interopRequireDefault(_FilterManager);

	var _RenderTarget = __webpack_require__(90);

	var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

	var _ObjectRenderer = __webpack_require__(80);

	var _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);

	var _TextureManager = __webpack_require__(95);

	var _TextureManager2 = _interopRequireDefault(_TextureManager);

	var _BaseTexture = __webpack_require__(53);

	var _BaseTexture2 = _interopRequireDefault(_BaseTexture);

	var _TextureGarbageCollector = __webpack_require__(96);

	var _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);

	var _WebGLState = __webpack_require__(97);

	var _WebGLState2 = _interopRequireDefault(_WebGLState);

	var _mapWebGLDrawModesToTiny = __webpack_require__(99);

	var _mapWebGLDrawModesToTiny2 = _interopRequireDefault(_mapWebGLDrawModesToTiny);

	var _validateContext = __webpack_require__(100);

	var _validateContext2 = _interopRequireDefault(_validateContext);

	var _utils = __webpack_require__(18);

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CONTEXT_UID = 0;

	/**
	 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
	 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
	 * So no need for Sprite Batches or Sprite Clouds.
	 * Don't forget to add the view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.SystemRenderer
	 */

	var WebGLRenderer = function (_SystemRenderer) {
	  _inherits(WebGLRenderer, _SystemRenderer);

	  /**
	   *
	   * @param {number} [width=0] - the width of the canvas view
	   * @param {number} [height=0] - the height of the canvas view
	   * @param {object} [options] - The optional renderer parameters
	   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
	   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
	   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
	   * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA
	   *  antialiasing is used
	   * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
	   *  FXAA is faster, but may not always look as great
	   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
	   *  The resolution of the renderer retina would be 2.
	   * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear
	   *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
	   *  preserveDrawingBuffer to `true`.
	   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
	   *  enable this if you need to call toDataUrl on the webgl context.
	   * @param {boolean} [options.roundPixels=false] - If true Tiny will Math.floor() x/y values when
	   *  rendering, stopping pixel interpolation.
	   */
	  function WebGLRenderer(width, height) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    _classCallCheck(this, WebGLRenderer);

	    /**
	     * The type of this renderer as a standardised const
	     *
	     * @member {number}
	     * @see Tiny.RENDERER_TYPE
	     */
	    var _this = _possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, 'WebGL', width, height, options));

	    _this.type = _const.RENDERER_TYPE.WEBGL;

	    _this.handleContextLost = _this.handleContextLost.bind(_this);
	    _this.handleContextRestored = _this.handleContextRestored.bind(_this);

	    _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);
	    _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);

	    /**
	     * The options passed in to create a new webgl context.
	     *
	     * @member {object}
	     * @private
	     */
	    _this._contextOptions = {
	      alpha: _this.transparent,
	      antialias: options.antialias,
	      premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',
	      stencil: true,
	      preserveDrawingBuffer: options.preserveDrawingBuffer
	    };

	    _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;

	    /**
	     * Manages the masks using the stencil buffer.
	     *
	     * @member {Tiny.MaskManager}
	     */
	    _this.maskManager = new _MaskManager2.default(_this);

	    /**
	     * Manages the stencil buffer.
	     *
	     * @member {Tiny.StencilManager}
	     */
	    _this.stencilManager = new _StencilManager2.default(_this);

	    /**
	     * An empty renderer.
	     *
	     * @member {Tiny.ObjectRenderer}
	     */
	    _this.emptyRenderer = new _ObjectRenderer2.default(_this);

	    /**
	     * The currently active ObjectRenderer.
	     *
	     * @member {Tiny.ObjectRenderer}
	     */
	    _this.currentRenderer = _this.emptyRenderer;

	    _this.initPlugins();

	    /**
	     * The current WebGL rendering context, it is created here
	     *
	     * @member {WebGLRenderingContext}
	     */
	    // initialize the context so it is ready for the managers.
	    if (options.context) {
	      // checks to see if a context is valid..
	      (0, _validateContext2.default)(options.context);
	    }

	    _this.gl = options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);

	    _this.CONTEXT_UID = CONTEXT_UID++;

	    /**
	     * The currently active ObjectRenderer.
	     *
	     * @member {Tiny.WebGLState}
	     */
	    _this.state = new _WebGLState2.default(_this.gl);

	    _this.renderingToScreen = true;

	    /**
	     * Holds the current state of textures bound to the GPU.
	     * @type {Array}
	     */
	    _this.boundTextures = null;

	    /**
	     * Holds the current shader
	     *
	     * @member {Tiny.Shader}
	     */
	    _this._activeShader = null;

	    _this._activeVao = null;

	    /**
	     * Holds the current render target
	     *
	     * @member {Tiny.RenderTarget}
	     */
	    _this._activeRenderTarget = null;

	    _this._initContext();

	    /**
	     * Manages the filters.
	     *
	     * @member {Tiny.FilterManager}
	     */
	    _this.filterManager = new _FilterManager2.default(_this);
	    // map some webGL blend and drawmodes..
	    _this.drawModes = (0, _mapWebGLDrawModesToTiny2.default)(_this.gl);

	    _this._nextTextureLocation = 0;

	    _this.setBlendMode(0);
	    return _this;
	  }

	  /**
	   * Creates the WebGL context
	   *
	   * @private
	   */


	  _createClass(WebGLRenderer, [{
	    key: '_initContext',
	    value: function _initContext() {
	      var gl = this.gl;

	      // restore a context if it was previously lost
	      if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
	        gl.getExtension('WEBGL_lose_context').restoreContext();
	      }

	      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

	      this.boundTextures = new Array(maxTextures);
	      this.emptyTextures = new Array(maxTextures);

	      // create a texture manager...
	      this.textureManager = new _TextureManager2.default(this);
	      this.textureGC = new _TextureGarbageCollector2.default(this);

	      this.state.resetToDefault();

	      this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
	      this.rootRenderTarget.clearColor = this._backgroundColorRgba;

	      this.bindRenderTarget(this.rootRenderTarget);

	      // now lets fill up the textures with empty ones!
	      var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1); // eslint-disable-line

	      var tempObj = { _glTextures: {} };

	      tempObj._glTextures[this.CONTEXT_UID] = {};

	      for (var i = 0; i < maxTextures; i++) {
	        var empty = new _BaseTexture2.default();

	        empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;

	        this.boundTextures[i] = tempObj;
	        this.emptyTextures[i] = empty;
	        this.bindTexture(null, i);
	      }

	      this.emit('context', gl);

	      // setup the width/height properties and gl viewport
	      this.resize(this.width, this.height);
	    }

	    /**
	     * Renders the object to its webGL view
	     *
	     * @param {Tiny.DisplayObject} displayObject - the object to be rendered
	     * @param {Tiny.RenderTexture} renderTexture - The render texture to render to.
	     * @param {boolean} [clear] - Should the canvas be cleared before the new render
	     * @param {Tiny.Transform} [transform] - A transform to apply to the render texture before rendering.
	     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?
	     */

	  }, {
	    key: 'render',
	    value: function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
	      // can be handy to know!
	      this.renderingToScreen = !renderTexture;

	      this.emit('prerender');

	      // no point rendering if our context has been blown up!
	      if (!this.gl || this.gl.isContextLost()) {
	        return;
	      }

	      this._nextTextureLocation = 0;

	      if (!renderTexture) {
	        this._lastObjectRendered = displayObject;
	      }

	      if (!skipUpdateTransform) {
	        // update the scene graph
	        var cacheParent = displayObject.parent;

	        displayObject.parent = this._tempDisplayObjectParent;
	        displayObject.updateTransform();
	        displayObject.parent = cacheParent;
	        // displayObject.hitArea = //TODO add a temp hit area
	      }

	      this.bindRenderTexture(renderTexture, transform);

	      this.currentRenderer.start();

	      if (clear !== undefined ? clear : this.clearBeforeRender) {
	        this._activeRenderTarget.clear();
	      }

	      displayObject.renderWebGL(this);

	      // apply transform..
	      this.currentRenderer.flush();

	      // this.setObjectRenderer(this.emptyRenderer);

	      this.textureGC.update();

	      this.emit('postrender');
	    }

	    /**
	     * Changes the current renderer to the one given in parameter
	     *
	     * @param {Tiny.ObjectRenderer} objectRenderer - The object renderer to use.
	     */

	  }, {
	    key: 'setObjectRenderer',
	    value: function setObjectRenderer(objectRenderer) {
	      if (this.currentRenderer === objectRenderer) {
	        return;
	      }

	      this.currentRenderer.stop();
	      this.currentRenderer = objectRenderer;
	      this.currentRenderer.start();
	    }

	    /**
	     * This should be called if you wish to do some custom rendering
	     * It will basically render anything that may be batched up such as sprites
	     *
	     */

	  }, {
	    key: 'flush',
	    value: function flush() {
	      this.setObjectRenderer(this.emptyRenderer);
	    }

	    /**
	     * Resizes the webGL view to the specified width and height.
	     *
	     * @param {number} width - the new width of the webGL view
	     * @param {number} height - the new height of the webGL view
	     */

	  }, {
	    key: 'resize',
	    value: function resize(width, height) {
	      //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;

	      _SystemRenderer3.default.prototype.resize.call(this, width, height);

	      this.rootRenderTarget.resize(width, height);

	      if (this._activeRenderTarget === this.rootRenderTarget) {
	        this.rootRenderTarget.activate();

	        if (this._activeShader) {
	          this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
	        }
	      }
	    }

	    /**
	     * Resizes the webGL view to the specified width and height.
	     *
	     * @param {number} blendMode - the desired blend mode
	     */

	  }, {
	    key: 'setBlendMode',
	    value: function setBlendMode(blendMode) {
	      this.state.setBlendMode(blendMode);
	    }

	    /**
	     * Erases the active render target and fills the drawing area with a colour
	     *
	     * @param {number} [clearColor] - The colour
	     */

	  }, {
	    key: 'clear',
	    value: function clear(clearColor) {
	      this._activeRenderTarget.clear(clearColor);
	    }

	    /**
	     * Sets the transform of the active render target to the given matrix
	     *
	     * @param {Tiny.Matrix} matrix - The transformation matrix
	     */

	  }, {
	    key: 'setTransform',
	    value: function setTransform(matrix) {
	      this._activeRenderTarget.transform = matrix;
	    }

	    /**
	     * Binds a render texture for rendering
	     *
	     * @param {Tiny.RenderTexture} renderTexture - The render texture to render
	     * @param {Tiny.Transform} transform - The transform to be applied to the render texture
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'bindRenderTexture',
	    value: function bindRenderTexture(renderTexture, transform) {
	      var renderTarget = void 0;

	      if (renderTexture) {
	        var baseTexture = renderTexture.baseTexture;

	        if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {
	          // bind the current texture
	          this.textureManager.updateTexture(baseTexture, 0);
	        }

	        this.unbindTexture(baseTexture);

	        renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
	        renderTarget.setFrame(renderTexture.frame);
	      } else {
	        renderTarget = this.rootRenderTarget;
	      }

	      renderTarget.transform = transform;
	      this.bindRenderTarget(renderTarget);

	      return this;
	    }

	    /**
	     * Changes the current render target to the one given in parameter
	     *
	     * @param {Tiny.RenderTarget} renderTarget - the new render target
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'bindRenderTarget',
	    value: function bindRenderTarget(renderTarget) {
	      if (renderTarget !== this._activeRenderTarget) {
	        this._activeRenderTarget = renderTarget;
	        renderTarget.activate();

	        if (this._activeShader) {
	          this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
	        }

	        this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
	      }

	      return this;
	    }

	    /**
	     * Changes the current shader to the one given in parameter
	     *
	     * @param {Tiny.Shader} shader - the new shader
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'bindShader',
	    value: function bindShader(shader) {
	      // TODO cache
	      if (this._activeShader !== shader) {
	        this._activeShader = shader;
	        shader.bind();

	        // automatically set the projection matrix
	        shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
	      }

	      return this;
	    }

	    /**
	     * Binds the texture. This will return the location of the bound texture.
	     * It may not be the same as the one you pass in. This is due to optimisation that prevents
	     * needless binding of textures. For example if the texture is already bound it will return the
	     * current location of the texture instead of the one provided. To bypass this use force location
	     *
	     * @param {Tiny.Texture} texture - the new texture
	     * @param {number} location - the suggested texture location
	     * @param {boolean} forceLocation - force the location
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'bindTexture',
	    value: function bindTexture(texture, location, forceLocation) {
	      texture = texture || this.emptyTextures[location];
	      texture = texture.baseTexture || texture;
	      texture.touched = this.textureGC.count;

	      if (!forceLocation) {
	        // TODO - maybe look into adding boundIds.. save us the loop?
	        for (var i = 0; i < this.boundTextures.length; i++) {
	          if (this.boundTextures[i] === texture) {
	            return i;
	          }
	        }

	        if (location === undefined) {
	          this._nextTextureLocation++;
	          this._nextTextureLocation %= this.boundTextures.length;
	          location = this.boundTextures.length - this._nextTextureLocation - 1;
	        }
	      } else {
	        location = location || 0;
	      }

	      var gl = this.gl;
	      var glTexture = texture._glTextures[this.CONTEXT_UID];

	      if (!glTexture) {
	        // this will also bind the texture..
	        this.textureManager.updateTexture(texture, location);
	      } else {
	        // bind the current texture
	        this.boundTextures[location] = texture;
	        gl.activeTexture(gl.TEXTURE0 + location);
	        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
	      }

	      return location;
	    }

	    /**
	     * unbinds the texture ...
	     *
	     * @param {Tiny.Texture} texture - the texture to unbind
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'unbindTexture',
	    value: function unbindTexture(texture) {
	      var gl = this.gl;

	      texture = texture.baseTexture || texture;

	      for (var i = 0; i < this.boundTextures.length; i++) {
	        if (this.boundTextures[i] === texture) {
	          this.boundTextures[i] = this.emptyTextures[i];

	          gl.activeTexture(gl.TEXTURE0 + i);
	          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);
	        }
	      }

	      return this;
	    }

	    /**
	     * Creates a new VAO from this renderer's context and state.
	     *
	     * @return {VertexArrayObject} The new VAO.
	     */

	  }, {
	    key: 'createVao',
	    value: function createVao() {
	      return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);
	    }

	    /**
	     * Changes the current Vao to the one given in parameter
	     *
	     * @param {Tiny.VertexArrayObject} vao - the new Vao
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'bindVao',
	    value: function bindVao(vao) {
	      if (this._activeVao === vao) {
	        return this;
	      }

	      if (vao) {
	        vao.bind();
	      } else if (this._activeVao) {
	        // TODO this should always be true i think?
	        this._activeVao.unbind();
	      }

	      this._activeVao = vao;

	      return this;
	    }

	    /**
	     * Resets the WebGL state so you can render things however you fancy!
	     *
	     * @return {Tiny.WebGLRenderer} Returns itself.
	     */

	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.setObjectRenderer(this.emptyRenderer);

	      this._activeShader = null;
	      this._activeRenderTarget = this.rootRenderTarget;

	      // bind the main frame buffer (the screen);
	      this.rootRenderTarget.activate();

	      this.state.resetToDefault();

	      return this;
	    }

	    /**
	     * Handles a lost webgl context
	     *
	     * @private
	     * @param {WebGLContextEvent} event - The context lost event.
	     */

	  }, {
	    key: 'handleContextLost',
	    value: function handleContextLost(event) {
	      event.preventDefault();
	    }

	    /**
	     * Handles a restored webgl context
	     *
	     * @private
	     */

	  }, {
	    key: 'handleContextRestored',
	    value: function handleContextRestored() {
	      this._initContext();
	      this.textureManager.removeAll();
	    }

	    /**
	     * Removes everything from the renderer (event listeners, spritebatch, etc...)
	     *
	     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
	     *  See: https://github.com/pixijs/pixi.js/issues/2233
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(removeView) {
	      this.destroyPlugins();

	      // remove listeners
	      this.view.removeEventListener('webglcontextlost', this.handleContextLost);
	      this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

	      this.textureManager.destroy();

	      // call base destroy
	      _get(WebGLRenderer.prototype.__proto__ || Object.getPrototypeOf(WebGLRenderer.prototype), 'destroy', this).call(this, removeView);

	      this.uid = 0;

	      // destroy the managers
	      this.maskManager.destroy();
	      this.stencilManager.destroy();
	      this.filterManager.destroy();

	      this.maskManager = null;
	      this.filterManager = null;
	      this.textureManager = null;
	      this.currentRenderer = null;

	      this.handleContextLost = null;
	      this.handleContextRestored = null;

	      this._contextOptions = null;
	      this.gl.useProgram(null);

	      if (this.gl.getExtension('WEBGL_lose_context')) {
	        this.gl.getExtension('WEBGL_lose_context').loseContext();
	      }

	      this.gl = null;

	      // this = null;
	    }
	  }]);

	  return WebGLRenderer;
	}(_SystemRenderer3.default);

	exports.default = WebGLRenderer;


	_utils.pluginTarget.mixin(WebGLRenderer);

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _WebGLManager2 = __webpack_require__(81);

	var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

	var _SpriteMaskFilter = __webpack_require__(84);

	var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @class
	 * @extends Tiny.WebGLManager
	 * @memberof Tiny
	 */
	var MaskManager = function (_WebGLManager) {
	  _inherits(MaskManager, _WebGLManager);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this manager works for.
	   */
	  function MaskManager(renderer) {
	    _classCallCheck(this, MaskManager);

	    // TODO - we don't need both!
	    var _this = _possibleConstructorReturn(this, (MaskManager.__proto__ || Object.getPrototypeOf(MaskManager)).call(this, renderer));

	    _this.scissor = false;
	    _this.scissorData = null;
	    _this.scissorRenderTarget = null;

	    _this.enableScissor = true;

	    _this.alphaMaskPool = [];
	    _this.alphaMaskIndex = 0;
	    return _this;
	  }

	  /**
	   * Applies the Mask and adds it to the current filter stack.
	   *
	   * @param {Tiny.DisplayObject} target - Display Object to push the mask to
	   * @param {Tiny.Sprite|Tiny.Graphics} maskData - The masking data.
	   */


	  _createClass(MaskManager, [{
	    key: 'pushMask',
	    value: function pushMask(target, maskData) {
	      // TODO the root check means scissor rect will not
	      // be used on render textures more info here:
	      // https://github.com/pixijs/pixi.js/pull/3545

	      if (maskData.texture) {
	        this.pushSpriteMask(target, maskData);
	      } else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && maskData.isFastRect()) {
	        var matrix = maskData.worldTransform;

	        var rot = Math.atan2(matrix.b, matrix.a);

	        // use the nearest degree!
	        rot = Math.round(rot * (180 / Math.PI));

	        if (rot % 90) {
	          this.pushStencilMask(maskData);
	        } else {
	          this.pushScissorMask(target, maskData);
	        }
	      } else {
	        this.pushStencilMask(maskData);
	      }
	    }

	    /**
	     * Removes the last mask from the mask stack and doesn't return it.
	     *
	     * @param {Tiny.DisplayObject} target - Display Object to pop the mask from
	     * @param {Tiny.Sprite|Tiny.Graphics} maskData - The masking data.
	     */

	  }, {
	    key: 'popMask',
	    value: function popMask(target, maskData) {
	      if (maskData.texture) {
	        this.popSpriteMask(target, maskData);
	      } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) {
	        this.popScissorMask(target, maskData);
	      } else {
	        this.popStencilMask(target, maskData);
	      }
	    }

	    /**
	     * Applies the Mask and adds it to the current filter stack.
	     *
	     * @param {Tiny.RenderTarget} target - Display Object to push the sprite mask to
	     * @param {Tiny.Sprite} maskData - Sprite to be used as the mask
	     */

	  }, {
	    key: 'pushSpriteMask',
	    value: function pushSpriteMask(target, maskData) {
	      var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];

	      if (!alphaMaskFilter) {
	        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)];
	      }

	      alphaMaskFilter[0].resolution = this.renderer.resolution;
	      alphaMaskFilter[0].maskSprite = maskData;

	      // TODO - may cause issues!
	      target.filterArea = maskData.getBounds(true);

	      this.renderer.filterManager.pushFilter(target, alphaMaskFilter);

	      this.alphaMaskIndex++;
	    }

	    /**
	     * Removes the last filter from the filter stack and doesn't return it.
	     *
	     */

	  }, {
	    key: 'popSpriteMask',
	    value: function popSpriteMask() {
	      this.renderer.filterManager.popFilter();
	      this.alphaMaskIndex--;
	    }

	    /**
	     * Applies the Mask and adds it to the current filter stack.
	     *
	     * @param {Tiny.Sprite|Tiny.Graphics} maskData - The masking data.
	     */

	  }, {
	    key: 'pushStencilMask',
	    value: function pushStencilMask(maskData) {
	      this.renderer.currentRenderer.stop();
	      this.renderer.stencilManager.pushStencil(maskData);
	    }

	    /**
	     * Removes the last filter from the filter stack and doesn't return it.
	     *
	     */

	  }, {
	    key: 'popStencilMask',
	    value: function popStencilMask() {
	      this.renderer.currentRenderer.stop();
	      this.renderer.stencilManager.popStencil();
	    }

	    /**
	     *
	     * @param {Tiny.DisplayObject} target - Display Object to push the mask to
	     * @param {Tiny.Graphics} maskData - The masking data.
	     */

	  }, {
	    key: 'pushScissorMask',
	    value: function pushScissorMask(target, maskData) {
	      maskData.renderable = true;

	      var renderTarget = this.renderer._activeRenderTarget;

	      var bounds = maskData.getBounds();

	      bounds.fit(renderTarget.size);
	      maskData.renderable = false;

	      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);

	      var resolution = this.renderer.resolution;

	      this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);

	      this.scissorRenderTarget = renderTarget;
	      this.scissorData = maskData;
	      this.scissor = true;
	    }

	    /**
	     *
	     *
	     */

	  }, {
	    key: 'popScissorMask',
	    value: function popScissorMask() {
	      this.scissorRenderTarget = null;
	      this.scissorData = null;
	      this.scissor = false;

	      // must be scissor!
	      var gl = this.renderer.gl;

	      gl.disable(gl.SCISSOR_TEST);
	    }
	  }]);

	  return MaskManager;
	}(_WebGLManager3.default);

	exports.default = MaskManager;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Filter2 = __webpack_require__(85);

	var _Filter3 = _interopRequireDefault(_Filter2);

	var _math = __webpack_require__(8);

	var _path = __webpack_require__(87);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The SpriteMaskFilter class
	 *
	 * @class
	 * @extends Tiny.Filter
	 * @memberof Tiny
	 */
	var SpriteMaskFilter = function (_Filter) {
	  _inherits(SpriteMaskFilter, _Filter);

	  /**
	   * @param {Tiny.Sprite} sprite - the target sprite
	   */
	  function SpriteMaskFilter(sprite) {
	    _classCallCheck(this, SpriteMaskFilter);

	    var maskMatrix = new _math.Matrix();

	    var _this = _possibleConstructorReturn(this, (SpriteMaskFilter.__proto__ || Object.getPrototypeOf(SpriteMaskFilter)).call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n'));

	    sprite.renderable = false;

	    _this.maskSprite = sprite;
	    _this.maskMatrix = maskMatrix;
	    return _this;
	  }

	  /**
	   * Applies the filter
	   *
	   * @param {Tiny.FilterManager} filterManager - The renderer to retrieve the filter from
	   * @param {Tiny.RenderTarget} input - The input render target.
	   * @param {Tiny.RenderTarget} output - The target to output to.
	   */


	  _createClass(SpriteMaskFilter, [{
	    key: 'apply',
	    value: function apply(filterManager, input, output) {
	      var maskSprite = this.maskSprite;

	      this.uniforms.mask = maskSprite._texture;
	      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite);
	      this.uniforms.alpha = maskSprite.worldAlpha;

	      filterManager.applyFilter(this, input, output);
	    }
	  }]);

	  return SpriteMaskFilter;
	}(_Filter3.default);

	exports.default = SpriteMaskFilter;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _extractUniformsFromSrc = __webpack_require__(86);

	var _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SOURCE_KEY_MAP = {};

	// let math = require('../../../math');
	/**
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.Shader
	 */

	var Filter = function () {
	  /**
	   * @param {string} [vertexSrc] - The source of the vertex shader.
	   * @param {string} [fragmentSrc] - The source of the fragment shader.
	   * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
	   */
	  function Filter(vertexSrc, fragmentSrc, uniforms) {
	    _classCallCheck(this, Filter);

	    /**
	     * The vertex shader.
	     *
	     * @member {string}
	     */
	    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;

	    /**
	     * The fragment shader.
	     *
	     * @member {string}
	     */
	    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;

	    this.blendMode = _const.BLEND_MODES.NORMAL;

	    // pull out the vertex and shader uniforms if they are not specified..
	    // currently this does not extract structs only default types
	    this.uniformData = uniforms || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');

	    /**
	     * An object containing the current values of custom uniforms.
	     * @example <caption>Updating the value of a custom uniform</caption>
	     * filter.uniforms.time = performance.now();
	     *
	     * @member {object}
	     */
	    this.uniforms = {};

	    for (var i in this.uniformData) {
	      this.uniforms[i] = this.uniformData[i].value;
	    }

	    // this is where we store shader references..
	    // TODO we could cache this!
	    this.glShaders = {};

	    // used for cacheing.. sure there is a better way!
	    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {
	      SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();
	    }

	    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];

	    /**
	     * The padding of the filter. Some filters require extra space to breath such as a blur.
	     * Increasing this will add extra width and height to the bounds of the object that the
	     * filter is applied to.
	     *
	     * @member {number}
	     */
	    this.padding = 4;

	    /**
	     * The resolution of the filter. Setting this to be lower will lower the quality but
	     * increase the performance of the filter.
	     *
	     * @member {number}
	     */
	    this.resolution = 1;

	    /**
	     * If enabled is true the filter is applied, if false it will not.
	     *
	     * @member {boolean}
	     */
	    this.enabled = true;
	  }

	  /**
	   * Applies the filter
	   *
	   * @param {Tiny.FilterManager} filterManager - The renderer to retrieve the filter from
	   * @param {Tiny.RenderTarget} input - The input render target.
	   * @param {Tiny.RenderTarget} output - The target to output to.
	   * @param {boolean} clear - Should the output be cleared before rendering to it
	   */


	  _createClass(Filter, [{
	    key: 'apply',
	    value: function apply(filterManager, input, output, clear) {
	      // --- //
	      //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );

	      // do as you please!

	      filterManager.applyFilter(this, input, output, clear);

	      // or just do a regular render..
	    }

	    /**
	     * The default vertex shader source
	     *
	     * @static
	     * @constant
	     */

	  }], [{
	    key: 'defaultVertexSrc',
	    get: function get() {
	      return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\n');
	    }

	    /**
	     * The default fragment shader source
	     *
	     * @static
	     * @constant
	     */

	  }, {
	    key: 'defaultFragmentSrc',
	    get: function get() {
	      return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }',
	      // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
	      '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\n');
	    }
	  }]);

	  return Filter;
	}();

	exports.default = Filter;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = extractUniformsFromSrc;

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var defaultValue = _pixiGlCore2.default.shader.defaultValue;

	function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) {
	  var vertUniforms = extractUniformsFromString(vertexSrc, mask);
	  var fragUniforms = extractUniformsFromString(fragmentSrc, mask);

	  return Object.assign(vertUniforms, fragUniforms);
	}

	function extractUniformsFromString(string) {
	  var maskRegex = new RegExp('^(projectionMatrix|uSampler|filterArea)$');

	  var uniforms = {};
	  var nameSplit = void 0;

	  // clean the lines a little - remove extra spaces / tabs etc
	  // then split along ';'
	  var lines = string.replace(/\s+/g, ' ').split(/\s*;\s*/);

	  // loop through..
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i].trim();

	    if (line.indexOf('uniform') > -1) {
	      var splitLine = line.split(' ');
	      var type = splitLine[1];

	      var name = splitLine[2];
	      var size = 1;

	      if (name.indexOf('[') > -1) {
	        // array!
	        nameSplit = name.split(/\[|]/);
	        name = nameSplit[0];
	        size *= Number(nameSplit[1]);
	      }

	      if (!name.match(maskRegex)) {
	        uniforms[name] = {
	          value: defaultValue(type, size),
	          name: name,
	          type: type
	        };
	      }
	    }
	  }

	  return uniforms;
	}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function splitPath(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function () {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = i >= 0 ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function (path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function (p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function (path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function () {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function (p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};

	// path.relative(from, to)
	// posix version
	exports.relative = function (from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function (path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};

	exports.basename = function (path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};

	exports.extname = function (path) {
	  return splitPath(path)[3];
	};

	function filter(xs, f) {
	  if (xs.filter) return xs.filter(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    if (f(xs[i], i, xs)) res.push(xs[i]);
	  }
	  return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
	  return str.substr(start, len);
	} : function (str, start, len) {
	  if (start < 0) start = str.length + start;
	  return str.substr(start, len);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _WebGLManager2 = __webpack_require__(81);

	var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @class
	 * @extends Tiny.WebGLManager
	 * @memberof Tiny
	 */
	var StencilManager = function (_WebGLManager) {
	  _inherits(StencilManager, _WebGLManager);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this manager works for.
	   */
	  function StencilManager(renderer) {
	    _classCallCheck(this, StencilManager);

	    var _this = _possibleConstructorReturn(this, (StencilManager.__proto__ || Object.getPrototypeOf(StencilManager)).call(this, renderer));

	    _this.stencilMaskStack = null;
	    return _this;
	  }

	  /**
	   * Changes the mask stack that is used by this manager.
	   *
	   * @param {Tiny.Graphics[]} stencilMaskStack - The mask stack
	   */


	  _createClass(StencilManager, [{
	    key: 'setMaskStack',
	    value: function setMaskStack(stencilMaskStack) {
	      this.stencilMaskStack = stencilMaskStack;

	      var gl = this.renderer.gl;

	      if (stencilMaskStack.length === 0) {
	        gl.disable(gl.STENCIL_TEST);
	      } else {
	        gl.enable(gl.STENCIL_TEST);
	      }
	    }

	    /**
	     * Applies the Mask and adds it to the current filter stack. @alvin
	     *
	     * @param {Tiny.Graphics} graphics - The mask
	     */

	  }, {
	    key: 'pushStencil',
	    value: function pushStencil(graphics) {
	      this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

	      this.renderer._activeRenderTarget.attachStencilBuffer();

	      var gl = this.renderer.gl;
	      var sms = this.stencilMaskStack;

	      if (sms.length === 0) {
	        gl.enable(gl.STENCIL_TEST);
	        gl.clear(gl.STENCIL_BUFFER_BIT);
	        gl.stencilFunc(gl.ALWAYS, 1, 1);
	      }

	      sms.push(graphics);

	      gl.colorMask(false, false, false, false);
	      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

	      this.renderer.plugins.graphics.render(graphics);

	      gl.colorMask(true, true, true, true);
	      gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
	      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	    }

	    /**
	     * TODO @alvin
	     */

	  }, {
	    key: 'popStencil',
	    value: function popStencil() {
	      this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

	      var gl = this.renderer.gl;
	      var sms = this.stencilMaskStack;

	      var graphics = sms.pop();

	      if (sms.length === 0) {
	        // the stack is empty!
	        gl.disable(gl.STENCIL_TEST);
	      } else {
	        gl.colorMask(false, false, false, false);
	        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);

	        this.renderer.plugins.graphics.render(graphics);

	        gl.colorMask(true, true, true, true);
	        gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
	        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	      }
	    }

	    /**
	     * Destroys the mask stack.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      _WebGLManager3.default.prototype.destroy.call(this);

	      this.stencilMaskStack.stencilStack = null;
	    }
	  }]);

	  return StencilManager;
	}(_WebGLManager3.default);

	exports.default = StencilManager;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _WebGLManager2 = __webpack_require__(81);

	var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

	var _RenderTarget = __webpack_require__(90);

	var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

	var _Quad = __webpack_require__(91);

	var _Quad2 = _interopRequireDefault(_Quad);

	var _math = __webpack_require__(8);

	var _Shader = __webpack_require__(93);

	var _Shader2 = _interopRequireDefault(_Shader);

	var _filterTransforms = __webpack_require__(94);

	var filterTransforms = _interopRequireWildcard(_filterTransforms);

	var _bitTwiddle = __webpack_require__(63);

	var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @ignore
	 * @class
	 */
	var FilterState =
	/**
	 *
	 */
	function FilterState() {
	  _classCallCheck(this, FilterState);

	  this.renderTarget = null;
	  this.sourceFrame = new _math.Rectangle();
	  this.destinationFrame = new _math.Rectangle();
	  this.filters = [];
	  this.target = null;
	  this.resolution = 1;
	};

	/**
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.WebGLManager
	 */


	var FilterManager = function (_WebGLManager) {
	  _inherits(FilterManager, _WebGLManager);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this manager works for.
	   */
	  function FilterManager(renderer) {
	    _classCallCheck(this, FilterManager);

	    var _this = _possibleConstructorReturn(this, (FilterManager.__proto__ || Object.getPrototypeOf(FilterManager)).call(this, renderer));

	    _this.gl = _this.renderer.gl;
	    // know about sprites!
	    _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);

	    _this.shaderCache = {};
	    // todo add default!
	    _this.pool = {};

	    _this.filterData = null;
	    return _this;
	  }

	  /**
	   * Adds a new filter to the manager.
	   *
	   * @param {Tiny.DisplayObject} target - The target of the filter to render.
	   * @param {Tiny.Filter[]} filters - The filters to apply.
	   */


	  _createClass(FilterManager, [{
	    key: 'pushFilter',
	    value: function pushFilter(target, filters) {
	      var renderer = this.renderer;

	      var filterData = this.filterData;

	      if (!filterData) {
	        filterData = this.renderer._activeRenderTarget.filterStack;

	        // add new stack
	        var filterState = new FilterState();

	        filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
	        filterState.renderTarget = renderer._activeRenderTarget;

	        this.renderer._activeRenderTarget.filterData = filterData = {
	          index: 0,
	          stack: [filterState]
	        };

	        this.filterData = filterData;
	      }

	      // get the current filter state..
	      var currentState = filterData.stack[++filterData.index];

	      if (!currentState) {
	        currentState = filterData.stack[filterData.index] = new FilterState();
	      }

	      // for now we go off the filter of the first resolution..
	      var resolution = filters[0].resolution;
	      var padding = filters[0].padding | 0;
	      var targetBounds = target.filterArea || target.getBounds(true);
	      var sourceFrame = currentState.sourceFrame;
	      var destinationFrame = currentState.destinationFrame;

	      sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;
	      sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;
	      sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;
	      sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;

	      if (filterData.stack[0].renderTarget.transform) {//

	        // TODO we should fit the rect around the transform..
	      } else {
	        sourceFrame.fit(filterData.stack[0].destinationFrame);
	      }

	      // lets apply the padding After we fit the element to the screen.
	      // this should stop the strange side effects that can occur when cropping to the edges
	      sourceFrame.pad(padding);

	      destinationFrame.width = sourceFrame.width;
	      destinationFrame.height = sourceFrame.height;

	      // lets play the padding after we fit the element to the screen.
	      // this should stop the strange side effects that can occur when cropping to the edges

	      var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);

	      currentState.target = target;
	      currentState.filters = filters;
	      currentState.resolution = resolution;
	      currentState.renderTarget = renderTarget;

	      // bind the render target to draw the shape in the top corner..

	      renderTarget.setFrame(destinationFrame, sourceFrame);

	      // bind the render target
	      renderer.bindRenderTarget(renderTarget);
	      renderTarget.clear();
	    }

	    /**
	     * Pops off the filter and applies it.
	     *
	     */

	  }, {
	    key: 'popFilter',
	    value: function popFilter() {
	      var filterData = this.filterData;

	      var lastState = filterData.stack[filterData.index - 1];
	      var currentState = filterData.stack[filterData.index];

	      this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();

	      var filters = currentState.filters;

	      if (filters.length === 1) {
	        filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false);
	        this.freePotRenderTarget(currentState.renderTarget);
	      } else {
	        var flip = currentState.renderTarget;
	        var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);

	        flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);

	        // finally lets clear the render target before drawing to it..
	        flop.clear();

	        var i = 0;

	        for (i = 0; i < filters.length - 1; ++i) {
	          filters[i].apply(this, flip, flop, true);

	          var t = flip;

	          flip = flop;
	          flop = t;
	        }

	        filters[i].apply(this, flip, lastState.renderTarget, true);

	        this.freePotRenderTarget(flip);
	        this.freePotRenderTarget(flop);
	      }

	      filterData.index--;

	      if (filterData.index === 0) {
	        this.filterData = null;
	      }
	    }

	    /**
	     * Draws a filter.
	     *
	     * @param {Tiny.Filter} filter - The filter to draw.
	     * @param {Tiny.RenderTarget} input - The input render target.
	     * @param {Tiny.RenderTarget} output - The target to output to.
	     * @param {boolean} clear - Should the output be cleared before rendering to it
	     */

	  }, {
	    key: 'applyFilter',
	    value: function applyFilter(filter, input, output, clear) {
	      var renderer = this.renderer;
	      var gl = renderer.gl;

	      var shader = filter.glShaders[renderer.CONTEXT_UID];

	      // cacheing..
	      if (!shader) {
	        if (filter.glShaderKey) {
	          shader = this.shaderCache[filter.glShaderKey];

	          if (!shader) {
	            shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);

	            filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;
	          }
	        } else {
	          shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
	        }

	        // TODO - this only needs to be done once?
	        renderer.bindVao(null);

	        this.quad.initVao(shader);
	      }

	      renderer.bindVao(this.quad.vao);

	      renderer.bindRenderTarget(output);

	      if (clear) {
	        gl.disable(gl.SCISSOR_TEST);
	        renderer.clear(); // [1, 1, 1, 1]);
	        gl.enable(gl.SCISSOR_TEST);
	      }

	      // in case the render target is being masked using a scissor rect
	      if (output === renderer.maskManager.scissorRenderTarget) {
	        renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);
	      }

	      renderer.bindShader(shader);

	      // free unit 0 for us, doesn't matter what was there
	      // don't try to restore it, because syncUniforms can upload it to another slot
	      // and it'll be a problem
	      var tex = this.renderer.emptyTextures[0];

	      this.renderer.boundTextures[0] = tex;
	      // this syncs the Tiny filters  uniforms with glsl uniforms
	      this.syncUniforms(shader, filter);

	      renderer.state.setBlendMode(filter.blendMode);

	      gl.activeTexture(gl.TEXTURE0);
	      gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);

	      this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);

	      gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
	    }

	    /**
	     * Uploads the uniforms of the filter.
	     *
	     * @param {GLShader} shader - The underlying gl shader.
	     * @param {Tiny.Filter} filter - The filter we are synchronizing.
	     */

	  }, {
	    key: 'syncUniforms',
	    value: function syncUniforms(shader, filter) {
	      var uniformData = filter.uniformData;
	      var uniforms = filter.uniforms;

	      // 0 is reserved for the pixi texture so we start at 1!
	      var textureCount = 1;
	      var currentState = void 0;

	      if (shader.uniforms.data.filterArea) {
	        currentState = this.filterData.stack[this.filterData.index];
	        var filterArea = shader.uniforms.filterArea;

	        filterArea[0] = currentState.renderTarget.size.width;
	        filterArea[1] = currentState.renderTarget.size.height;
	        filterArea[2] = currentState.sourceFrame.x;
	        filterArea[3] = currentState.sourceFrame.y;

	        shader.uniforms.filterArea = filterArea;
	      }

	      // use this to clamp displaced texture coords so they belong to filterArea
	      // see displacementFilter fragment shader for an example
	      if (shader.uniforms.data.filterClamp) {
	        currentState = this.filterData.stack[this.filterData.index];

	        var filterClamp = shader.uniforms.filterClamp;

	        filterClamp[0] = 0;
	        filterClamp[1] = 0;
	        filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
	        filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;

	        shader.uniforms.filterClamp = filterClamp;
	      }

	      // TODO Cacheing layer..
	      for (var i in uniformData) {
	        if (uniformData[i].type === 'sampler2D' && uniforms[i] !== 0) {
	          if (uniforms[i].baseTexture) {
	            shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);
	          } else {
	            shader.uniforms[i] = textureCount;

	            // TODO
	            // this is helpful as renderTargets can also be set.
	            // Although thinking about it, we could probably
	            // make the filter texture cache return a RenderTexture
	            // rather than a renderTarget
	            var gl = this.renderer.gl;

	            this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
	            gl.activeTexture(gl.TEXTURE0 + textureCount);

	            uniforms[i].texture.bind();
	          }

	          textureCount++;
	        } else if (uniformData[i].type === 'mat3') {
	          // check if its Tiny matrix..
	          if (uniforms[i].a !== undefined) {
	            shader.uniforms[i] = uniforms[i].toArray(true);
	          } else {
	            shader.uniforms[i] = uniforms[i];
	          }
	        } else if (uniformData[i].type === 'vec2') {
	          // check if its a point..
	          if (uniforms[i].x !== undefined) {
	            var val = shader.uniforms[i] || new Float32Array(2);

	            val[0] = uniforms[i].x;
	            val[1] = uniforms[i].y;
	            shader.uniforms[i] = val;
	          } else {
	            shader.uniforms[i] = uniforms[i];
	          }
	        } else if (uniformData[i].type === 'float') {
	          if (shader.uniforms.data[i].value !== uniformData[i]) {
	            shader.uniforms[i] = uniforms[i];
	          }
	        } else {
	          shader.uniforms[i] = uniforms[i];
	        }
	      }
	    }

	    /**
	     * Gets a render target from the pool, or creates a new one.
	     *
	     * @param {boolean} clear - Should we clear the render texture when we get it?
	     * @param {number} resolution - The resolution of the target.
	     * @return {Tiny.RenderTarget} The new render target
	     */

	  }, {
	    key: 'getRenderTarget',
	    value: function getRenderTarget(clear, resolution) {
	      var currentState = this.filterData.stack[this.filterData.index];
	      var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);

	      renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);

	      return renderTarget;
	    }

	    /**
	     * Returns a render target to the pool.
	     *
	     * @param {Tiny.RenderTarget} renderTarget - The render target to return.
	     */

	  }, {
	    key: 'returnRenderTarget',
	    value: function returnRenderTarget(renderTarget) {
	      this.freePotRenderTarget(renderTarget);
	    }

	    /**
	     * Calculates the mapped matrix.
	     *
	     * TODO playing around here.. this is temporary - (will end up in the shader)
	     * this returns a matrix that will normalise map filter cords in the filter to screen space
	     *
	     * @param {Tiny.Matrix} outputMatrix - the matrix to output to.
	     * @return {Tiny.Matrix} The mapped matrix.
	     */

	  }, {
	    key: 'calculateScreenSpaceMatrix',
	    value: function calculateScreenSpaceMatrix(outputMatrix) {
	      var currentState = this.filterData.stack[this.filterData.index];

	      return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);
	    }

	    /**
	     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea
	     *
	     * @param {Tiny.Matrix} outputMatrix - The matrix to output to.
	     * @return {Tiny.Matrix} The mapped matrix.
	     */

	  }, {
	    key: 'calculateNormalizedScreenSpaceMatrix',
	    value: function calculateNormalizedScreenSpaceMatrix(outputMatrix) {
	      var currentState = this.filterData.stack[this.filterData.index];

	      return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);
	    }

	    /**
	     * This will map the filter coord so that a texture can be used based on the transform of a sprite
	     *
	     * @param {Tiny.Matrix} outputMatrix - The matrix to output to.
	     * @param {Tiny.Sprite} sprite - The sprite to map to.
	     * @return {Tiny.Matrix} The mapped matrix.
	     */

	  }, {
	    key: 'calculateSpriteMatrix',
	    value: function calculateSpriteMatrix(outputMatrix, sprite) {
	      var currentState = this.filterData.stack[this.filterData.index];

	      return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);
	    }

	    /**
	     * Destroys this Filter Manager.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.shaderCache = [];
	      this.emptyPool();
	    }

	    /**
	     * Gets a Power-of-Two render texture.
	     *
	     * TODO move to a seperate class could be on renderer?
	     * also - could cause issue with multiple contexts?
	     *
	     * @private
	     * @param {WebGLRenderingContext} gl - The webgl rendering context
	     * @param {number} minWidth - The minimum width of the render target.
	     * @param {number} minHeight - The minimum height of the render target.
	     * @param {number} resolution - The resolution of the render target.
	     * @return {Tiny.RenderTarget} The new render target.
	     */

	  }, {
	    key: 'getPotRenderTarget',
	    value: function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
	      // TODO you could return a bigger texture if there is not one in the pool?
	      minWidth = _bitTwiddle2.default.nextPow2(minWidth * resolution);
	      minHeight = _bitTwiddle2.default.nextPow2(minHeight * resolution);

	      var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;

	      if (!this.pool[key]) {
	        this.pool[key] = [];
	      }

	      var renderTarget = this.pool[key].pop();

	      // creating render target will cause texture to be bound!
	      if (!renderTarget) {
	        // temporary bypass cache..
	        var tex = this.renderer.boundTextures[0];

	        gl.activeTexture(gl.TEXTURE0);

	        // internally - this will cause a texture to be bound..
	        renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);

	        // set the current one back
	        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
	      }

	      // manually tweak the resolution...
	      // this will not modify the size of the frame buffer, just its resolution.
	      renderTarget.resolution = resolution;
	      renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
	      renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;

	      return renderTarget;
	    }

	    /**
	     * Empties the texture pool.
	     *
	     */

	  }, {
	    key: 'emptyPool',
	    value: function emptyPool() {
	      for (var i in this.pool) {
	        var textures = this.pool[i];

	        if (textures) {
	          for (var j = 0; j < textures.length; j++) {
	            textures[j].destroy(true);
	          }
	        }
	      }

	      this.pool = {};
	    }

	    /**
	     * Frees a render target back into the pool.
	     *
	     * @param {Tiny.RenderTarget} renderTarget - The renderTarget to free
	     */

	  }, {
	    key: 'freePotRenderTarget',
	    value: function freePotRenderTarget(renderTarget) {
	      var minWidth = renderTarget.size.width * renderTarget.resolution;
	      var minHeight = renderTarget.size.height * renderTarget.resolution;
	      var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;

	      this.pool[key].push(renderTarget);
	    }
	  }]);

	  return FilterManager;
	}(_WebGLManager3.default);

	exports.default = FilterManager;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _math = __webpack_require__(8);

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _pixiGlCore = __webpack_require__(28);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var RenderTarget = function () {
	  /**
	   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
	   * @param {number} [width=0] - the horizontal range of the filter
	   * @param {number} [height=0] - the vertical range of the filter
	   * @param {number} [scaleMode=Tiny.settings.SCALE_MODE] - See {@link Tiny.SCALE_MODES} for possible values
	   * @param {number} [resolution=1] - The current resolution / device pixel ratio
	   * @param {boolean} [root=false] - Whether this object is the root element or not
	   */
	  function RenderTarget(gl, width, height, scaleMode, resolution, root) {
	    _classCallCheck(this, RenderTarget);

	    // TODO Resolution could go here ( eg low res blurs )

	    /**
	     * The current WebGL drawing context.
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    // next time to create a frame buffer and texture

	    /**
	     * A frame buffer
	     *
	     * @member {Tiny.glCore.GLFramebuffer}
	     */
	    this.frameBuffer = null;

	    /**
	     * The texture
	     *
	     * @member {Tiny.glCore.GLTexture}
	     */
	    this.texture = null;

	    /**
	     * The background colour of this render target, as an array of [r,g,b,a] values
	     *
	     * @member {number[]}
	     */
	    this.clearColor = [0, 0, 0, 0];

	    /**
	     * The size of the object as a rectangle
	     *
	     * @member {Tiny.Rectangle}
	     */
	    this.size = new _math.Rectangle(0, 0, 1, 1);

	    /**
	     * The current resolution / device pixel ratio
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.resolution = resolution || _settings2.default.RESOLUTION;

	    /**
	     * The projection matrix
	     *
	     * @member {Tiny.Matrix}
	     */
	    this.projectionMatrix = new _math.Matrix();

	    /**
	     * The object's transform
	     *
	     * @member {Tiny.Matrix}
	     */
	    this.transform = null;

	    /**
	     * The frame.
	     *
	     * @member {Tiny.Rectangle}
	     */
	    this.frame = null;

	    /**
	     * The stencil buffer stores masking data for the render target
	     *
	     * @member {glCore.GLBuffer}
	     */
	    this.defaultFrame = new _math.Rectangle();
	    this.destinationFrame = null;
	    this.sourceFrame = null;

	    /**
	     * The stencil buffer stores masking data for the render target
	     *
	     * @member {glCore.GLBuffer}
	     */
	    this.stencilBuffer = null;

	    /**
	     * The data structure for the stencil masks
	     *
	     * @member {Tiny.Graphics[]}
	     */
	    this.stencilMaskStack = [];

	    /**
	     * Stores filter data for the render target
	     *
	     * @member {object[]}
	     */
	    this.filterData = null;

	    /**
	     * The scale mode.
	     *
	     * @member {number}
	     * @default Tiny.settings.SCALE_MODE
	     * @see Tiny.SCALE_MODES
	     */
	    this.scaleMode = scaleMode || _settings2.default.SCALE_MODE;

	    /**
	     * Whether this object is the root element or not
	     *
	     * @member {boolean}
	     */
	    this.root = root;

	    if (!this.root) {
	      this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);

	      if (this.scaleMode === _const.SCALE_MODES.NEAREST) {
	        this.frameBuffer.texture.enableNearestScaling();
	      } else {
	        this.frameBuffer.texture.enableLinearScaling();
	      }
	      /*
	       A frame buffer needs a target to render to..
	       create a texture and bind it attach it to the framebuffer..
	       */

	      // this is used by the base texture
	      this.texture = this.frameBuffer.texture;
	    } else {
	      // make it a null framebuffer..
	      this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
	      this.frameBuffer.framebuffer = null;
	    }

	    this.setFrame();

	    this.resize(width, height);
	  }

	  /**
	   * Clears the filter texture.
	   *
	   * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
	   */


	  _createClass(RenderTarget, [{
	    key: 'clear',
	    value: function clear(clearColor) {
	      var cc = clearColor || this.clearColor;

	      this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
	    }

	    /**
	     * Binds the stencil buffer.
	     *
	     */

	  }, {
	    key: 'attachStencilBuffer',
	    value: function attachStencilBuffer() {
	      // TODO check if stencil is done?
	      /**
	       * The stencil buffer is used for masking in Tiny
	       * lets create one and then add attach it to the framebuffer..
	       */
	      if (!this.root) {
	        this.frameBuffer.enableStencil();
	      }
	    }

	    /**
	     * Sets the frame of the render target.
	     *
	     * @param {Rectangle} destinationFrame - The destination frame.
	     * @param {Rectangle} sourceFrame - The source frame.
	     */

	  }, {
	    key: 'setFrame',
	    value: function setFrame(destinationFrame, sourceFrame) {
	      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
	      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
	    }

	    /**
	     * Binds the buffers and initialises the viewport.
	     *
	     */

	  }, {
	    key: 'activate',
	    value: function activate() {
	      // TOOD refactor usage of frame..
	      var gl = this.gl;

	      // make sure the texture is unbound!
	      this.frameBuffer.bind();

	      this.calculateProjection(this.destinationFrame, this.sourceFrame);

	      if (this.transform) {
	        this.projectionMatrix.append(this.transform);
	      }

	      // TODO add a check as them may be the same!
	      if (this.destinationFrame !== this.sourceFrame) {
	        gl.enable(gl.SCISSOR_TEST);
	        gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
	      } else {
	        gl.disable(gl.SCISSOR_TEST);
	      }

	      // TODO - does not need to be updated all the time??
	      gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
	    }

	    /**
	     * Updates the projection matrix based on a projection frame (which is a rectangle)
	     *
	     * @param {Rectangle} destinationFrame - The destination frame.
	     * @param {Rectangle} sourceFrame - The source frame.
	     */

	  }, {
	    key: 'calculateProjection',
	    value: function calculateProjection(destinationFrame, sourceFrame) {
	      var pm = this.projectionMatrix;

	      sourceFrame = sourceFrame || destinationFrame;

	      pm.identity();

	      // TODO: make dest scale source
	      if (!this.root) {
	        pm.a = 1 / destinationFrame.width * 2;
	        pm.d = 1 / destinationFrame.height * 2;

	        pm.tx = -1 - sourceFrame.x * pm.a;
	        pm.ty = -1 - sourceFrame.y * pm.d;
	      } else {
	        pm.a = 1 / destinationFrame.width * 2;
	        pm.d = -1 / destinationFrame.height * 2;

	        pm.tx = -1 - sourceFrame.x * pm.a;
	        pm.ty = 1 - sourceFrame.y * pm.d;
	      }
	    }

	    /**
	     * Resizes the texture to the specified width and height
	     *
	     * @param {number} width - the new width of the texture
	     * @param {number} height - the new height of the texture
	     */

	  }, {
	    key: 'resize',
	    value: function resize(width, height) {
	      width = width | 0;
	      height = height | 0;

	      if (this.size.width === width && this.size.height === height) {
	        return;
	      }

	      this.size.width = width;
	      this.size.height = height;

	      this.defaultFrame.width = width;
	      this.defaultFrame.height = height;

	      this.frameBuffer.resize(width * this.resolution, height * this.resolution);

	      var projectionFrame = this.frame || this.size;

	      this.calculateProjection(projectionFrame);
	    }

	    /**
	     * Destroys the render target.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.frameBuffer.destroy();

	      this.frameBuffer = null;
	      this.texture = null;
	    }
	  }]);

	  return RenderTarget;
	}();

	exports.default = RenderTarget;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	var _createIndicesForQuads = __webpack_require__(92);

	var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Helper class to create a quad
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Quad = function () {
	  /**
	   * @param {WebGLRenderingContext} gl - The gl context for this quad to use.
	   * @param {object} state - TODO: Description
	   */
	  function Quad(gl, state) {
	    _classCallCheck(this, Quad);

	    /*
	     * the current WebGL drawing context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    /**
	     * An array of vertices
	     *
	     * @member {Float32Array}
	     */
	    this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);

	    /**
	     * The Uvs of the quad
	     *
	     * @member {Float32Array}
	     */
	    this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

	    this.interleaved = new Float32Array(8 * 2);

	    for (var i = 0; i < 4; i++) {
	      this.interleaved[i * 4] = this.vertices[i * 2];
	      this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
	      this.interleaved[i * 4 + 2] = this.uvs[i * 2];
	      this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
	    }

	    /*
	     * @member {Uint16Array} An array containing the indices of the vertices
	     */
	    this.indices = (0, _createIndicesForQuads2.default)(1);

	    /*
	     * @member {glCore.GLBuffer} The vertex buffer
	     */
	    this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);

	    /*
	     * @member {glCore.GLBuffer} The index buffer
	     */
	    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

	    /*
	     * @member {glCore.VertexArrayObject} The index buffer
	     */
	    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
	  }

	  /**
	   * Initialises the vaos and uses the shader.
	   *
	   * @param {Tiny.Shader} shader - the shader to use
	   */


	  _createClass(Quad, [{
	    key: 'initVao',
	    value: function initVao(shader) {
	      this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
	    }

	    /**
	     * Maps two Rectangle to the quad.
	     *
	     * @param {Tiny.Rectangle} targetTextureFrame - the first rectangle
	     * @param {Tiny.Rectangle} destinationFrame - the second rectangle
	     * @return {Tiny.Quad} Returns itself.
	     */

	  }, {
	    key: 'map',
	    value: function map(targetTextureFrame, destinationFrame) {
	      var x = 0; // destinationFrame.x / targetTextureFrame.width;
	      var y = 0; // destinationFrame.y / targetTextureFrame.height;

	      this.uvs[0] = x;
	      this.uvs[1] = y;

	      this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
	      this.uvs[3] = y;

	      this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
	      this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;

	      this.uvs[6] = x;
	      this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;

	      x = destinationFrame.x;
	      y = destinationFrame.y;

	      this.vertices[0] = x;
	      this.vertices[1] = y;

	      this.vertices[2] = x + destinationFrame.width;
	      this.vertices[3] = y;

	      this.vertices[4] = x + destinationFrame.width;
	      this.vertices[5] = y + destinationFrame.height;

	      this.vertices[6] = x;
	      this.vertices[7] = y + destinationFrame.height;

	      return this;
	    }

	    /**
	     * Binds the buffer and uploads the data
	     *
	     * @return {Tiny.Quad} Returns itself.
	     */

	  }, {
	    key: 'upload',
	    value: function upload() {
	      for (var i = 0; i < 4; i++) {
	        this.interleaved[i * 4] = this.vertices[i * 2];
	        this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
	        this.interleaved[i * 4 + 2] = this.uvs[i * 2];
	        this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
	      }

	      this.vertexBuffer.upload(this.interleaved);

	      return this;
	    }

	    /**
	     * Removes this quad from WebGL
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      var gl = this.gl;

	      gl.deleteBuffer(this.vertexBuffer);
	      gl.deleteBuffer(this.indexBuffer);
	    }
	  }]);

	  return Quad;
	}();

	exports.default = Quad;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createIndicesForQuads;
	/**
	 * Generic Mask Stack data structure
	 *
	 * @memberof Tiny
	 * @function createIndicesForQuads
	 * @private
	 * @param {number} size - Number of quads
	 * @return {Uint16Array} indices
	 */
	function createIndicesForQuads(size) {
	  // the total number of indices in our array, there are 6 points per quad.

	  var totalIndices = size * 6;

	  var indices = new Uint16Array(totalIndices);

	  // fill the indices with the quads to draw
	  for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
	    indices[i + 0] = j + 0;
	    indices[i + 1] = j + 1;
	    indices[i + 2] = j + 2;
	    indices[i + 3] = j + 0;
	    indices[i + 4] = j + 2;
	    indices[i + 5] = j + 3;
	  }

	  return indices;
	}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _pixiGlCore = __webpack_require__(28);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PRECISION = _settings2.default.PRECISION;


	function checkPrecision(src) {
	  if (src instanceof Array) {
	    if (src[0].substring(0, 9) !== 'precision') {
	      var copy = src.slice(0);

	      copy.unshift('precision ' + PRECISION + ' float;');

	      return copy;
	    }
	  } else if (src.substring(0, 9) !== 'precision') {
	    return 'precision ' + PRECISION + ' float;\n' + src;
	  }

	  return src;
	}

	/**
	 * Wrapper class, webGL Shader for Tiny.
	 * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
	 *
	 * @class
	 * @extends GLShader
	 * @memberof Tiny
	 */

	var Shader = function (_GLShader) {
	  _inherits(Shader, _GLShader);

	  /**
	   *
	   * @param {WebGLRenderingContext} gl - The current WebGL rendering context
	   * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
	   * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
	   */
	  function Shader(gl, vertexSrc, fragmentSrc) {
	    _classCallCheck(this, Shader);

	    return _possibleConstructorReturn(this, (Shader.__proto__ || Object.getPrototypeOf(Shader)).call(this, gl, checkPrecision(vertexSrc), checkPrecision(fragmentSrc)));
	  }

	  return Shader;
	}(_pixiGlCore.GLShader);

	exports.default = Shader;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
	exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
	exports.calculateSpriteMatrix = calculateSpriteMatrix;

	var _math = __webpack_require__(8);

	/*
	 * Calculates the mapped matrix
	 * @param filterArea {Rectangle} The filter area
	 * @param sprite {Sprite} the target sprite
	 * @param outputMatrix {Matrix} @alvin
	 */
	// TODO playing around here.. this is temporary - (will end up in the shader)
	// this returns a matrix that will normalise map filter cords in the filter to screen space
	function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
	  // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),
	  // let texture = {width:1136, height:700};//sprite._texture.baseTexture;

	  // TODO unwrap?
	  var mappedMatrix = outputMatrix.identity();

	  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

	  mappedMatrix.scale(textureSize.width, textureSize.height);

	  return mappedMatrix;
	}

	function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
	  var mappedMatrix = outputMatrix.identity();

	  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

	  var translateScaleX = textureSize.width / filterArea.width;
	  var translateScaleY = textureSize.height / filterArea.height;

	  mappedMatrix.scale(translateScaleX, translateScaleY);

	  return mappedMatrix;
	}

	// this will map the filter coord so that a texture can be used based on the transform of a sprite
	function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
	  var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);
	  var texture = sprite._texture.baseTexture;

	  // TODO unwrap?
	  var mappedMatrix = outputMatrix.identity();

	  // scale..
	  var ratio = textureSize.height / textureSize.width;

	  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);

	  mappedMatrix.scale(1, ratio);

	  var translateScaleX = textureSize.width / texture.width;
	  var translateScaleY = textureSize.height / texture.height;

	  worldTransform.tx /= texture.width * translateScaleX;

	  // this...?  free beer for anyone who can explain why this makes sense!
	  worldTransform.ty /= texture.width * translateScaleX;
	  // worldTransform.ty /= texture.height * translateScaleY;

	  worldTransform.invert();
	  mappedMatrix.prepend(worldTransform);

	  // apply inverse scale..
	  mappedMatrix.scale(1, 1 / ratio);

	  mappedMatrix.scale(translateScaleX, translateScaleY);

	  mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

	  return mappedMatrix;
	}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _pixiGlCore = __webpack_require__(28);

	var _const = __webpack_require__(7);

	var _RenderTarget = __webpack_require__(90);

	var _RenderTarget2 = _interopRequireDefault(_RenderTarget);

	var _utils = __webpack_require__(18);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Helper class to create a webGL Texture
	 *
	 * @class
	 * @memberof Tiny
	 */
	var TextureManager = function () {
	  /**
	   * @param {Tiny.WebGLRenderer} renderer - A reference to the current renderer
	   */
	  function TextureManager(renderer) {
	    _classCallCheck(this, TextureManager);

	    /**
	     * A reference to the current renderer
	     *
	     * @member {Tiny.WebGLRenderer}
	     */
	    this.renderer = renderer;

	    /**
	     * The current WebGL rendering context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = renderer.gl;

	    /**
	     * Track textures in the renderer so we can no longer listen to them on destruction.
	     *
	     * @member {Array<*>}
	     * @private
	     */
	    this._managedTextures = [];
	  }

	  /**
	   * Binds a texture.
	   *
	   */


	  _createClass(TextureManager, [{
	    key: 'bindTexture',
	    value: function bindTexture() {}
	    // empty


	    /**
	     * Gets a texture.
	     *
	     */

	  }, {
	    key: 'getTexture',
	    value: function getTexture() {}
	    // empty


	    /**
	     * Updates and/or Creates a WebGL texture for the renderer's context.
	     *
	     * @param {Tiny.BaseTexture|Tiny.Texture} texture - the texture to update
	     * @param {Number} location - the location the texture will be bound to.
	     * @return {GLTexture} The gl texture.
	     */

	  }, {
	    key: 'updateTexture',
	    value: function updateTexture(texture, location) {
	      // assume it good!
	      // texture = texture.baseTexture || texture;

	      var gl = this.gl;

	      var isRenderTexture = !!texture._glRenderTargets;

	      if (!texture.hasLoaded) {
	        return null;
	      }

	      var boundTextures = this.renderer.boundTextures;

	      // if the location is undefined then this may have been called by n event.
	      // this being the case the texture may already be bound to a slot. As a texture can only be bound once
	      // we need to find its current location if it exists.
	      if (location === undefined) {
	        location = 0;

	        // TODO maybe we can use texture bound ids later on...
	        // check if texture is already bound..
	        for (var i = 0; i < boundTextures.length; ++i) {
	          if (boundTextures[i] === texture) {
	            location = i;
	            break;
	          }
	        }
	      }

	      boundTextures[location] = texture;

	      gl.activeTexture(gl.TEXTURE0 + location);

	      var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];

	      if (!glTexture) {
	        if (isRenderTexture) {
	          var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);

	          renderTarget.resize(texture.width, texture.height);
	          texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
	          glTexture = renderTarget.texture;
	        } else {
	          glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
	          glTexture.bind(location);
	          glTexture.premultiplyAlpha = true;
	          glTexture.upload(texture.source);
	        }

	        texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;

	        texture.on('update', this.updateTexture, this);
	        texture.on('dispose', this.destroyTexture, this);

	        this._managedTextures.push(texture);

	        if (texture.isPowerOfTwo) {
	          if (texture.mipmap) {
	            glTexture.enableMipmap();
	          }

	          if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {
	            glTexture.enableWrapClamp();
	          } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {
	            glTexture.enableWrapRepeat();
	          } else {
	            glTexture.enableWrapMirrorRepeat();
	          }
	        } else {
	          glTexture.enableWrapClamp();
	        }

	        if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {
	          glTexture.enableNearestScaling();
	        } else {
	          glTexture.enableLinearScaling();
	        }
	      }
	      // the texture already exists so we only need to update it..
	      else if (isRenderTexture) {
	          texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);
	        } else {
	          glTexture.upload(texture.source);
	        }

	      return glTexture;
	    }

	    /**
	     * Deletes the texture from WebGL
	     *
	     * @param {Tiny.BaseTexture|Tiny.Texture} texture - the texture to destroy
	     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
	     */

	  }, {
	    key: 'destroyTexture',
	    value: function destroyTexture(texture, skipRemove) {
	      texture = texture.baseTexture || texture;

	      if (!texture.hasLoaded) {
	        return;
	      }

	      if (texture._glTextures[this.renderer.CONTEXT_UID]) {
	        this.renderer.unbindTexture(texture);

	        texture._glTextures[this.renderer.CONTEXT_UID].destroy();
	        texture.off('update', this.updateTexture, this);
	        texture.off('dispose', this.destroyTexture, this);

	        delete texture._glTextures[this.renderer.CONTEXT_UID];

	        if (!skipRemove) {
	          var i = this._managedTextures.indexOf(texture);

	          if (i !== -1) {
	            (0, _utils.removeItems)(this._managedTextures, i, 1);
	          }
	        }
	      }
	    }

	    /**
	     * Deletes all the textures from WebGL
	     */

	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      // empty all the old gl textures as they are useless now
	      for (var i = 0; i < this._managedTextures.length; ++i) {
	        var texture = this._managedTextures[i];

	        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
	          delete texture._glTextures[this.renderer.CONTEXT_UID];
	        }
	      }
	    }

	    /**
	     * Destroys this manager and removes all its textures
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      // destroy managed textures
	      for (var i = 0; i < this._managedTextures.length; ++i) {
	        var texture = this._managedTextures[i];

	        this.destroyTexture(texture, true);

	        texture.off('update', this.updateTexture, this);
	        texture.off('dispose', this.destroyTexture, this);
	      }

	      this._managedTextures = null;
	    }
	  }]);

	  return TextureManager;
	}();

	exports.default = TextureManager;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged
	 * up with textures that are no longer being used.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var TextureGarbageCollector = function () {
	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this manager works for.
	   */
	  function TextureGarbageCollector(renderer) {
	    _classCallCheck(this, TextureGarbageCollector);

	    this.renderer = renderer;

	    this.count = 0;
	    this.checkCount = 0;
	    this.maxIdle = _settings2.default.GC_MAX_IDLE;
	    this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
	    this.mode = _settings2.default.GC_MODE;
	  }

	  /**
	   * Checks to see when the last time a texture was used
	   * if the texture has not been used for a specified amount of time it will be removed from the GPU
	   */


	  _createClass(TextureGarbageCollector, [{
	    key: 'update',
	    value: function update() {
	      this.count++;

	      if (this.mode === _const.GC_MODES.MANUAL) {
	        return;
	      }

	      this.checkCount++;

	      if (this.checkCount > this.checkCountMax) {
	        this.checkCount = 0;

	        this.run();
	      }
	    }

	    /**
	     * Checks to see when the last time a texture was used
	     * if the texture has not been used for a specified amount of time it will be removed from the GPU
	     */

	  }, {
	    key: 'run',
	    value: function run() {
	      var tm = this.renderer.textureManager;
	      var managedTextures = tm._managedTextures;
	      var wasRemoved = false;

	      for (var i = 0; i < managedTextures.length; i++) {
	        var texture = managedTextures[i];

	        // only supports non generated textures at the moment!
	        if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {
	          tm.destroyTexture(texture, true);
	          managedTextures[i] = null;
	          wasRemoved = true;
	        }
	      }

	      if (wasRemoved) {
	        var j = 0;

	        for (var _i = 0; _i < managedTextures.length; _i++) {
	          if (managedTextures[_i] !== null) {
	            managedTextures[j++] = managedTextures[_i];
	          }
	        }

	        managedTextures.length = j;
	      }
	    }

	    /**
	     * Removes all the textures within the specified displayObject and its children from the GPU
	     *
	     * @param {Tiny.DisplayObject} displayObject - the displayObject to remove the textures from.
	     */

	  }, {
	    key: 'unload',
	    value: function unload(displayObject) {
	      var tm = this.renderer.textureManager;

	      // only destroy non generated textures
	      if (displayObject._texture && displayObject._texture._glRenderTargets) {
	        tm.destroyTexture(displayObject._texture, true);
	      }

	      for (var i = displayObject.children.length - 1; i >= 0; i--) {
	        this.unload(displayObject.children[i]);
	      }
	    }
	  }]);

	  return TextureGarbageCollector;
	}();

	exports.default = TextureGarbageCollector;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mapWebGLBlendModesToTiny = __webpack_require__(98);

	var _mapWebGLBlendModesToTiny2 = _interopRequireDefault(_mapWebGLBlendModesToTiny);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var BLEND = 0;
	var DEPTH_TEST = 1;
	var FRONT_FACE = 2;
	var CULL_FACE = 3;
	var BLEND_FUNC = 4;

	/**
	 * A WebGL state machines
	 *
	 * @memberof Tiny
	 * @class
	 */

	var WebGLState = function () {
	  /**
	   * @param {WebGLRenderingContext} gl - The current WebGL rendering context
	   */
	  function WebGLState(gl) {
	    _classCallCheck(this, WebGLState);

	    /**
	     * The current active state
	     *
	     * @member {Uint8Array}
	     */
	    this.activeState = new Uint8Array(16);

	    /**
	     * The default state
	     *
	     * @member {Uint8Array}
	     */
	    this.defaultState = new Uint8Array(16);

	    // default blend mode..
	    this.defaultState[0] = 1;

	    /**
	     * The current state index in the stack
	     *
	     * @member {number}
	     * @private
	     */
	    this.stackIndex = 0;

	    /**
	     * The stack holding all the different states
	     *
	     * @member {Array<*>}
	     * @private
	     */
	    this.stack = [];

	    /**
	     * The current WebGL rendering context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

	    this.attribState = {
	      tempAttribState: new Array(this.maxAttribs),
	      attribState: new Array(this.maxAttribs)
	    };

	    this.blendModes = (0, _mapWebGLBlendModesToTiny2.default)(gl);

	    // check we have vao..
	    this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
	  }

	  /**
	   * Pushes a new active state
	   */


	  _createClass(WebGLState, [{
	    key: 'push',
	    value: function push() {
	      // next state..
	      var state = this.stack[++this.stackIndex];

	      if (!state) {
	        state = this.stack[this.stackIndex] = new Uint8Array(16);
	      }

	      // copy state..
	      // set active state so we can force overrides of gl state
	      for (var i = 0; i < this.activeState.length; i++) {
	        this.activeState[i] = state[i];
	      }
	    }

	    /**
	     * Pops a state out
	     */

	  }, {
	    key: 'pop',
	    value: function pop() {
	      var state = this.stack[--this.stackIndex];

	      this.setState(state);
	    }

	    /**
	     * Sets the current state
	     *
	     * @param {*} state - The state to set.
	     */

	  }, {
	    key: 'setState',
	    value: function setState(state) {
	      this.setBlend(state[BLEND]);
	      this.setDepthTest(state[DEPTH_TEST]);
	      this.setFrontFace(state[FRONT_FACE]);
	      this.setCullFace(state[CULL_FACE]);
	      this.setBlendMode(state[BLEND_FUNC]);
	    }

	    /**
	     * Enables or disabled blending.
	     *
	     * @param {boolean} value - Turn on or off webgl blending.
	     */

	  }, {
	    key: 'setBlend',
	    value: function setBlend(value) {
	      value = value ? 1 : 0;

	      if (this.activeState[BLEND] === value) {
	        return;
	      }

	      this.activeState[BLEND] = value;
	      this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
	    }

	    /**
	     * Sets the blend mode.
	     *
	     * @param {number} value - The blend mode to set to.
	     */

	  }, {
	    key: 'setBlendMode',
	    value: function setBlendMode(value) {
	      if (value === this.activeState[BLEND_FUNC]) {
	        return;
	      }

	      this.activeState[BLEND_FUNC] = value;

	      this.gl.blendFunc(this.blendModes[value][0], this.blendModes[value][1]);
	    }

	    /**
	     * Sets whether to enable or disable depth test.
	     *
	     * @param {boolean} value - Turn on or off webgl depth testing.
	     */

	  }, {
	    key: 'setDepthTest',
	    value: function setDepthTest(value) {
	      value = value ? 1 : 0;

	      if (this.activeState[DEPTH_TEST] === value) {
	        return;
	      }

	      this.activeState[DEPTH_TEST] = value;
	      this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
	    }

	    /**
	     * Sets whether to enable or disable cull face.
	     *
	     * @param {boolean} value - Turn on or off webgl cull face.
	     */

	  }, {
	    key: 'setCullFace',
	    value: function setCullFace(value) {
	      value = value ? 1 : 0;

	      if (this.activeState[CULL_FACE] === value) {
	        return;
	      }

	      this.activeState[CULL_FACE] = value;
	      this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
	    }

	    /**
	     * Sets the gl front face.
	     *
	     * @param {boolean} value - true is clockwise and false is counter-clockwise
	     */

	  }, {
	    key: 'setFrontFace',
	    value: function setFrontFace(value) {
	      value = value ? 1 : 0;

	      if (this.activeState[FRONT_FACE] === value) {
	        return;
	      }

	      this.activeState[FRONT_FACE] = value;
	      this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
	    }

	    /**
	     * Disables all the vaos in use
	     *
	     */

	  }, {
	    key: 'resetAttributes',
	    value: function resetAttributes() {
	      for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
	        this.attribState.tempAttribState[i] = 0;
	      }

	      for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
	        this.attribState.attribState[_i] = 0;
	      }

	      // im going to assume one is always active for performance reasons.
	      for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
	        this.gl.disableVertexAttribArray(_i2);
	      }
	    }

	    // used
	    /**
	     * Resets all the logic and disables the vaos
	     */

	  }, {
	    key: 'resetToDefault',
	    value: function resetToDefault() {
	      // unbind any VAO if they exist..
	      if (this.nativeVaoExtension) {
	        this.nativeVaoExtension.bindVertexArrayOES(null);
	      }

	      // reset all attributes..
	      this.resetAttributes();

	      // set active state so we can force overrides of gl state
	      for (var i = 0; i < this.activeState.length; ++i) {
	        this.activeState[i] = 32;
	      }

	      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

	      this.setState(this.defaultState);
	    }
	  }]);

	  return WebGLState;
	}();

	exports.default = WebGLState;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = mapWebGLBlendModesToTiny;

	var _const = __webpack_require__(7);

	/**
	 * Maps gl blend combinations to WebGL.
	 *
	 * @memberof Tiny
	 * @function mapWebGLBlendModesToTiny
	 * @private
	 * @param {WebGLRenderingContext} gl - The rendering context.
	 * @param {string[]} [array=[]] - The array to output into.
	 * @return {string[]} Mapped modes.
	 */
	function mapWebGLBlendModesToTiny(gl) {
	  var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	  // TODO - premultiply alpha would be different.
	  // add a boolean for that!
	  array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA];
	  array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
	  array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
	  array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

	  return array;
	}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = mapWebGLDrawModesToTiny;

	var _const = __webpack_require__(7);

	/**
	 * Generic Mask Stack data structure.
	 *
	 * @memberof Tiny
	 * @function mapWebGLDrawModesToTiny
	 * @private
	 * @param {WebGLRenderingContext} gl - The current WebGL drawing context
	 * @param {object} [object={}] - The object to map into
	 * @return {object} The mapped draw modes.
	 */
	function mapWebGLDrawModesToTiny(gl) {
	  var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  object[_const.DRAW_MODES.POINTS] = gl.POINTS;
	  object[_const.DRAW_MODES.LINES] = gl.LINES;
	  object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
	  object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
	  object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
	  object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
	  object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;

	  return object;
	}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = validateContext;
	function validateContext(gl) {
	  var attributes = gl.getContextAttributes();

	  // this is going to be fairly simple for now.. but at least we have room to grow!
	  if (!attributes.stencil) {
	    /* eslint-disable no-console */
	    console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
	    /* eslint-enable no-console */
	  }
	}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = generateMultiTextureShader;

	var _Shader = __webpack_require__(93);

	var _Shader2 = _interopRequireDefault(_Shader);

	var _path = __webpack_require__(87);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var fragTemplate = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', 'float textureId = floor(vTextureId+0.5);', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n');

	function generateMultiTextureShader(gl, maxTextures) {
	  var vertexSrc = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n';
	  var fragmentSrc = fragTemplate;

	  fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
	  fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));

	  var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);

	  var sampleValues = [];

	  for (var i = 0; i < maxTextures; i++) {
	    sampleValues[i] = i;
	  }

	  shader.bind();
	  shader.uniforms.uSamplers = sampleValues;

	  return shader;
	}

	function generateSampleSrc(maxTextures) {
	  var src = '';

	  src += '\n';
	  src += '\n';

	  for (var i = 0; i < maxTextures; i++) {
	    if (i > 0) {
	      src += '\nelse ';
	    }

	    if (i < maxTextures - 1) {
	      src += 'if(textureId == ' + i + '.0)';
	    }

	    src += '\n{';
	    src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);';
	    src += '\n}';
	  }

	  src += '\n';
	  src += '\n';

	  return src;
	}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = checkMaxIfStatmentsInShader;

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n');

	function checkMaxIfStatmentsInShader(maxIfs, gl) {
	  var createTempContext = !gl;

	  // @if DEBUG
	  if (maxIfs === 0) {
	    throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
	  }
	  // @endif

	  if (createTempContext) {
	    var tinyCanvas = document.createElement('canvas');

	    tinyCanvas.width = 1;
	    tinyCanvas.height = 1;

	    gl = _pixiGlCore2.default.createContext(tinyCanvas);
	  }

	  var shader = gl.createShader(gl.FRAGMENT_SHADER);

	  while (true) // eslint-disable-line no-constant-condition
	  {
	    var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));

	    gl.shaderSource(shader, fragmentSrc);
	    gl.compileShader(shader);

	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	      maxIfs = maxIfs / 2 | 0;
	    } else {
	      // valid!
	      break;
	    }
	  }

	  if (createTempContext) {
	    // get rid of context
	    if (gl.getExtension('WEBGL_lose_context')) {
	      gl.getExtension('WEBGL_lose_context').loseContext();
	    }
	  }

	  return maxIfs;
	}

	function generateIfTestSrc(maxIfs) {
	  var src = '';

	  for (var i = 0; i < maxIfs; ++i) {
	    if (i > 0) {
	      src += '\nelse ';
	    }

	    if (i < maxIfs - 1) {
	      src += 'if(test == ' + i + '.0){}';
	    }
	  }

	  return src;
	}

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var Buffer = function () {
	  /**
	   * @param {number} size - The size of the buffer in bytes.
	   */
	  function Buffer(size) {
	    _classCallCheck(this, Buffer);

	    this.vertices = new ArrayBuffer(size);

	    /**
	     * View on the vertices as a Float32Array for positions
	     *
	     * @member {Float32Array}
	     */
	    this.float32View = new Float32Array(this.vertices);

	    /**
	     * View on the vertices as a Uint32Array for uvs
	     *
	     * @member {Float32Array}
	     */
	    this.uint32View = new Uint32Array(this.vertices);
	  }

	  /**
	   * Destroys the buffer.
	   *
	   */


	  _createClass(Buffer, [{
	    key: "destroy",
	    value: function destroy() {
	      this.vertices = null;
	      this.positions = null;
	      this.uvs = null;
	      this.colors = null;
	    }
	  }]);

	  return Buffer;
	}();

	exports.default = Buffer;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _Sprite2 = __webpack_require__(51);

	var _Sprite3 = _interopRequireDefault(_Sprite2);

	var _Texture = __webpack_require__(52);

	var _Texture2 = _interopRequireDefault(_Texture);

	var _math = __webpack_require__(8);

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _TextStyle = __webpack_require__(105);

	var _TextStyle2 = _interopRequireDefault(_TextStyle);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint max-depth: [2, 8] */


	var defaultDestroyOptions = {
	  texture: true,
	  children: false,
	  baseTexture: true
	};

	/**
	 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
	 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
	 *
	 * A Text can be created directly from a string and a style object
	 *
	 * ```js
	* let text = new Tiny.Text('This is a Tiny text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
	 * ```
	 *
	 * @class
	 * @extends Tiny.Sprite
	 * @memberof Tiny
	 */

	var Text = function (_Sprite) {
	  _inherits(Text, _Sprite);

	  /**
	   * @param {string} text - The string that you would like the text to display
	   * @param {object|Tiny.TextStyle} [style] - The style parameters
	   * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text
	   */
	  function Text(text, style, canvas) {
	    _classCallCheck(this, Text);

	    canvas = canvas || document.createElement('canvas');

	    canvas.width = 3;
	    canvas.height = 3;

	    var texture = _Texture2.default.fromCanvas(canvas);

	    texture.orig = new _math.Rectangle();
	    texture.trim = new _math.Rectangle();

	    /**
	     * The canvas element that everything is drawn to
	     *
	     * @member {HTMLCanvasElement}
	     */
	    var _this = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, texture));

	    _this.canvas = canvas;

	    /**
	     * The canvas 2d context that everything is drawn with
	     * @member {HTMLCanvasElement}
	     */
	    _this.context = _this.canvas.getContext('2d');

	    /**
	     * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.
	     * @member {number}
	     * @default 1
	     */
	    _this.resolution = _settings2.default.RESOLUTION;

	    /**
	     * Private tracker for the current text.
	     *
	     * @member {string}
	     * @private
	     */
	    _this._text = null;

	    /**
	     * Private tracker for the current style.
	     *
	     * @member {object}
	     * @private
	     */
	    _this._style = null;
	    /**
	     * Private listener to track style changes.
	     *
	     * @member {Function}
	     * @private
	     */
	    _this._styleListener = null;

	    /**
	     * Private tracker for the current font.
	     *
	     * @member {string}
	     * @private
	     */
	    _this._font = '';

	    _this.text = text;
	    _this.style = style;

	    _this.localStyleID = -1;
	    return _this;
	  }

	  /**
	   * Renders text and updates it when needed.
	   *
	   * @private
	   * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
	   */


	  _createClass(Text, [{
	    key: 'updateText',
	    value: function updateText(respectDirty) {
	      var style = this._style;

	      // check if style has changed..
	      if (this.localStyleID !== style.styleID) {
	        this.dirty = true;
	        this.localStyleID = style.styleID;
	      }

	      if (!this.dirty && respectDirty) {
	        return;
	      }

	      this._font = Text.getFontStyle(style);

	      this.context.font = this._font;

	      // word wrap
	      // preserve original text
	      var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;

	      // split text into lines
	      var lines = outputText.split(/(?:\r\n|\r|\n)/);

	      // calculate text width
	      var lineWidths = new Array(lines.length);
	      var maxLineWidth = 0;
	      var fontProperties = Text.calculateFontProperties(this._font);

	      for (var i = 0; i < lines.length; i++) {
	        var lineWidth = this.context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;

	        lineWidths[i] = lineWidth;
	        maxLineWidth = Math.max(maxLineWidth, lineWidth);
	      }

	      var width = maxLineWidth + style.strokeThickness;

	      if (style.dropShadow) {
	        width += style.dropShadowDistance;
	      }

	      this.canvas.width = Math.ceil((width + style.padding * 2) * this.resolution);

	      // calculate text height
	      var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;

	      var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * lineHeight;

	      if (style.dropShadow) {
	        height += style.dropShadowDistance;
	      }

	      this.canvas.height = Math.ceil((height + style.padding * 2) * this.resolution);

	      this.context.scale(this.resolution, this.resolution);

	      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

	      this.context.font = this._font;
	      this.context.strokeStyle = style.stroke;
	      this.context.lineWidth = style.strokeThickness;
	      this.context.textBaseline = style.textBaseline;
	      this.context.lineJoin = style.lineJoin;
	      this.context.miterLimit = style.miterLimit;

	      var linePositionX = void 0;
	      var linePositionY = void 0;

	      if (style.dropShadow) {
	        if (style.dropShadowBlur > 0) {
	          this.context.shadowColor = style.dropShadowColor;
	          this.context.shadowBlur = style.dropShadowBlur;
	        } else {
	          this.context.fillStyle = style.dropShadowColor;
	        }

	        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
	        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

	        for (var _i = 0; _i < lines.length; _i++) {
	          linePositionX = style.strokeThickness / 2;
	          linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;

	          if (style.align === 'right') {
	            linePositionX += maxLineWidth - lineWidths[_i];
	          } else if (style.align === 'center') {
	            linePositionX += (maxLineWidth - lineWidths[_i]) / 2;
	          }

	          if (style.fill) {
	            this.drawLetterSpacing(lines[_i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);

	            if (style.stroke && style.strokeThickness) {
	              this.context.strokeStyle = style.dropShadowColor;
	              this.drawLetterSpacing(lines[_i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);
	              this.context.strokeStyle = style.stroke;
	            }
	          }
	        }
	      }

	      // set canvas text styles
	      this.context.fillStyle = this._generateFillStyle(style, lines);

	      // draw lines line by line
	      for (var _i2 = 0; _i2 < lines.length; _i2++) {
	        linePositionX = style.strokeThickness / 2;
	        linePositionY = style.strokeThickness / 2 + _i2 * lineHeight + fontProperties.ascent;

	        if (style.align === 'right') {
	          linePositionX += maxLineWidth - lineWidths[_i2];
	        } else if (style.align === 'center') {
	          linePositionX += (maxLineWidth - lineWidths[_i2]) / 2;
	        }

	        if (style.stroke && style.strokeThickness) {
	          this.drawLetterSpacing(lines[_i2], linePositionX + style.padding, linePositionY + style.padding, true);
	        }

	        if (style.fill) {
	          this.drawLetterSpacing(lines[_i2], linePositionX + style.padding, linePositionY + style.padding);
	        }
	      }

	      this.updateTexture();
	    }

	    /**
	     * Render the text with letter-spacing.
	     * @param {string} text - The text to draw
	     * @param {number} x - Horizontal position to draw the text
	     * @param {number} y - Vertical position to draw the text
	     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
	     *  text? If not, it's for the inside fill
	     * @private
	     */

	  }, {
	    key: 'drawLetterSpacing',
	    value: function drawLetterSpacing(text, x, y) {
	      var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	      var style = this._style;

	      // letterSpacing of 0 means normal
	      var letterSpacing = style.letterSpacing;

	      if (letterSpacing === 0) {
	        if (isStroke) {
	          this.context.strokeText(text, x, y);
	        } else {
	          this.context.fillText(text, x, y);
	        }

	        return;
	      }

	      var characters = String.prototype.split.call(text, '');
	      var currentPosition = x;
	      var index = 0;
	      var current = '';

	      while (index < text.length) {
	        current = characters[index++];
	        if (isStroke) {
	          this.context.strokeText(current, currentPosition, y);
	        } else {
	          this.context.fillText(current, currentPosition, y);
	        }
	        currentPosition += this.context.measureText(current).width + letterSpacing;
	      }
	    }

	    /**
	     * Updates texture size based on canvas size
	     *
	     * @private
	     */

	  }, {
	    key: 'updateTexture',
	    value: function updateTexture() {
	      var texture = this._texture;
	      var style = this._style;

	      texture.baseTexture.hasLoaded = true;
	      texture.baseTexture.resolution = this.resolution;

	      texture.baseTexture.realWidth = this.canvas.width;
	      texture.baseTexture.realHeight = this.canvas.height;
	      texture.baseTexture.width = this.canvas.width / this.resolution;
	      texture.baseTexture.height = this.canvas.height / this.resolution;
	      texture.trim.width = texture._frame.width = this.canvas.width / this.resolution;
	      texture.trim.height = texture._frame.height = this.canvas.height / this.resolution;

	      texture.trim.x = -style.padding;
	      texture.trim.y = -style.padding;

	      texture.orig.width = texture._frame.width - style.padding * 2;
	      texture.orig.height = texture._frame.height - style.padding * 2;

	      // call sprite onTextureUpdate to update scale if _width or _height were set
	      this._onTextureUpdate();

	      texture.baseTexture.emit('update', texture.baseTexture);

	      this.dirty = false;
	    }

	    /**
	     * Renders the object using the WebGL renderer
	     *
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      if (this.resolution !== renderer.resolution) {
	        this.resolution = renderer.resolution;
	        this.dirty = true;
	      }

	      this.updateText(true);

	      _get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'renderWebGL', this).call(this, renderer);
	    }

	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      if (this.resolution !== renderer.resolution) {
	        this.resolution = renderer.resolution;
	        this.dirty = true;
	      }

	      this.updateText(true);

	      _get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), '_renderCanvas', this).call(this, renderer);
	    }

	    /**
	     * Applies newlines to a string to have it optimally fit into the horizontal
	     * bounds set by the Text object's wordWrapWidth property.
	     *
	     * @private
	     * @param {string} text - String to apply word wrapping to
	     * @return {string} New string with new lines applied where required
	     */

	  }, {
	    key: 'wordWrap',
	    value: function wordWrap(text) {
	      // Greedy wrapping algorithm that will wrap words as the line grows longer
	      // than its horizontal bounds.
	      var result = '';
	      var style = this._style;
	      var lines = text.split('\n');
	      var wordWrapWidth = style.wordWrapWidth;

	      for (var i = 0; i < lines.length; i++) {
	        var spaceLeft = wordWrapWidth;
	        var words = lines[i].split(' ');

	        for (var j = 0; j < words.length; j++) {
	          var wordWidth = this.context.measureText(words[j]).width;

	          if (style.breakWords && wordWidth > wordWrapWidth) {
	            // Word should be split in the middle
	            var characters = words[j].split('');

	            for (var c = 0; c < characters.length; c++) {
	              var characterWidth = this.context.measureText(characters[c]).width;

	              if (characterWidth > spaceLeft) {
	                result += '\n' + characters[c];
	                spaceLeft = wordWrapWidth - characterWidth;
	              } else {
	                if (c === 0) {
	                  result += ' ';
	                }

	                result += characters[c];
	                spaceLeft -= characterWidth;
	              }
	            }
	          } else {
	            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;

	            if (j === 0 || wordWidthWithSpace > spaceLeft) {
	              // Skip printing the newline if it's the first word of the line that is
	              // greater than the word wrap width.
	              if (j > 0) {
	                result += '\n';
	              }
	              result += words[j];
	              spaceLeft = wordWrapWidth - wordWidth;
	            } else {
	              spaceLeft -= wordWidthWithSpace;
	              result += ' ' + words[j];
	            }
	          }
	        }

	        if (i < lines.length - 1) {
	          result += '\n';
	        }
	      }

	      return result;
	    }

	    /**
	     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
	     */

	  }, {
	    key: '_calculateBounds',
	    value: function _calculateBounds() {
	      this.updateText(true);
	      this.calculateVertices();
	      // if we have already done this on THIS frame.
	      this._bounds.addQuad(this.vertexData);
	    }

	    /**
	     * Method to be called upon a TextStyle change.
	     * @private
	     */

	  }, {
	    key: '_onStyleChange',
	    value: function _onStyleChange() {
	      this.dirty = true;
	    }

	    /**
	     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
	     *
	     * @private
	     * @param {object} style - The style.
	     * @param {string[]} lines - The lines of text.
	     * @return {string|number|CanvasGradient} The fill style
	     */

	  }, {
	    key: '_generateFillStyle',
	    value: function _generateFillStyle(style, lines) {
	      if (!Array.isArray(style.fill)) {
	        return style.fill;
	      }

	      // cocoon on canvas+ cannot generate textures, so use the first colour instead
	      if (navigator.isCocoonJS) {
	        return style.fill[0];
	      }

	      // the gradient will be evenly spaced out according to how large the array is.
	      // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
	      var gradient = void 0;
	      var totalIterations = void 0;
	      var currentIteration = void 0;
	      var stop = void 0;

	      var width = this.canvas.width / this.resolution;
	      var height = this.canvas.height / this.resolution;

	      if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
	        // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
	        gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);

	        // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
	        // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
	        totalIterations = (style.fill.length + 1) * lines.length;
	        currentIteration = 0;
	        for (var i = 0; i < lines.length; i++) {
	          currentIteration += 1;
	          for (var j = 0; j < style.fill.length; j++) {
	            stop = currentIteration / totalIterations;
	            gradient.addColorStop(stop, style.fill[j]);
	            currentIteration++;
	          }
	        }
	      } else {
	        // start the gradient at the center left of the canvas, and end at the center right of the canvas
	        gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);

	        // can just evenly space out the gradients in this case, as multiple lines makes no difference
	        // to an even left to right gradient
	        totalIterations = style.fill.length + 1;
	        currentIteration = 1;

	        for (var _i3 = 0; _i3 < style.fill.length; _i3++) {
	          stop = currentIteration / totalIterations;
	          gradient.addColorStop(stop, style.fill[_i3]);
	          currentIteration++;
	        }
	      }

	      return gradient;
	    }

	    /**
	     * Destroys this text object.
	     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
	     * the majorety of the time the texture will not be shared with any other Sprites.
	     *
	     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
	     *  have been set to that value
	     * @param {boolean} [options.children=false] - if set to true, all the children will have their
	     *  destroy method called as well. 'options' will be passed on to those calls.
	     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
	     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(options) {
	      if (typeof options === 'boolean') {
	        options = { children: options };
	      }

	      options = Object.assign({}, defaultDestroyOptions, options);

	      _get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'destroy', this).call(this, options);

	      // make sure to reset the the context and canvas.. dont want this hanging around in memory!
	      this.context = null;
	      this.canvas = null;

	      this._style = null;
	    }

	    /**
	     * The width of the Text, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      this.updateText(true);

	      return Math.abs(this.scale.x) * this._texture.orig.width;
	    },
	    set: function set(value) {
	      this.updateText(true);

	      var s = (0, _utils.sign)(this.scale.x) || 1;

	      this.scale.x = s * value / this._texture.orig.width;
	      this._width = value;
	    }

	    /**
	     * The height of the Text, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      this.updateText(true);

	      return Math.abs(this.scale.y) * this._texture.orig.height;
	    },
	    set: function set(value) {
	      this.updateText(true);

	      var s = (0, _utils.sign)(this.scale.y) || 1;

	      this.scale.y = s * value / this._texture.orig.height;
	      this._height = value;
	    }

	    /**
	     * Set the style of the text. Set up an event listener to listen for changes on the style
	     * object and mark the text as dirty.
	     *
	     * @member {object|Tiny.TextStyle}
	     */

	  }, {
	    key: 'style',
	    get: function get() {
	      return this._style;
	    },
	    set: function set(style) {
	      style = style || {};

	      if (style instanceof _TextStyle2.default) {
	        this._style = style;
	      } else {
	        this._style = new _TextStyle2.default(style);
	      }

	      this.localStyleID = -1;
	      this.dirty = true;
	    }

	    /**
	     * Set the copy for the text object. To split a line you can use '\n'.
	     *
	     * @member {string}
	     */

	  }, {
	    key: 'text',
	    get: function get() {
	      return this._text;
	    },
	    set: function set(text) {
	      text = String(text || ' ');

	      if (this._text === text) {
	        return;
	      }
	      this._text = text;
	      this.dirty = true;
	    }

	    /**
	     * Generates a font style string to use for Text.calculateFontProperties(). Takes the same parameter
	     * as Text.style.
	     *
	     * @static
	     * @param {object|TextStyle} style - String representing the style of the font
	     * @return {string} Font style string, for passing to Text.calculateFontProperties()
	     */

	  }], [{
	    key: 'getFontStyle',
	    value: function getFontStyle(style) {
	      style = style || {};

	      if (!(style instanceof _TextStyle2.default)) {
	        style = new _TextStyle2.default(style);
	      }

	      // build canvas api font setting from individual components. Convert a numeric style.fontSize to px
	      var fontSizeString = typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize;

	      // Clean-up fontFamily property by quoting each font name
	      // this will support font names with spaces
	      var fontFamilies = style.fontFamily;

	      if (!Array.isArray(style.fontFamily)) {
	        fontFamilies = style.fontFamily.split(',');
	      }

	      for (var i = fontFamilies.length - 1; i >= 0; i--) {
	        // Trim any extra white-space
	        var fontFamily = fontFamilies[i].trim();

	        // Check if font already contains strings
	        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily)) {
	          // eslint-disable-line
	          fontFamily = '"' + fontFamily + '"';
	        }
	        fontFamilies[i] = fontFamily;
	      }

	      return style.fontStyle + ' ' + style.fontVariant + ' ' + style.fontWeight + ' ' + fontSizeString + ' ' + fontFamilies.join(',');
	    }

	    /**
	     * Calculates the ascent, descent and fontSize of a given fontStyle
	     *
	     * @static
	     * @param {string} fontStyle - String representing the style of the font
	     * @return {Object} Font properties object
	     */

	  }, {
	    key: 'calculateFontProperties',
	    value: function calculateFontProperties(fontStyle) {
	      // as this method is used for preparing assets, don't recalculate things if we don't need to
	      if (Text.fontPropertiesCache[fontStyle]) {
	        return Text.fontPropertiesCache[fontStyle];
	      }

	      var properties = {};

	      var canvas = Text.fontPropertiesCanvas;
	      var context = Text.fontPropertiesContext;

	      context.font = fontStyle;

	      var width = Math.ceil(context.measureText('|MÉq').width);
	      var baseline = Math.ceil(context.measureText('M').width);
	      var height = 2 * baseline;

	      baseline = baseline * 1.4 | 0;

	      canvas.width = width;
	      canvas.height = height;

	      context.fillStyle = '#f00';
	      context.fillRect(0, 0, width, height);

	      context.font = fontStyle;

	      context.textBaseline = 'alphabetic';
	      context.fillStyle = '#000';
	      context.fillText('|MÉq', 0, baseline);

	      var imagedata = context.getImageData(0, 0, width, height).data;
	      var pixels = imagedata.length;
	      var line = width * 4;

	      var i = 0;
	      var idx = 0;
	      var stop = false;

	      // ascent. scan from top to bottom until we find a non red pixel
	      for (i = 0; i < baseline; ++i) {
	        for (var j = 0; j < line; j += 4) {
	          if (imagedata[idx + j] !== 255) {
	            stop = true;
	            break;
	          }
	        }
	        if (!stop) {
	          idx += line;
	        } else {
	          break;
	        }
	      }

	      properties.ascent = baseline - i;

	      idx = pixels - line;
	      stop = false;

	      // descent. scan from bottom to top until we find a non red pixel
	      for (i = height; i > baseline; --i) {
	        for (var _j = 0; _j < line; _j += 4) {
	          if (imagedata[idx + _j] !== 255) {
	            stop = true;
	            break;
	          }
	        }

	        if (!stop) {
	          idx -= line;
	        } else {
	          break;
	        }
	      }

	      properties.descent = i - baseline;
	      properties.fontSize = properties.ascent + properties.descent;

	      Text.fontPropertiesCache[fontStyle] = properties;

	      return properties;
	    }
	  }]);

	  return Text;
	}(_Sprite3.default);

	exports.default = Text;


	Text.fontPropertiesCache = {};
	Text.fontPropertiesCanvas = document.createElement('canvas');
	Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _const = __webpack_require__(7);

	var _utils = __webpack_require__(18);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultStyle = {
	  align: 'left',
	  breakWords: false,
	  dropShadow: false,
	  dropShadowAngle: Math.PI / 6,
	  dropShadowBlur: 0,
	  dropShadowColor: '#000000',
	  dropShadowDistance: 5,
	  fill: 'black',
	  fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
	  fontFamily: 'Arial',
	  fontSize: 26,
	  fontStyle: 'normal',
	  fontVariant: 'normal',
	  fontWeight: 'normal',
	  letterSpacing: 0,
	  lineHeight: 0,
	  lineJoin: 'miter',
	  miterLimit: 10,
	  padding: 0,
	  stroke: 'black',
	  strokeThickness: 0,
	  textBaseline: 'alphabetic',
	  wordWrap: false,
	  wordWrapWidth: 100
	};

	/**
	 * A TextStyle Object decorates a Text Object. It can be shared between
	 * multiple Text objects. Changing the style will update all text objects using it.
	 *
	 * @class
	 * @memberof Tiny
	 */

	var TextStyle = function () {
	  /**
	   * @param {object} [style] - The style parameters
	   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
	   *  does not affect single line text
	   * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
	   *  needs wordWrap to be set to true
	   * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
	   * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
	   * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
	   * @param {string} [style.dropShadowColor='#000000'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	   * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
	   * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
	   *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
	   *  eg ['#000000','#FFFFFF']
	   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
	   * @param {number} [style.fillGradientType=Tiny.TEXT_GRADIENT.LINEAR_VERTICAL] - If fills styles are
	   *  supplied, this can change the type/direction of the gradient. See {@link Tiny.TEXT_GRADIENT} for possible values
	   * @param {string|string[]} [style.fontFamily='Arial'] - The font family
	   * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
	   *  equivalents are '26px','20pt','160%' or '1.6em')
	   * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
	   * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
	   * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
	   *  '200', '300', '400', '500', '600', '700', 800' or '900')
	   * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
	   * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
	   * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
	   *      spiked text issues. Default is 'miter' (creates a sharp corner).
	   * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	   *      or increase the spikiness of rendered text.
	   * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
	   *     happening by adding padding to all sides of the text.
	   * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
	   *  e.g 'blue', '#FCFF00'
	   * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
	   *  Default is 0 (no stroke)
	   * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
	   * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
	   * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
	   */
	  function TextStyle(style) {
	    _classCallCheck(this, TextStyle);

	    this.styleID = 0;

	    Object.assign(this, defaultStyle, style);
	  }

	  /**
	   * Creates a new TextStyle object with the same values as this one.
	   * Note that the only the properties of the object are cloned.
	   *
	   * @return {Tiny.TextStyle} New cloned TextStyle object
	   */


	  _createClass(TextStyle, [{
	    key: 'clone',
	    value: function clone() {
	      var clonedProperties = {};

	      for (var key in defaultStyle) {
	        clonedProperties[key] = this[key];
	      }

	      return new TextStyle(clonedProperties);
	    }

	    /**
	     * Resets all properties to the defaults specified in TextStyle.prototype._default
	     */

	  }, {
	    key: 'reset',
	    value: function reset() {
	      Object.assign(this, defaultStyle);
	    }
	  }, {
	    key: 'align',
	    get: function get() {
	      return this._align;
	    },
	    set: function set(align) {
	      if (this._align !== align) {
	        this._align = align;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'breakWords',
	    get: function get() {
	      return this._breakWords;
	    },
	    set: function set(breakWords) {
	      if (this._breakWords !== breakWords) {
	        this._breakWords = breakWords;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'dropShadow',
	    get: function get() {
	      return this._dropShadow;
	    },
	    set: function set(dropShadow) {
	      if (this._dropShadow !== dropShadow) {
	        this._dropShadow = dropShadow;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'dropShadowAngle',
	    get: function get() {
	      return this._dropShadowAngle;
	    },
	    set: function set(dropShadowAngle) {
	      if (this._dropShadowAngle !== dropShadowAngle) {
	        this._dropShadowAngle = dropShadowAngle;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'dropShadowBlur',
	    get: function get() {
	      return this._dropShadowBlur;
	    },
	    set: function set(dropShadowBlur) {
	      if (this._dropShadowBlur !== dropShadowBlur) {
	        this._dropShadowBlur = dropShadowBlur;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'dropShadowColor',
	    get: function get() {
	      return this._dropShadowColor;
	    },
	    set: function set(dropShadowColor) {
	      var outputColor = getColor(dropShadowColor);
	      if (this._dropShadowColor !== outputColor) {
	        this._dropShadowColor = outputColor;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'dropShadowDistance',
	    get: function get() {
	      return this._dropShadowDistance;
	    },
	    set: function set(dropShadowDistance) {
	      if (this._dropShadowDistance !== dropShadowDistance) {
	        this._dropShadowDistance = dropShadowDistance;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fill',
	    get: function get() {
	      return this._fill;
	    },
	    set: function set(fill) {
	      var outputColor = getColor(fill);
	      if (this._fill !== outputColor) {
	        this._fill = outputColor;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fillGradientType',
	    get: function get() {
	      return this._fillGradientType;
	    },
	    set: function set(fillGradientType) {
	      if (this._fillGradientType !== fillGradientType) {
	        this._fillGradientType = fillGradientType;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fontFamily',
	    get: function get() {
	      return this._fontFamily;
	    },
	    set: function set(fontFamily) {
	      if (this.fontFamily !== fontFamily) {
	        this._fontFamily = fontFamily;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fontSize',
	    get: function get() {
	      return this._fontSize;
	    },
	    set: function set(fontSize) {
	      if (this._fontSize !== fontSize) {
	        this._fontSize = fontSize;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fontStyle',
	    get: function get() {
	      return this._fontStyle;
	    },
	    set: function set(fontStyle) {
	      if (this._fontStyle !== fontStyle) {
	        this._fontStyle = fontStyle;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fontVariant',
	    get: function get() {
	      return this._fontVariant;
	    },
	    set: function set(fontVariant) {
	      if (this._fontVariant !== fontVariant) {
	        this._fontVariant = fontVariant;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'fontWeight',
	    get: function get() {
	      return this._fontWeight;
	    },
	    set: function set(fontWeight) {
	      if (this._fontWeight !== fontWeight) {
	        this._fontWeight = fontWeight;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'letterSpacing',
	    get: function get() {
	      return this._letterSpacing;
	    },
	    set: function set(letterSpacing) {
	      if (this._letterSpacing !== letterSpacing) {
	        this._letterSpacing = letterSpacing;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'lineHeight',
	    get: function get() {
	      return this._lineHeight;
	    },
	    set: function set(lineHeight) {
	      if (this._lineHeight !== lineHeight) {
	        this._lineHeight = lineHeight;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'lineJoin',
	    get: function get() {
	      return this._lineJoin;
	    },
	    set: function set(lineJoin) {
	      if (this._lineJoin !== lineJoin) {
	        this._lineJoin = lineJoin;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'miterLimit',
	    get: function get() {
	      return this._miterLimit;
	    },
	    set: function set(miterLimit) {
	      if (this._miterLimit !== miterLimit) {
	        this._miterLimit = miterLimit;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'padding',
	    get: function get() {
	      return this._padding;
	    },
	    set: function set(padding) {
	      if (this._padding !== padding) {
	        this._padding = padding;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'stroke',
	    get: function get() {
	      return this._stroke;
	    },
	    set: function set(stroke) {
	      var outputColor = getColor(stroke);
	      if (this._stroke !== outputColor) {
	        this._stroke = outputColor;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'strokeThickness',
	    get: function get() {
	      return this._strokeThickness;
	    },
	    set: function set(strokeThickness) {
	      if (this._strokeThickness !== strokeThickness) {
	        this._strokeThickness = strokeThickness;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'textBaseline',
	    get: function get() {
	      return this._textBaseline;
	    },
	    set: function set(textBaseline) {
	      if (this._textBaseline !== textBaseline) {
	        this._textBaseline = textBaseline;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'wordWrap',
	    get: function get() {
	      return this._wordWrap;
	    },
	    set: function set(wordWrap) {
	      if (this._wordWrap !== wordWrap) {
	        this._wordWrap = wordWrap;
	        this.styleID++;
	      }
	    }
	  }, {
	    key: 'wordWrapWidth',
	    get: function get() {
	      return this._wordWrapWidth;
	    },
	    set: function set(wordWrapWidth) {
	      if (this._wordWrapWidth !== wordWrapWidth) {
	        this._wordWrapWidth = wordWrapWidth;
	        this.styleID++;
	      }
	    }
	  }]);

	  return TextStyle;
	}();

	/**
	 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
	 *
	 * @param {number|number[]} color
	 * @return {string} The color as a string.
	 */


	exports.default = TextStyle;
	function getSingleColor(color) {
	  if (typeof color === 'number') {
	    return (0, _utils.hex2string)(color);
	  } else if (typeof color === 'string') {
	    if (color.indexOf('0x') === 0) {
	      color = color.replace('0x', '#');
	    }
	  }

	  return color;
	}

	/**
	 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
	 * This version can also convert array of colors
	 *
	 * @param {number|number[]} color
	 * @return {string} The color as a string.
	 */
	function getColor(color) {
	  if (!Array.isArray(color)) {
	    return getSingleColor(color);
	  } else {
	    for (var i = 0; i < color.length; ++i) {
	      color[i] = getSingleColor(color[i]);
	    }

	    return color;
	  }
	}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _Container2 = __webpack_require__(50);

	var _Container3 = _interopRequireDefault(_Container2);

	var _RenderTexture = __webpack_require__(72);

	var _RenderTexture2 = _interopRequireDefault(_RenderTexture);

	var _Texture = __webpack_require__(52);

	var _Texture2 = _interopRequireDefault(_Texture);

	var _GraphicsData = __webpack_require__(107);

	var _GraphicsData2 = _interopRequireDefault(_GraphicsData);

	var _Sprite = __webpack_require__(51);

	var _Sprite2 = _interopRequireDefault(_Sprite);

	var _math = __webpack_require__(8);

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	var _Bounds = __webpack_require__(45);

	var _Bounds2 = _interopRequireDefault(_Bounds);

	var _bezierCurveTo2 = __webpack_require__(108);

	var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);

	var _CanvasRenderer = __webpack_require__(70);

	var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var canvasRenderer = void 0;
	var tempMatrix = new _math.Matrix();
	var tempPoint = new _math.Point();
	var tempColor1 = new Float32Array(4);
	var tempColor2 = new Float32Array(4);

	/**
	 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
	 * rectangles to the display, and to color and fill them.
	 *
	 * @class
	 * @extends Tiny.Container
	 * @memberof Tiny
	 */

	var Graphics = function (_Container) {
	  _inherits(Graphics, _Container);

	  /**
	   *
	   */
	  function Graphics() {
	    _classCallCheck(this, Graphics);

	    /**
	     * The alpha value used when filling the Graphics object.
	     *
	     * @member {number}
	     * @default 1
	     */
	    var _this = _possibleConstructorReturn(this, (Graphics.__proto__ || Object.getPrototypeOf(Graphics)).call(this));

	    _this.fillAlpha = 1;

	    /**
	     * The width (thickness) of any lines drawn.
	     *
	     * @member {number}
	     * @default 0
	     */
	    _this.lineWidth = 0;

	    /**
	     * The color of any lines drawn.
	     *
	     * @member {string}
	     * @default 0
	     */
	    _this.lineColor = 0;

	    /**
	     * Graphics data
	     *
	     * @member {Tiny.GraphicsData[]}
	     * @private
	     */
	    _this.graphicsData = [];

	    /**
	     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to
	     * reset the tint.
	     *
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    _this.tint = 0xFFFFFF;

	    /**
	     * The previous tint applied to the graphic shape. Used to compare to the current tint and
	     * check if theres change.
	     *
	     * @member {number}
	     * @private
	     * @default 0xFFFFFF
	     */
	    _this._prevTint = 0xFFFFFF;

	    /**
	     * The blend mode to be applied to the graphic shape. Apply a value of
	     * `Tiny.BLEND_MODES.NORMAL` to reset the blend mode.
	     *
	     * @member {number}
	     * @default Tiny.BLEND_MODES.NORMAL;
	     * @see Tiny.BLEND_MODES
	     */
	    _this.blendMode = _const.BLEND_MODES.NORMAL;

	    /**
	     * Current path
	     *
	     * @member {Tiny.GraphicsData}
	     * @private
	     */
	    _this.currentPath = null;

	    /**
	     * Array containing some WebGL-related properties used by the WebGL renderer.
	     *
	     * @member {object<number, object>}
	     * @private
	     */
	    // TODO - _webgl should use a prototype object, not a random undocumented object...
	    _this._webGL = {};

	    /**
	     * Whether this shape is being used as a mask.
	     *
	     * @member {boolean}
	     */
	    _this.isMask = false;

	    /**
	     * The bounds' padding used for bounds calculation.
	     *
	     * @member {number}
	     */
	    _this.boundsPadding = 0;

	    /**
	     * A cache of the local bounds to prevent recalculation.
	     *
	     * @member {Tiny.Rectangle}
	     * @private
	     */
	    _this._localBounds = new _Bounds2.default();

	    /**
	     * Used to detect if the graphics object has changed. If this is set to true then the graphics
	     * object will be recalculated.
	     *
	     * @member {boolean}
	     * @private
	     */
	    _this.dirty = 0;

	    /**
	     * Used to detect if we need to do a fast rect check using the id compare method
	     * @type {Number}
	     */
	    _this.fastRectDirty = -1;

	    /**
	     * Used to detect if we clear the graphics webGL data
	     * @type {Number}
	     */
	    _this.clearDirty = 0;

	    /**
	     * Used to detect if we we need to recalculate local bounds
	     * @type {Number}
	     */
	    _this.boundsDirty = -1;

	    /**
	     * Used to detect if the cached sprite object needs to be updated.
	     *
	     * @member {boolean}
	     * @private
	     */
	    _this.cachedSpriteDirty = false;

	    _this._spriteRect = null;
	    _this._fastRect = false;

	    /**
	     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
	     * This is useful if your graphics element does not change often, as it will speed up the rendering
	     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
	     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
	     * you are constantly redrawing the graphics element.
	     *
	     * @name cacheAsBitmap
	     * @member {boolean}
	     * @memberof Tiny.Graphics#
	     * @default false
	     */
	    return _this;
	  }

	  /**
	   * Creates a new Graphics object with the same values as this one.
	   * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
	   *
	   * @return {Tiny.Graphics} A clone of the graphics object
	   */


	  _createClass(Graphics, [{
	    key: 'clone',
	    value: function clone() {
	      var clone = new Graphics();

	      clone.renderable = this.renderable;
	      clone.fillAlpha = this.fillAlpha;
	      clone.lineWidth = this.lineWidth;
	      clone.lineColor = this.lineColor;
	      clone.tint = this.tint;
	      clone.blendMode = this.blendMode;
	      clone.isMask = this.isMask;
	      clone.boundsPadding = this.boundsPadding;
	      clone.dirty = 0;
	      clone.cachedSpriteDirty = this.cachedSpriteDirty;

	      // copy graphics data
	      for (var i = 0; i < this.graphicsData.length; ++i) {
	        clone.graphicsData.push(this.graphicsData[i].clone());
	      }

	      clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

	      clone.updateLocalBounds();

	      return clone;
	    }

	    /**
	     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
	     * method or the drawCircle() method.
	     *
	     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
	     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
	     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'lineStyle',
	    value: function lineStyle() {
	      var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

	      this.lineWidth = lineWidth;
	      this.lineColor = color;
	      this.lineAlpha = alpha;

	      if (this.currentPath) {
	        if (this.currentPath.shape.points.length) {
	          // halfway through a line? start a new one!
	          var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));

	          shape.closed = false;

	          this.drawShape(shape);
	        } else {
	          // otherwise its empty so lets just set the line properties
	          this.currentPath.lineWidth = this.lineWidth;
	          this.currentPath.lineColor = this.lineColor;
	          this.currentPath.lineAlpha = this.lineAlpha;
	        }
	      }

	      return this;
	    }

	    /**
	     * Moves the current drawing position to x, y.
	     *
	     * @param {number} x - the X coordinate to move to
	     * @param {number} y - the Y coordinate to move to
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'moveTo',
	    value: function moveTo(x, y) {
	      var shape = new _math.Polygon([x, y]);

	      shape.closed = false;
	      this.drawShape(shape);

	      return this;
	    }

	    /**
	     * Draws a line using the current line style from the current drawing position to (x, y);
	     * The current drawing position is then set to (x, y).
	     *
	     * @param {number} x - the X coordinate to draw to
	     * @param {number} y - the Y coordinate to draw to
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'lineTo',
	    value: function lineTo(x, y) {
	      this.currentPath.shape.points.push(x, y);
	      this.dirty++;

	      return this;
	    }

	    /**
	     * Calculate the points for a quadratic bezier curve and then draws it.
	     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	     *
	     * @param {number} cpX - Control point x
	     * @param {number} cpY - Control point y
	     * @param {number} toX - Destination point x
	     * @param {number} toY - Destination point y
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'quadraticCurveTo',
	    value: function quadraticCurveTo(cpX, cpY, toX, toY) {
	      if (this.currentPath) {
	        if (this.currentPath.shape.points.length === 0) {
	          this.currentPath.shape.points = [0, 0];
	        }
	      } else {
	        this.moveTo(0, 0);
	      }

	      var n = 20;
	      var points = this.currentPath.shape.points;
	      var xa = 0;
	      var ya = 0;

	      if (points.length === 0) {
	        this.moveTo(0, 0);
	      }

	      var fromX = points[points.length - 2];
	      var fromY = points[points.length - 1];

	      for (var i = 1; i <= n; ++i) {
	        var j = i / n;

	        xa = fromX + (cpX - fromX) * j;
	        ya = fromY + (cpY - fromY) * j;

	        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
	      }

	      this.dirty++;

	      return this;
	    }

	    /**
	     * Calculate the points for a bezier curve and then draws it.
	     *
	     * @param {number} cpX - Control point x
	     * @param {number} cpY - Control point y
	     * @param {number} cpX2 - Second Control point x
	     * @param {number} cpY2 - Second Control point y
	     * @param {number} toX - Destination point x
	     * @param {number} toY - Destination point y
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'bezierCurveTo',
	    value: function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
	      if (this.currentPath) {
	        if (this.currentPath.shape.points.length === 0) {
	          this.currentPath.shape.points = [0, 0];
	        }
	      } else {
	        this.moveTo(0, 0);
	      }

	      var points = this.currentPath.shape.points;

	      var fromX = points[points.length - 2];
	      var fromY = points[points.length - 1];

	      points.length -= 2;

	      (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);

	      this.dirty++;

	      return this;
	    }

	    /**
	     * The arcTo() method creates an arc/curve between two tangents on the canvas.
	     *
	     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
	     *
	     * @param {number} x1 - The x-coordinate of the beginning of the arc
	     * @param {number} y1 - The y-coordinate of the beginning of the arc
	     * @param {number} x2 - The x-coordinate of the end of the arc
	     * @param {number} y2 - The y-coordinate of the end of the arc
	     * @param {number} radius - The radius of the arc
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'arcTo',
	    value: function arcTo(x1, y1, x2, y2, radius) {
	      if (this.currentPath) {
	        if (this.currentPath.shape.points.length === 0) {
	          this.currentPath.shape.points.push(x1, y1);
	        }
	      } else {
	        this.moveTo(x1, y1);
	      }

	      var points = this.currentPath.shape.points;
	      var fromX = points[points.length - 2];
	      var fromY = points[points.length - 1];
	      var a1 = fromY - y1;
	      var b1 = fromX - x1;
	      var a2 = y2 - y1;
	      var b2 = x2 - x1;
	      var mm = Math.abs(a1 * b2 - b1 * a2);

	      if (mm < 1.0e-8 || radius === 0) {
	        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
	          points.push(x1, y1);
	        }
	      } else {
	        var dd = a1 * a1 + b1 * b1;
	        var cc = a2 * a2 + b2 * b2;
	        var tt = a1 * a2 + b1 * b2;
	        var k1 = radius * Math.sqrt(dd) / mm;
	        var k2 = radius * Math.sqrt(cc) / mm;
	        var j1 = k1 * tt / dd;
	        var j2 = k2 * tt / cc;
	        var cx = k1 * b2 + k2 * b1;
	        var cy = k1 * a2 + k2 * a1;
	        var px = b1 * (k2 + j1);
	        var py = a1 * (k2 + j1);
	        var qx = b2 * (k1 + j2);
	        var qy = a2 * (k1 + j2);
	        var startAngle = Math.atan2(py - cy, px - cx);
	        var endAngle = Math.atan2(qy - cy, qx - cx);

	        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
	      }

	      this.dirty++;

	      return this;
	    }

	    /**
	     * The arc method creates an arc/curve (used to create circles, or parts of circles).
	     *
	     * @param {number} cx - The x-coordinate of the center of the circle
	     * @param {number} cy - The y-coordinate of the center of the circle
	     * @param {number} radius - The radius of the circle
	     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
	     *  of the arc's circle)
	     * @param {number} endAngle - The ending angle, in radians
	     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
	     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
	     *  indicates counter-clockwise.
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'arc',
	    value: function arc(cx, cy, radius, startAngle, endAngle) {
	      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

	      if (startAngle === endAngle) {
	        return this;
	      }

	      if (!anticlockwise && endAngle <= startAngle) {
	        endAngle += Math.PI * 2;
	      } else if (anticlockwise && startAngle <= endAngle) {
	        startAngle += Math.PI * 2;
	      }

	      var sweep = endAngle - startAngle;
	      var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

	      if (sweep === 0) {
	        return this;
	      }

	      var startX = cx + Math.cos(startAngle) * radius;
	      var startY = cy + Math.sin(startAngle) * radius;

	      // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
	      var points = this.currentPath ? this.currentPath.shape.points : null;

	      if (points) {
	        if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
	          points.push(startX, startY);
	        }
	      } else {
	        this.moveTo(startX, startY);
	        points = this.currentPath.shape.points;
	      }

	      var theta = sweep / (segs * 2);
	      var theta2 = theta * 2;

	      var cTheta = Math.cos(theta);
	      var sTheta = Math.sin(theta);

	      var segMinus = segs - 1;

	      var remainder = segMinus % 1 / segMinus;

	      for (var i = 0; i <= segMinus; ++i) {
	        var real = i + remainder * i;

	        var angle = theta + startAngle + theta2 * real;

	        var c = Math.cos(angle);
	        var s = -Math.sin(angle);

	        points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
	      }

	      this.dirty++;

	      return this;
	    }

	    /**
	     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
	     * (such as lineTo() or drawCircle()) use when drawing.
	     *
	     * @param {number} [color=0] - the color of the fill
	     * @param {number} [alpha=1] - the alpha of the fill
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'beginFill',
	    value: function beginFill() {
	      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	      this.filling = true;
	      this.fillColor = color;
	      this.fillAlpha = alpha;

	      if (this.currentPath) {
	        if (this.currentPath.shape.points.length <= 2) {
	          this.currentPath.fill = this.filling;
	          this.currentPath.fillColor = this.fillColor;
	          this.currentPath.fillAlpha = this.fillAlpha;
	        }
	      }

	      return this;
	    }

	    /**
	     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
	     *
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'endFill',
	    value: function endFill() {
	      this.filling = false;
	      this.fillColor = null;
	      this.fillAlpha = 1;

	      return this;
	    }

	    /**
	     *
	     * @param {number} x - The X coord of the top-left of the rectangle
	     * @param {number} y - The Y coord of the top-left of the rectangle
	     * @param {number} width - The width of the rectangle
	     * @param {number} height - The height of the rectangle
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'drawRect',
	    value: function drawRect(x, y, width, height) {
	      this.drawShape(new _math.Rectangle(x, y, width, height));

	      return this;
	    }

	    /**
	     *
	     * @param {number} x - The X coord of the top-left of the rectangle
	     * @param {number} y - The Y coord of the top-left of the rectangle
	     * @param {number} width - The width of the rectangle
	     * @param {number} height - The height of the rectangle
	     * @param {number} radius - Radius of the rectangle corners
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'drawRoundedRect',
	    value: function drawRoundedRect(x, y, width, height, radius) {
	      this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));

	      return this;
	    }

	    /**
	     * Draws a circle.
	     *
	     * @param {number} x - The X coordinate of the center of the circle
	     * @param {number} y - The Y coordinate of the center of the circle
	     * @param {number} radius - The radius of the circle
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'drawCircle',
	    value: function drawCircle(x, y, radius) {
	      this.drawShape(new _math.Circle(x, y, radius));

	      return this;
	    }

	    /**
	     * Draws an ellipse.
	     *
	     * @param {number} x - The X coordinate of the center of the ellipse
	     * @param {number} y - The Y coordinate of the center of the ellipse
	     * @param {number} width - The half width of the ellipse
	     * @param {number} height - The half height of the ellipse
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'drawEllipse',
	    value: function drawEllipse(x, y, width, height) {
	      this.drawShape(new _math.Ellipse(x, y, width, height));

	      return this;
	    }

	    /**
	     * Draws a polygon using the given path.
	     *
	     * @param {number[]|Tiny.Point[]} path - The path data used to construct the polygon.
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'drawPolygon',
	    value: function drawPolygon(path) {
	      // prevents an argument assignment deopt
	      // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	      var points = path;

	      var closed = true;

	      if (points instanceof _math.Polygon) {
	        closed = points.closed;
	        points = points.points;
	      }

	      if (!Array.isArray(points)) {
	        // prevents an argument leak deopt
	        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	        points = new Array(arguments.length);

	        for (var i = 0; i < points.length; ++i) {
	          points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
	        }
	      }

	      var shape = new _math.Polygon(points);

	      shape.closed = closed;

	      this.drawShape(shape);

	      return this;
	    }

	    /**
	     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
	     *
	     * @return {Tiny.Graphics} This Graphics object. Good for chaining method calls
	     */

	  }, {
	    key: 'clear',
	    value: function clear() {
	      if (this.lineWidth || this.filling || this.graphicsData.length > 0) {
	        this.lineWidth = 0;
	        this.filling = false;

	        this.boundsDirty = -1;
	        this.dirty++;
	        this.clearDirty++;
	        this.graphicsData.length = 0;
	      }

	      this.currentPath = null;
	      this._spriteRect = null;

	      return this;
	    }

	    /**
	     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
	     * masked with gl.scissor.
	     *
	     * @return {boolean} True if only 1 rect.
	     */

	  }, {
	    key: 'isFastRect',
	    value: function isFastRect() {
	      return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;
	    }

	    /**
	     * Renders the object using the WebGL renderer
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      // if the sprite is not visible or the alpha is 0 then no need to render this element
	      if (this.dirty !== this.fastRectDirty) {
	        this.fastRectDirty = this.dirty;
	        this._fastRect = this.isFastRect();
	      }

	      // TODO this check can be moved to dirty?
	      if (this._fastRect) {
	        this._renderSpriteRect(renderer);
	      } else {
	        renderer.setObjectRenderer(renderer.plugins.graphics);
	        renderer.plugins.graphics.render(this);
	      }
	    }

	    /**
	     * Renders a sprite rectangle.
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderSpriteRect',
	    value: function _renderSpriteRect(renderer) {
	      var rect = this.graphicsData[0].shape;

	      if (!this._spriteRect) {
	        if (!Graphics._SPRITE_TEXTURE) {
	          Graphics._SPRITE_TEXTURE = _RenderTexture2.default.create(10, 10);

	          var canvas = document.createElement('canvas');

	          canvas.width = 10;
	          canvas.height = 10;

	          var context = canvas.getContext('2d');

	          context.fillStyle = 'white';
	          context.fillRect(0, 0, 10, 10);

	          Graphics._SPRITE_TEXTURE = _Texture2.default.fromCanvas(canvas);
	        }

	        this._spriteRect = new _Sprite2.default(Graphics._SPRITE_TEXTURE);
	      }
	      if (this.tint === 0xffffff) {
	        this._spriteRect.tint = this.graphicsData[0].fillColor;
	      } else {
	        var t1 = tempColor1;
	        var t2 = tempColor2;

	        (0, _utils.hex2rgb)(this.graphicsData[0].fillColor, t1);
	        (0, _utils.hex2rgb)(this.tint, t2);

	        t1[0] *= t2[0];
	        t1[1] *= t2[1];
	        t1[2] *= t2[2];

	        this._spriteRect.tint = (0, _utils.rgb2hex)(t1);
	      }
	      this._spriteRect.alpha = this.graphicsData[0].fillAlpha;
	      this._spriteRect.worldAlpha = this.worldAlpha * this._spriteRect.alpha;

	      Graphics._SPRITE_TEXTURE._frame.width = rect.width;
	      Graphics._SPRITE_TEXTURE._frame.height = rect.height;

	      this._spriteRect.transform.worldTransform = this.transform.worldTransform;

	      this._spriteRect.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
	      this._spriteRect._onAnchorUpdate();

	      this._spriteRect._renderWebGL(renderer);
	    }

	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      if (this.isMask === true) {
	        return;
	      }

	      renderer.plugins.graphics.render(this);
	    }

	    /**
	     * Retrieves the bounds of the graphic shape as a rectangle object
	     *
	     * @private
	     */

	  }, {
	    key: '_calculateBounds',
	    value: function _calculateBounds() {
	      if (this.boundsDirty !== this.dirty) {
	        this.boundsDirty = this.dirty;
	        this.updateLocalBounds();

	        this.cachedSpriteDirty = true;
	      }

	      var lb = this._localBounds;

	      this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
	    }

	    /**
	     * Tests if a point is inside this graphics object
	     *
	     * @param {Tiny.Point} point - the point to test
	     * @return {boolean} the result of the test
	     */

	  }, {
	    key: 'containsPoint',
	    value: function containsPoint(point) {
	      this.worldTransform.applyInverse(point, tempPoint);

	      var graphicsData = this.graphicsData;

	      for (var i = 0; i < graphicsData.length; ++i) {
	        var data = graphicsData[i];

	        if (!data.fill) {
	          continue;
	        }

	        // only deal with fills..
	        if (data.shape) {
	          if (data.shape.contains(tempPoint.x, tempPoint.y)) {
	            return true;
	          }
	        }
	      }

	      return false;
	    }

	    /**
	     * Update the bounds of the object
	     *
	     */

	  }, {
	    key: 'updateLocalBounds',
	    value: function updateLocalBounds() {
	      var minX = Infinity;
	      var maxX = -Infinity;

	      var minY = Infinity;
	      var maxY = -Infinity;

	      if (this.graphicsData.length) {
	        var shape = 0;
	        var x = 0;
	        var y = 0;
	        var w = 0;
	        var h = 0;

	        for (var i = 0; i < this.graphicsData.length; i++) {
	          var data = this.graphicsData[i];
	          var type = data.type;
	          var lineWidth = data.lineWidth;

	          shape = data.shape;

	          if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {
	            x = shape.x - lineWidth / 2;
	            y = shape.y - lineWidth / 2;
	            w = shape.width + lineWidth;
	            h = shape.height + lineWidth;

	            minX = x < minX ? x : minX;
	            maxX = x + w > maxX ? x + w : maxX;

	            minY = y < minY ? y : minY;
	            maxY = y + h > maxY ? y + h : maxY;
	          } else if (type === _const.SHAPES.CIRC) {
	            x = shape.x;
	            y = shape.y;
	            w = shape.radius + lineWidth / 2;
	            h = shape.radius + lineWidth / 2;

	            minX = x - w < minX ? x - w : minX;
	            maxX = x + w > maxX ? x + w : maxX;

	            minY = y - h < minY ? y - h : minY;
	            maxY = y + h > maxY ? y + h : maxY;
	          } else if (type === _const.SHAPES.ELIP) {
	            x = shape.x;
	            y = shape.y;
	            w = shape.width + lineWidth / 2;
	            h = shape.height + lineWidth / 2;

	            minX = x - w < minX ? x - w : minX;
	            maxX = x + w > maxX ? x + w : maxX;

	            minY = y - h < minY ? y - h : minY;
	            maxY = y + h > maxY ? y + h : maxY;
	          } else {
	            // POLY
	            var points = shape.points;
	            var x2 = 0;
	            var y2 = 0;
	            var dx = 0;
	            var dy = 0;
	            var rw = 0;
	            var rh = 0;
	            var cx = 0;
	            var cy = 0;

	            for (var j = 0; j + 2 < points.length; j += 2) {
	              x = points[j];
	              y = points[j + 1];
	              x2 = points[j + 2];
	              y2 = points[j + 3];
	              dx = Math.abs(x2 - x);
	              dy = Math.abs(y2 - y);
	              h = lineWidth;
	              w = Math.sqrt(dx * dx + dy * dy);

	              if (w < 1e-9) {
	                continue;
	              }

	              rw = (h / w * dy + dx) / 2;
	              rh = (h / w * dx + dy) / 2;
	              cx = (x2 + x) / 2;
	              cy = (y2 + y) / 2;

	              minX = cx - rw < minX ? cx - rw : minX;
	              maxX = cx + rw > maxX ? cx + rw : maxX;

	              minY = cy - rh < minY ? cy - rh : minY;
	              maxY = cy + rh > maxY ? cy + rh : maxY;
	            }
	          }
	        }
	      } else {
	        minX = 0;
	        maxX = 0;
	        minY = 0;
	        maxY = 0;
	      }

	      var padding = this.boundsPadding;

	      this._localBounds.minX = minX - padding;
	      this._localBounds.maxX = maxX + padding * 2;

	      this._localBounds.minY = minY - padding;
	      this._localBounds.maxY = maxY + padding * 2;
	    }

	    /**
	     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	     *
	     * @param {Tiny.Circle|Tiny.Ellipse|Tiny.Polygon|Tiny.Rectangle|Tiny.RoundedRectangle} shape - The shape object to draw.
	     * @return {Tiny.GraphicsData} The generated GraphicsData object.
	     */

	  }, {
	    key: 'drawShape',
	    value: function drawShape(shape) {
	      if (this.currentPath) {
	        // check current path!
	        if (this.currentPath.shape.points.length <= 2) {
	          this.graphicsData.pop();
	        }
	      }

	      this.currentPath = null;

	      var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);

	      this.graphicsData.push(data);

	      if (data.type === _const.SHAPES.POLY) {
	        data.shape.closed = data.shape.closed || this.filling;
	        this.currentPath = data;
	      }

	      this.dirty++;

	      return data;
	    }

	    /**
	     * Generates a canvas texture.
	     *
	     * @param {number} scaleMode - The scale mode of the texture.
	     * @param {number} resolution - The resolution of the texture.
	     * @return {Tiny.Texture} The new texture.
	     */

	  }, {
	    key: 'generateCanvasTexture',
	    value: function generateCanvasTexture(scaleMode) {
	      var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	      var bounds = this.getLocalBounds();

	      var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);

	      if (!canvasRenderer) {
	        canvasRenderer = new _CanvasRenderer2.default();
	      }

	      tempMatrix.tx = -bounds.x;
	      tempMatrix.ty = -bounds.y;

	      canvasRenderer.render(this, canvasBuffer, false, tempMatrix);

	      var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode);

	      texture.baseTexture.resolution = resolution;
	      texture.baseTexture.update();

	      return texture;
	    }

	    /**
	     * Closes the current path.
	     *
	     * @return {Tiny.Graphics} Returns itself.
	     */

	  }, {
	    key: 'closePath',
	    value: function closePath() {
	      // ok so close path assumes next one is a hole!
	      var currentPath = this.currentPath;

	      if (currentPath && currentPath.shape) {
	        currentPath.shape.close();
	      }

	      return this;
	    }

	    /**
	     * Adds a hole in the current path.
	     *
	     * @return {Tiny.Graphics} Returns itself.
	     */

	  }, {
	    key: 'addHole',
	    value: function addHole() {
	      // this is a hole!
	      var hole = this.graphicsData.pop();

	      this.currentPath = this.graphicsData[this.graphicsData.length - 1];

	      this.currentPath.addHole(hole.shape);
	      this.currentPath = null;

	      return this;
	    }

	    /**
	     * Destroys the Graphics object.
	     *
	     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
	     *  options have been set to that value
	     * @param {boolean} [options.children=false] - if set to true, all the children will have
	     *  their destroy method called as well. 'options' will be passed on to those calls.
	     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the texture of the child sprite
	     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the base texture of the child sprite
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(options) {
	      _get(Graphics.prototype.__proto__ || Object.getPrototypeOf(Graphics.prototype), 'destroy', this).call(this, options);

	      // destroy each of the GraphicsData objects
	      for (var i = 0; i < this.graphicsData.length; ++i) {
	        this.graphicsData[i].destroy();
	      }

	      // for each webgl data entry, destroy the WebGLGraphicsData
	      for (var id in this._webgl) {
	        for (var j = 0; j < this._webgl[id].data.length; ++j) {
	          this._webgl[id].data[j].destroy();
	        }
	      }

	      if (this._spriteRect) {
	        this._spriteRect.destroy();
	      }

	      this.graphicsData = null;

	      this.currentPath = null;
	      this._webgl = null;
	      this._localBounds = null;
	    }
	  }]);

	  return Graphics;
	}(_Container3.default);

	exports.default = Graphics;


	Graphics._SPRITE_TEXTURE = null;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A GraphicsData object.
	 *
	 * @class
	 * @memberof Tiny
	 */
	var GraphicsData = function () {
	  /**
	   *
	   * @param {number} lineWidth - the width of the line to draw
	   * @param {number} lineColor - the color of the line to draw
	   * @param {number} lineAlpha - the alpha of the line to draw
	   * @param {number} fillColor - the color of the fill
	   * @param {number} fillAlpha - the alpha of the fill
	   * @param {boolean} fill - whether or not the shape is filled with a colour
	   * @param {Tiny.Circle|Tiny.Rectangle|Tiny.Ellipse|Tiny.Polygon} shape - The shape object to draw.
	   */
	  function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
	    _classCallCheck(this, GraphicsData);

	    /**
	     * @member {number} the width of the line to draw
	     */
	    this.lineWidth = lineWidth;

	    /**
	     * @member {number} the color of the line to draw
	     */
	    this.lineColor = lineColor;

	    /**
	     * @member {number} the alpha of the line to draw
	     */
	    this.lineAlpha = lineAlpha;

	    /**
	     * @member {number} cached tint of the line to draw
	     */
	    this._lineTint = lineColor;

	    /**
	     * @member {number} the color of the fill
	     */
	    this.fillColor = fillColor;

	    /**
	     * @member {number} the alpha of the fill
	     */
	    this.fillAlpha = fillAlpha;

	    /**
	     * @member {number} cached tint of the fill
	     */
	    this._fillTint = fillColor;

	    /**
	     * @member {boolean} whether or not the shape is filled with a colour
	     */
	    this.fill = fill;

	    this.holes = [];

	    /**
	     * @member {Tiny.Circle|Tiny.Ellipse|Tiny.Polygon|Tiny.Rectangle|Tiny.RoundedRectangle} The shape object to draw.
	     */
	    this.shape = shape;

	    /**
	     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
	     */
	    this.type = shape.type;
	  }

	  /**
	   * Creates a new GraphicsData object with the same values as this one.
	   *
	   * @return {Tiny.GraphicsData} Cloned GraphicsData object
	   */


	  _createClass(GraphicsData, [{
	    key: "clone",
	    value: function clone() {
	      return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
	    }

	    /**
	     * Adds a hole to the shape.
	     *
	     * @param {Tiny.Rectangle|Tiny.Circle} shape - The shape of the hole.
	     */

	  }, {
	    key: "addHole",
	    value: function addHole(shape) {
	      this.holes.push(shape);
	    }

	    /**
	     * Destroys the Graphics data.
	     */

	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.shape = null;
	      this.holes = null;
	    }
	  }]);

	  return GraphicsData;
	}();

	exports.default = GraphicsData;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = bezierCurveTo;
	/**
	 * Calculate the points for a bezier curve and then draws it.
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @param {number} fromX - Starting point x
	 * @param {number} fromY - Starting point y
	 * @param {number} cpX - Control point x
	 * @param {number} cpY - Control point y
	 * @param {number} cpX2 - Second Control point x
	 * @param {number} cpY2 - Second Control point y
	 * @param {number} toX - Destination point x
	 * @param {number} toY - Destination point y
	 * @param {number[]} [path=[]] - Path array to push points into
	 * @return {number[]} Array of points of the curve
	 */
	function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
	  var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];

	  var n = 20;
	  var dt = 0;
	  var dt2 = 0;
	  var dt3 = 0;
	  var t2 = 0;
	  var t3 = 0;

	  path.push(fromX, fromY);

	  for (var i = 1, j = 0; i <= n; ++i) {
	    j = i / n;

	    dt = 1 - j;
	    dt2 = dt * dt;
	    dt3 = dt2 * dt;

	    t2 = j * j;
	    t3 = t2 * j;

	    path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
	  }

	  return path;
	}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(18);

	var _const = __webpack_require__(7);

	var _ObjectRenderer2 = __webpack_require__(80);

	var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);

	var _WebGLRenderer = __webpack_require__(82);

	var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

	var _WebGLGraphicsData = __webpack_require__(110);

	var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);

	var _PrimitiveShader = __webpack_require__(111);

	var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);

	var _buildPoly = __webpack_require__(112);

	var _buildPoly2 = _interopRequireDefault(_buildPoly);

	var _buildRectangle = __webpack_require__(115);

	var _buildRectangle2 = _interopRequireDefault(_buildRectangle);

	var _buildRoundedRectangle = __webpack_require__(116);

	var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);

	var _buildCircle = __webpack_require__(117);

	var _buildCircle2 = _interopRequireDefault(_buildCircle);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Renders the graphics object.
	 *
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.ObjectRenderer
	 */
	var GraphicsRenderer = function (_ObjectRenderer) {
	  _inherits(GraphicsRenderer, _ObjectRenderer);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this object renderer works for.
	   */
	  function GraphicsRenderer(renderer) {
	    _classCallCheck(this, GraphicsRenderer);

	    var _this = _possibleConstructorReturn(this, (GraphicsRenderer.__proto__ || Object.getPrototypeOf(GraphicsRenderer)).call(this, renderer));

	    _this.graphicsDataPool = [];

	    _this.primitiveShader = null;

	    _this.gl = renderer.gl;

	    // easy access!
	    _this.CONTEXT_UID = 0;
	    return _this;
	  }

	  /**
	   * Called when there is a WebGL context change
	   *
	   * @private
	   *
	   */


	  _createClass(GraphicsRenderer, [{
	    key: 'onContextChange',
	    value: function onContextChange() {
	      this.gl = this.renderer.gl;
	      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
	      this.primitiveShader = new _PrimitiveShader2.default(this.gl);
	    }

	    /**
	     * Destroys this renderer.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      _ObjectRenderer3.default.prototype.destroy.call(this);

	      for (var i = 0; i < this.graphicsDataPool.length; ++i) {
	        this.graphicsDataPool[i].destroy();
	      }

	      this.graphicsDataPool = null;
	    }

	    /**
	     * Renders a graphics object.
	     *
	     * @param {Tiny.Graphics} graphics - The graphics object to render.
	     */

	  }, {
	    key: 'render',
	    value: function render(graphics) {
	      var renderer = this.renderer;
	      var gl = renderer.gl;

	      var webGLData = void 0;
	      var webGL = graphics._webGL[this.CONTEXT_UID];

	      if (!webGL || graphics.dirty !== webGL.dirty) {
	        this.updateGraphics(graphics);

	        webGL = graphics._webGL[this.CONTEXT_UID];
	      }

	      // This  could be speeded up for sure!
	      var shader = this.primitiveShader;

	      renderer.bindShader(shader);
	      renderer.state.setBlendMode(graphics.blendMode);

	      for (var i = 0, n = webGL.data.length; i < n; i++) {
	        webGLData = webGL.data[i];
	        var shaderTemp = webGLData.shader;

	        renderer.bindShader(shaderTemp);
	        shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
	        shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
	        shaderTemp.uniforms.alpha = graphics.worldAlpha;

	        renderer.bindVao(webGLData.vao);
	        webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
	      }
	    }

	    /**
	     * Updates the graphics object
	     *
	     * @private
	     * @param {Tiny.Graphics} graphics - The graphics object to update
	     */

	  }, {
	    key: 'updateGraphics',
	    value: function updateGraphics(graphics) {
	      var gl = this.renderer.gl;

	      // get the contexts graphics object
	      var webGL = graphics._webGL[this.CONTEXT_UID];

	      // if the graphics object does not exist in the webGL context time to create it!
	      if (!webGL) {
	        webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
	      }

	      // flag the graphics as not dirty as we are about to update it...
	      webGL.dirty = graphics.dirty;

	      // if the user cleared the graphics object we will need to clear every object
	      if (graphics.clearDirty !== webGL.clearDirty) {
	        webGL.clearDirty = graphics.clearDirty;

	        // loop through and return all the webGLDatas to the object pool so than can be reused later on
	        for (var i = 0; i < webGL.data.length; i++) {
	          this.graphicsDataPool.push(webGL.data[i]);
	        }

	        // clear the array and reset the index..
	        webGL.data.length = 0;
	        webGL.lastIndex = 0;
	      }

	      var webGLData = void 0;

	      // loop through the graphics datas and construct each one..
	      // if the object is a complex fill then the new stencil buffer technique will be used
	      // other wise graphics objects will be pushed into a batch..
	      for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
	        var data = graphics.graphicsData[_i];

	        // TODO - this can be simplified
	        webGLData = this.getWebGLData(webGL, 0);

	        if (data.type === _const.SHAPES.POLY) {
	          (0, _buildPoly2.default)(data, webGLData);
	        }
	        if (data.type === _const.SHAPES.RECT) {
	          (0, _buildRectangle2.default)(data, webGLData);
	        } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
	          (0, _buildCircle2.default)(data, webGLData);
	        } else if (data.type === _const.SHAPES.RREC) {
	          (0, _buildRoundedRectangle2.default)(data, webGLData);
	        }

	        webGL.lastIndex++;
	      }

	      this.renderer.bindVao(null);

	      // upload all the dirty data...
	      for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
	        webGLData = webGL.data[_i2];

	        if (webGLData.dirty) {
	          webGLData.upload();
	        }
	      }
	    }

	    /**
	     *
	     * @private
	     * @param {WebGLRenderingContext} gl - the current WebGL drawing context
	     * @param {number} type - TODO @Alvin
	     * @return {*} TODO
	     */

	  }, {
	    key: 'getWebGLData',
	    value: function getWebGLData(gl, type) {
	      var webGLData = gl.data[gl.data.length - 1];

	      if (!webGLData || webGLData.points.length > 320000) {
	        webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);

	        webGLData.reset(type);
	        gl.data.push(webGLData);
	      }

	      webGLData.dirty = true;

	      return webGLData;
	    }
	  }]);

	  return GraphicsRenderer;
	}(_ObjectRenderer3.default);

	exports.default = GraphicsRenderer;


	_WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * An object containing WebGL specific properties to be used by the WebGL renderer
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */
	var WebGLGraphicsData = function () {
	  /**
	   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
	   * @param {Tiny.Shader} shader - The shader
	   * @param {object} attribsState - The state for the VAO
	   */
	  function WebGLGraphicsData(gl, shader, attribsState) {
	    _classCallCheck(this, WebGLGraphicsData);

	    /**
	     * The current WebGL drawing context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    // TODO does this need to be split before uploading??
	    /**
	     * An array of color components (r,g,b)
	     * @member {number[]}
	     */
	    this.color = [0, 0, 0]; // color split!

	    /**
	     * An array of points to draw
	     * @member {Tiny.Point[]}
	     */
	    this.points = [];

	    /**
	     * The indices of the vertices
	     * @member {number[]}
	     */
	    this.indices = [];
	    /**
	     * The main buffer
	     * @member {WebGLBuffer}
	     */
	    this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);

	    /**
	     * The index buffer
	     * @member {WebGLBuffer}
	     */
	    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);

	    /**
	     * Whether this graphics is dirty or not
	     * @member {boolean}
	     */
	    this.dirty = true;

	    this.glPoints = null;
	    this.glIndices = null;

	    /**
	     *
	     * @member {Tiny.Shader}
	     */
	    this.shader = shader;

	    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
	  }

	  /**
	   * Resets the vertices and the indices
	   */


	  _createClass(WebGLGraphicsData, [{
	    key: 'reset',
	    value: function reset() {
	      this.points.length = 0;
	      this.indices.length = 0;
	    }

	    /**
	     * Binds the buffers and uploads the data
	     */

	  }, {
	    key: 'upload',
	    value: function upload() {
	      this.glPoints = new Float32Array(this.points);
	      this.buffer.upload(this.glPoints);

	      this.glIndices = new Uint16Array(this.indices);
	      this.indexBuffer.upload(this.glIndices);

	      this.dirty = false;
	    }

	    /**
	     * Empties all the data
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.color = null;
	      this.points = null;
	      this.indices = null;

	      this.vao.destroy();
	      this.buffer.destroy();
	      this.indexBuffer.destroy();

	      this.gl = null;

	      this.buffer = null;
	      this.indexBuffer = null;

	      this.glPoints = null;
	      this.glIndices = null;
	    }
	  }]);

	  return WebGLGraphicsData;
	}();

	exports.default = WebGLGraphicsData;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Shader2 = __webpack_require__(93);

	var _Shader3 = _interopRequireDefault(_Shader2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * This shader is used to draw simple primitive shapes for {@link Tiny.Graphics}.
	 *
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.Shader
	 */
	var PrimitiveShader = function (_Shader) {
	  _inherits(PrimitiveShader, _Shader);

	  /**
	   * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
	   */
	  function PrimitiveShader(gl) {
	    _classCallCheck(this, PrimitiveShader);

	    return _possibleConstructorReturn(this, (PrimitiveShader.__proto__ || Object.getPrototypeOf(PrimitiveShader)).call(this, gl,
	    // vertex shader
	    ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
	    // fragment shader
	    ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
	  }

	  return PrimitiveShader;
	}(_Shader3.default);

	exports.default = PrimitiveShader;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildPoly;

	var _buildLine = __webpack_require__(113);

	var _buildLine2 = _interopRequireDefault(_buildLine);

	var _utils = __webpack_require__(18);

	var _earcut = __webpack_require__(114);

	var _earcut2 = _interopRequireDefault(_earcut);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Builds a polygon to draw
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {Tiny.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
	 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
	 */
	function buildPoly(graphicsData, webGLData) {
	  graphicsData.points = graphicsData.shape.points.slice();

	  var points = graphicsData.points;

	  if (graphicsData.fill && points.length >= 6) {
	    var holeArray = [];
	    // Process holes..
	    var holes = graphicsData.holes;

	    for (var i = 0; i < holes.length; i++) {
	      var hole = holes[i];

	      holeArray.push(points.length / 2);

	      points = points.concat(hole.points);
	    }

	    // get first and last point.. figure out the middle!
	    var verts = webGLData.points;
	    var indices = webGLData.indices;

	    var length = points.length / 2;

	    // sort color
	    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
	    var alpha = graphicsData.fillAlpha;
	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;

	    var triangles = (0, _earcut2.default)(points, holeArray, 2);

	    if (!triangles) {
	      return;
	    }

	    var vertPos = verts.length / 6;

	    for (var _i = 0; _i < triangles.length; _i += 3) {
	      indices.push(triangles[_i] + vertPos);
	      indices.push(triangles[_i] + vertPos);
	      indices.push(triangles[_i + 1] + vertPos);
	      indices.push(triangles[_i + 2] + vertPos);
	      indices.push(triangles[_i + 2] + vertPos);
	    }

	    for (var _i2 = 0; _i2 < length; _i2++) {
	      verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
	    }
	  }

	  if (graphicsData.lineWidth > 0) {
	    (0, _buildLine2.default)(graphicsData, webGLData);
	  }
	}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildLine;

	var _math = __webpack_require__(8);

	var _utils = __webpack_require__(18);

	/**
	 * Builds a line to draw
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {Tiny.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
	 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
	 */
	function buildLine(graphicsData, webGLData) {
	  // TODO OPTIMISE!
	  var points = graphicsData.points;

	  if (points.length === 0) {
	    return;
	  }
	  // if the line width is an odd number add 0.5 to align to a whole pixel
	  // commenting this out fixes #711 and #1620
	  // if (graphicsData.lineWidth%2)
	  // {
	  //     for (i = 0; i < points.length; i++)
	  //     {
	  //         points[i] += 0.5;
	  //     }
	  // }

	  // get first and last point.. figure out the middle!
	  var firstPoint = new _math.Point(points[0], points[1]);
	  var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

	  // if the first point is the last point - gonna have issues :)
	  if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
	    // need to clone as we are going to slightly modify the shape..
	    points = points.slice();

	    points.pop();
	    points.pop();

	    lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);

	    var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
	    var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

	    points.unshift(midPointX, midPointY);
	    points.push(midPointX, midPointY);
	  }

	  var verts = webGLData.points;
	  var indices = webGLData.indices;
	  var length = points.length / 2;
	  var indexCount = points.length;
	  var indexStart = verts.length / 6;

	  // DRAW the Line
	  var width = graphicsData.lineWidth / 2;

	  // sort color
	  var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
	  var alpha = graphicsData.lineAlpha;
	  var r = color[0] * alpha;
	  var g = color[1] * alpha;
	  var b = color[2] * alpha;

	  var p1x = points[0];
	  var p1y = points[1];
	  var p2x = points[2];
	  var p2y = points[3];
	  var p3x = 0;
	  var p3y = 0;

	  var perpx = -(p1y - p2y);
	  var perpy = p1x - p2x;
	  var perp2x = 0;
	  var perp2y = 0;
	  var perp3x = 0;
	  var perp3y = 0;

	  var dist = Math.sqrt(perpx * perpx + perpy * perpy);

	  perpx /= dist;
	  perpy /= dist;
	  perpx *= width;
	  perpy *= width;

	  // start
	  verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);

	  verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);

	  for (var i = 1; i < length - 1; ++i) {
	    p1x = points[(i - 1) * 2];
	    p1y = points[(i - 1) * 2 + 1];

	    p2x = points[i * 2];
	    p2y = points[i * 2 + 1];

	    p3x = points[(i + 1) * 2];
	    p3y = points[(i + 1) * 2 + 1];

	    perpx = -(p1y - p2y);
	    perpy = p1x - p2x;

	    dist = Math.sqrt(perpx * perpx + perpy * perpy);
	    perpx /= dist;
	    perpy /= dist;
	    perpx *= width;
	    perpy *= width;

	    perp2x = -(p2y - p3y);
	    perp2y = p2x - p3x;

	    dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
	    perp2x /= dist;
	    perp2y /= dist;
	    perp2x *= width;
	    perp2y *= width;

	    var a1 = -perpy + p1y - (-perpy + p2y);
	    var b1 = -perpx + p2x - (-perpx + p1x);
	    var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
	    var a2 = -perp2y + p3y - (-perp2y + p2y);
	    var b2 = -perp2x + p2x - (-perp2x + p3x);
	    var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

	    var denom = a1 * b2 - a2 * b1;

	    if (Math.abs(denom) < 0.1) {
	      denom += 10.1;
	      verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);

	      verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);

	      continue;
	    }

	    var px = (b1 * c2 - b2 * c1) / denom;
	    var py = (a2 * c1 - a1 * c2) / denom;
	    var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

	    if (pdist > 196 * width * width) {
	      perp3x = perpx - perp2x;
	      perp3y = perpy - perp2y;

	      dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
	      perp3x /= dist;
	      perp3y /= dist;
	      perp3x *= width;
	      perp3y *= width;

	      verts.push(p2x - perp3x, p2y - perp3y);
	      verts.push(r, g, b, alpha);

	      verts.push(p2x + perp3x, p2y + perp3y);
	      verts.push(r, g, b, alpha);

	      verts.push(p2x - perp3x, p2y - perp3y);
	      verts.push(r, g, b, alpha);

	      indexCount++;
	    } else {
	      verts.push(px, py);
	      verts.push(r, g, b, alpha);

	      verts.push(p2x - (px - p2x), p2y - (py - p2y));
	      verts.push(r, g, b, alpha);
	    }
	  }

	  p1x = points[(length - 2) * 2];
	  p1y = points[(length - 2) * 2 + 1];

	  p2x = points[(length - 1) * 2];
	  p2y = points[(length - 1) * 2 + 1];

	  perpx = -(p1y - p2y);
	  perpy = p1x - p2x;

	  dist = Math.sqrt(perpx * perpx + perpy * perpy);
	  perpx /= dist;
	  perpy /= dist;
	  perpx *= width;
	  perpy *= width;

	  verts.push(p2x - perpx, p2y - perpy);
	  verts.push(r, g, b, alpha);

	  verts.push(p2x + perpx, p2y + perpy);
	  verts.push(r, g, b, alpha);

	  indices.push(indexStart);

	  for (var _i = 0; _i < indexCount; ++_i) {
	    indices.push(indexStart++);
	  }

	  indices.push(indexStart - 1);
	}

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = earcut;

	function earcut(data, holeIndices, dim) {

	    dim = dim || 2;

	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];

	    if (!outerNode) return triangles;

	    var minX, minY, maxX, maxY, x, y, size;

	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];

	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        // minX, minY and size are later used to transform coords into integers for z-order calculation
	        size = Math.max(maxX - minX, maxY - minY);
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, size);

	    return triangles;
	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;

	    if (clockwise === signedArea(data, start, end, dim) > 0) {
	        for (i = start; i < end; i += dim) {
	            last = insertNode(i, data[i], data[i + 1], last);
	        }
	    } else {
	        for (i = end - dim; i >= start; i -= dim) {
	            last = insertNode(i, data[i], data[i + 1], last);
	        }
	    }

	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }

	    return last;
	}

	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    var p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) return null;
	            again = true;
	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
	    if (!ear) return;

	    // interlink polygon nodes in z-order
	    if (!pass && size) indexCurve(ear, minX, minY, size);

	    var stop = ear,
	        prev,
	        next;

	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;

	        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);

	            removeNode(ear);

	            // skipping the next vertice leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

	                // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(ear, triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

	                // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, size);
	            }

	            break;
	        }
	    }
	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;

	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed(ear, minX, minY, size) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
	        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
	        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
	        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;

	    // z-order range for the current triangle bbox;
	    var minZ = zOrder(minTX, minTY, minX, minY, size),
	        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

	    // first look for points inside the triangle in increasing z-order
	    var p = ear.nextZ;

	    while (p && p.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.nextZ;
	    }

	    // then look for points in decreasing z-order
	    p = ear.prevZ;

	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    return true;
	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;

	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);

	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return p;
	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, size) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon(a, b);

	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);

	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, size);
	                earcutLinked(c, triangles, dim, minX, minY, size);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i,
	        len,
	        start,
	        end,
	        list;

	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }

	    queue.sort(compareX);

	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }

	    return outerNode;
	}

	function compareX(a, b) {
	    return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    outerNode = findHoleBridge(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon(outerNode, hole);
	        filterPoints(b, b.next);
	    }
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;

	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point

	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;

	    p = m.next;

	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    }

	    return m;
	}

	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, size) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    var i,
	        p,
	        q,
	        e,
	        tail,
	        numMerges,
	        pSize,
	        qSize,
	        inSize = 1;

	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }

	            qSize = inSize;

	            while (pSize > 0 || qSize > 0 && q) {

	                if (pSize === 0) {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                } else if (qSize === 0 || !q) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else if (p.z <= q.z) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;
	    } while (numMerges > 1);

	    return list;
	}

	// z-order of a point given coords and size of the data bounding box
	function zOrder(x, y, minX, minY, size) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) / size;
	    y = 32767 * (y - minY) / size;

	    x = (x | x << 8) & 0x00FF00FF;
	    x = (x | x << 4) & 0x0F0F0F0F;
	    x = (x | x << 2) & 0x33333333;
	    x = (x | x << 1) & 0x55555555;

	    y = (y | y << 8) & 0x00FF00FF;
	    y = (y | y << 4) & 0x0F0F0F0F;
	    y = (y | y << 2) & 0x33333333;
	    y = (y | y << 1) & 0x55555555;

	    return x | y << 1;
	}

	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}

	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
	    if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
	    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y),
	        b2 = new Node(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;
	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
	    // vertice index in coordinates array
	    this.i = i;

	    // vertex coordinates
	    this.x = x;
	    this.y = y;

	    // previous and next vertice nodes in a polygon ring
	    this.prev = null;
	    this.next = null;

	    // z-order curve value
	    this.z = null;

	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;

	    // indicates whether this is a steiner point
	    this.steiner = false;
	}

	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }

	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }

	    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
	};

	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = { vertices: [], holes: [], dimensions: dim },
	        holeIndex = 0;

	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) {
	                result.vertices.push(data[i][j][d]);
	            }
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildRectangle;

	var _buildLine = __webpack_require__(113);

	var _buildLine2 = _interopRequireDefault(_buildLine);

	var _utils = __webpack_require__(18);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Builds a rectangle to draw
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {Tiny.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
	 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
	 */
	function buildRectangle(graphicsData, webGLData) {
	  // --- //
	  // need to convert points to a nice regular data
	  //
	  var rectData = graphicsData.shape;
	  var x = rectData.x;
	  var y = rectData.y;
	  var width = rectData.width;
	  var height = rectData.height;

	  if (graphicsData.fill) {
	    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
	    var alpha = graphicsData.fillAlpha;

	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;

	    var verts = webGLData.points;
	    var indices = webGLData.indices;

	    var vertPos = verts.length / 6;

	    // start
	    verts.push(x, y);
	    verts.push(r, g, b, alpha);

	    verts.push(x + width, y);
	    verts.push(r, g, b, alpha);

	    verts.push(x, y + height);
	    verts.push(r, g, b, alpha);

	    verts.push(x + width, y + height);
	    verts.push(r, g, b, alpha);

	    // insert 2 dead triangles..
	    indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
	  }

	  if (graphicsData.lineWidth) {
	    var tempPoints = graphicsData.points;

	    graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

	    (0, _buildLine2.default)(graphicsData, webGLData);

	    graphicsData.points = tempPoints;
	  }
	}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildRoundedRectangle;

	var _earcut = __webpack_require__(114);

	var _earcut2 = _interopRequireDefault(_earcut);

	var _buildLine = __webpack_require__(113);

	var _buildLine2 = _interopRequireDefault(_buildLine);

	var _utils = __webpack_require__(18);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Builds a rounded rectangle to draw
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {Tiny.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
	 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
	 */
	function buildRoundedRectangle(graphicsData, webGLData) {
	  var rrectData = graphicsData.shape;
	  var x = rrectData.x;
	  var y = rrectData.y;
	  var width = rrectData.width;
	  var height = rrectData.height;

	  var radius = rrectData.radius;

	  var recPoints = [];

	  recPoints.push(x, y + radius);
	  quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
	  quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
	  quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
	  quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);

	  // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
	  // TODO - fix this properly, this is not very elegant.. but it works for now.

	  if (graphicsData.fill) {
	    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
	    var alpha = graphicsData.fillAlpha;

	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;

	    var verts = webGLData.points;
	    var indices = webGLData.indices;

	    var vecPos = verts.length / 6;

	    var triangles = (0, _earcut2.default)(recPoints, null, 2);

	    for (var i = 0, j = triangles.length; i < j; i += 3) {
	      indices.push(triangles[i] + vecPos);
	      indices.push(triangles[i] + vecPos);
	      indices.push(triangles[i + 1] + vecPos);
	      indices.push(triangles[i + 2] + vecPos);
	      indices.push(triangles[i + 2] + vecPos);
	    }

	    for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
	      verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
	    }
	  }

	  if (graphicsData.lineWidth) {
	    var tempPoints = graphicsData.points;

	    graphicsData.points = recPoints;

	    (0, _buildLine2.default)(graphicsData, webGLData);

	    graphicsData.points = tempPoints;
	  }
	}

	/**
	 * Calculate the points for a quadratic bezier curve. (helper function..)
	 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {number} fromX - Origin point x
	 * @param {number} fromY - Origin point x
	 * @param {number} cpX - Control point x
	 * @param {number} cpY - Control point y
	 * @param {number} toX - Destination point x
	 * @param {number} toY - Destination point y
	 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
	 * @return {number[]} an array of points
	 */
	function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
	  var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

	  var n = 20;
	  var points = out;

	  var xa = 0;
	  var ya = 0;
	  var xb = 0;
	  var yb = 0;
	  var x = 0;
	  var y = 0;

	  function getPt(n1, n2, perc) {
	    var diff = n2 - n1;

	    return n1 + diff * perc;
	  }

	  for (var i = 0, j = 0; i <= n; ++i) {
	    j = i / n;

	    // The Green Line
	    xa = getPt(fromX, cpX, j);
	    ya = getPt(fromY, cpY, j);
	    xb = getPt(cpX, toX, j);
	    yb = getPt(cpY, toY, j);

	    // The Black Dot
	    x = getPt(xa, xb, j);
	    y = getPt(ya, yb, j);

	    points.push(x, y);
	  }

	  return points;
	}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = buildCircle;

	var _buildLine = __webpack_require__(113);

	var _buildLine2 = _interopRequireDefault(_buildLine);

	var _const = __webpack_require__(7);

	var _utils = __webpack_require__(18);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Builds a circle to draw
	 *
	 * Ignored from docs since it is not directly exposed.
	 *
	 * @ignore
	 * @private
	 * @param {Tiny.WebGLGraphicsData} graphicsData - The graphics object to draw
	 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
	 */
	function buildCircle(graphicsData, webGLData) {
	  // need to convert points to a nice regular data
	  var circleData = graphicsData.shape;
	  var x = circleData.x;
	  var y = circleData.y;
	  var width = void 0;
	  var height = void 0;

	  // TODO - bit hacky??
	  if (graphicsData.type === _const.SHAPES.CIRC) {
	    width = circleData.radius;
	    height = circleData.radius;
	  } else {
	    width = circleData.width;
	    height = circleData.height;
	  }

	  var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

	  var seg = Math.PI * 2 / totalSegs;

	  if (graphicsData.fill) {
	    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
	    var alpha = graphicsData.fillAlpha;

	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;

	    var verts = webGLData.points;
	    var indices = webGLData.indices;

	    var vecPos = verts.length / 6;

	    indices.push(vecPos);

	    for (var i = 0; i < totalSegs + 1; i++) {
	      verts.push(x, y, r, g, b, alpha);

	      verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

	      indices.push(vecPos++, vecPos++);
	    }

	    indices.push(vecPos - 1);
	  }

	  if (graphicsData.lineWidth) {
	    var tempPoints = graphicsData.points;

	    graphicsData.points = [];

	    for (var _i = 0; _i < totalSegs + 1; _i++) {
	      graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height);
	    }

	    (0, _buildLine2.default)(graphicsData, webGLData);

	    graphicsData.points = tempPoints;
	  }
	}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CanvasRenderer = __webpack_require__(70);

	var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

	var _const = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
	 * now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
	 * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
	 */

	/**
	 * Renderer dedicated to drawing and batching graphics objects.
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */
	var CanvasGraphicsRenderer = function () {
	  /**
	   * @param {Tiny.CanvasRenderer} renderer - The current Tiny renderer.
	   */
	  function CanvasGraphicsRenderer(renderer) {
	    _classCallCheck(this, CanvasGraphicsRenderer);

	    this.renderer = renderer;
	  }

	  /**
	   * Renders a Graphics object to a canvas.
	   *
	   * @param {Tiny.Graphics} graphics - the actual graphics object to render
	   */


	  _createClass(CanvasGraphicsRenderer, [{
	    key: 'render',
	    value: function render(graphics) {
	      var renderer = this.renderer;
	      var context = renderer.context;
	      var worldAlpha = graphics.worldAlpha;
	      var transform = graphics.transform.worldTransform;
	      var resolution = renderer.resolution;

	      // if the tint has changed, set the graphics object to dirty.
	      if (this._prevTint !== this.tint) {
	        this.dirty = true;
	      }

	      context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

	      if (graphics.dirty) {
	        this.updateGraphicsTint(graphics);
	        graphics.dirty = false;
	      }

	      renderer.setBlendMode(graphics.blendMode);

	      for (var i = 0; i < graphics.graphicsData.length; i++) {
	        var data = graphics.graphicsData[i];
	        var shape = data.shape;

	        var fillColor = data._fillTint;
	        var lineColor = data._lineTint;

	        context.lineWidth = data.lineWidth;

	        if (data.type === _const.SHAPES.POLY) {
	          context.beginPath();

	          this.renderPolygon(shape.points, shape.closed, context);

	          for (var j = 0; j < data.holes.length; j++) {
	            this.renderPolygon(data.holes[j].points, true, context);
	          }

	          if (data.fill) {
	            context.globalAlpha = data.fillAlpha * worldAlpha;
	            context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
	            context.fill();
	          }
	          if (data.lineWidth) {
	            context.globalAlpha = data.lineAlpha * worldAlpha;
	            context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
	            context.stroke();
	          }
	        } else if (data.type === _const.SHAPES.RECT) {
	          if (data.fillColor || data.fillColor === 0) {
	            context.globalAlpha = data.fillAlpha * worldAlpha;
	            context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
	            context.fillRect(shape.x, shape.y, shape.width, shape.height);
	          }
	          if (data.lineWidth) {
	            context.globalAlpha = data.lineAlpha * worldAlpha;
	            context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
	            context.strokeRect(shape.x, shape.y, shape.width, shape.height);
	          }
	        } else if (data.type === _const.SHAPES.CIRC) {
	          // TODO - need to be Undefined!
	          context.beginPath();
	          context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
	          context.closePath();

	          if (data.fill) {
	            context.globalAlpha = data.fillAlpha * worldAlpha;
	            context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
	            context.fill();
	          }
	          if (data.lineWidth) {
	            context.globalAlpha = data.lineAlpha * worldAlpha;
	            context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
	            context.stroke();
	          }
	        } else if (data.type === _const.SHAPES.ELIP) {
	          // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

	          var w = shape.width * 2;
	          var h = shape.height * 2;

	          var x = shape.x - w / 2;
	          var y = shape.y - h / 2;

	          context.beginPath();

	          var kappa = 0.5522848;
	          var ox = w / 2 * kappa; // control point offset horizontal
	          var oy = h / 2 * kappa; // control point offset vertical
	          var xe = x + w; // x-end
	          var ye = y + h; // y-end
	          var xm = x + w / 2; // x-middle
	          var ym = y + h / 2; // y-middle

	          context.moveTo(x, ym);
	          context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
	          context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
	          context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
	          context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

	          context.closePath();

	          if (data.fill) {
	            context.globalAlpha = data.fillAlpha * worldAlpha;
	            context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
	            context.fill();
	          }
	          if (data.lineWidth) {
	            context.globalAlpha = data.lineAlpha * worldAlpha;
	            context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
	            context.stroke();
	          }
	        } else if (data.type === _const.SHAPES.RREC) {
	          var rx = shape.x;
	          var ry = shape.y;
	          var width = shape.width;
	          var height = shape.height;
	          var radius = shape.radius;

	          var maxRadius = Math.min(width, height) / 2 | 0;

	          radius = radius > maxRadius ? maxRadius : radius;

	          context.beginPath();
	          context.moveTo(rx, ry + radius);
	          context.lineTo(rx, ry + height - radius);
	          context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
	          context.lineTo(rx + width - radius, ry + height);
	          context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
	          context.lineTo(rx + width, ry + radius);
	          context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
	          context.lineTo(rx + radius, ry);
	          context.quadraticCurveTo(rx, ry, rx, ry + radius);
	          context.closePath();

	          if (data.fillColor || data.fillColor === 0) {
	            context.globalAlpha = data.fillAlpha * worldAlpha;
	            context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
	            context.fill();
	          }

	          if (data.lineWidth) {
	            context.globalAlpha = data.lineAlpha * worldAlpha;
	            context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
	            context.stroke();
	          }
	        }
	      }
	    }

	    /**
	     * Updates the tint of a graphics object
	     *
	     * @private
	     * @param {Tiny.Graphics} graphics - the graphics that will have its tint updated
	     */

	  }, {
	    key: 'updateGraphicsTint',
	    value: function updateGraphicsTint(graphics) {
	      graphics._prevTint = graphics.tint;

	      var tintR = (graphics.tint >> 16 & 0xFF) / 255;
	      var tintG = (graphics.tint >> 8 & 0xFF) / 255;
	      var tintB = (graphics.tint & 0xFF) / 255;

	      for (var i = 0; i < graphics.graphicsData.length; ++i) {
	        var data = graphics.graphicsData[i];

	        var fillColor = data.fillColor | 0;
	        var lineColor = data.lineColor | 0;

	        // super inline cos im an optimization NAZI :)
	        data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;

	        data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;
	      }
	    }

	    /**
	     * Renders a polygon.
	     *
	     * @param {Tiny.Point[]} points - The points to render
	     * @param {boolean} close - Should the polygon be closed
	     * @param {CanvasRenderingContext2D} context - The rendering context to use
	     */

	  }, {
	    key: 'renderPolygon',
	    value: function renderPolygon(points, close, context) {
	      context.moveTo(points[0], points[1]);

	      for (var j = 1; j < points.length / 2; ++j) {
	        context.lineTo(points[j * 2], points[j * 2 + 1]);
	      }

	      if (close) {
	        context.closePath();
	      }
	    }

	    /**
	     * destroy graphics object
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.renderer = null;
	    }
	  }]);

	  return CanvasGraphicsRenderer;
	}();

	exports.default = CanvasGraphicsRenderer;


	_CanvasRenderer2.default.registerPlugin('graphics', CanvasGraphicsRenderer);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line


	var _ismobilejs = __webpack_require__(22);

	var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

	var _tween = __webpack_require__(25);

	var _tween2 = _interopRequireDefault(_tween);

	var _Container = __webpack_require__(50);

	var _Container2 = _interopRequireDefault(_Container);

	var _Ticker = __webpack_require__(66);

	var _Ticker2 = _interopRequireDefault(_Ticker);

	var _settings = __webpack_require__(20);

	var _settings2 = _interopRequireDefault(_settings);

	var _const = __webpack_require__(7);

	var _utils = __webpack_require__(18);

	var utils = _interopRequireWildcard(_utils);

	var _Text = __webpack_require__(104);

	var _Text2 = _interopRequireDefault(_Text);

	var _Transition = __webpack_require__(120);

	var _Transition2 = _interopRequireDefault(_Transition);

	var _CanvasRenderer = __webpack_require__(70);

	var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

	var _WebGLRenderer = __webpack_require__(82);

	var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 故事从这里开始
	 *
	 * @example
	 *
	 * var config = {
	 *   showFPS: true,
	 *   renderOptions: {
	 *     backgroundColor: 0x2a3145
	 *   }
	 * };
	 * Tiny.app = new Tiny.Application(config);
	 * Tiny.app.run(new MenuLayer());
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Application = function () {
	  /**
	   * @param {Tiny.config} 启动参数
	   */
	  function Application(conf) {
	    _classCallCheck(this, Application);

	    this.setup(conf);

	    this._accumDt = 0.0;

	    /**
	     * WebGL renderer if available, otherwise CanvasRenderer
	     * @member {Tiny.WebGLRenderer|Tiny.CanvasRenderer}
	     */
	    this.renderer = this.autoDetectRenderer(_settings.config.newWidth, _settings.config.newHeight, {
	      view: this.view
	    });

	    _const.WIN_SIZE.width = Math.round(this.renderer.width);
	    _const.WIN_SIZE.height = Math.round(this.renderer.height);

	    /**
	     * The root display container that's renderered.
	     * @member {Tiny.Container}
	     */
	    this.stage = new _Container2.default();
	    this.stage.scale.set(_settings.config.multiplier);

	    /**
	     * @member {Tiny.Container}
	     */
	    this.camera = new _Container2.default();
	    this.camera.addChild(this.stage);
	    if (_settings.config.showFPS) {
	      this._createStatsLabel();
	    }
	  }

	  _createClass(Application, [{
	    key: 'setup',
	    value: function setup(conf) {
	      Object.assign(_settings.config, conf);

	      if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
	        //style设置
	        var fontStyle = document.createElement('style');
	        fontStyle.type = 'text/css';
	        document.body.appendChild(fontStyle);

	        fontStyle.textContent = 'body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}';
	      }
	      var view = document.getElementById(_settings.config.canvasId);
	      if (!view) {
	        view = document.createElement('canvas');
	        view.setAttribute('tabindex', 99);
	        view.id = _settings.config.canvasId;
	        view.style.outline = 'none';
	        document.body.appendChild(view);
	      }

	      /**
	       * 就是那个用于渲染故事的普通 <canvas> 画布对象
	       *
	       * @property view
	       * @type {HTMLCanvasElement}
	       */
	      this.view = view;
	      this.resize();
	    }

	    /**
	     * Render the current camera.
	     */

	  }, {
	    key: 'render',
	    value: function render() {
	      this.renderer.render(this.camera);
	    }

	    /**
	     * Convenience method for stopping the render.
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.ticker.stop();
	    }

	    /**
	     * Convenience method for starting the render.
	     */

	  }, {
	    key: 'start',
	    value: function start() {
	      this.ticker.start();
	    }

	    /**
	     *
	     * @param {number}  width - the width of the renderers view
	     * @param {number}  height  - the height of the renderers view
	     * @param {Tiny.RENDER_OPTIONS}  options  - The optional renderer parameters
	     * @return {Tiny.WebGLRenderer|Tiny.CanvasRenderer} - Returns WebGL renderer if available, otherwise CanvasRenderer
	     */

	  }, {
	    key: 'autoDetectRenderer',
	    value: function autoDetectRenderer() {
	      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 320;
	      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 568;
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      Object.assign(options, _settings.config.renderOptions);

	      if (utils.isWebGLSupported()) {
	        if (_settings.config.renderType !== _const.RENDERER_TYPE.CANVAS) {
	          console.log('WebGLRenderer');
	          return new _WebGLRenderer2.default(width, height, options);
	        }
	      }
	      console.log('CanvasRenderer');
	      return new _CanvasRenderer2.default(width, height, options);
	    }

	    /**
	     * 启动某个场景
	     *
	     * @param {Tiny.DisplayObject}  startScene
	     */

	  }, {
	    key: 'run',
	    value: function run(startScene) {
	      this.replaceScene(startScene);

	      if (_settings.config.autoRender) {
	        this.mainLoop();
	      } else {
	        //手动渲染一次
	        this.render();
	      }
	    }

	    /**
	     * 切换场景，如果你想切换下一个场景，使用 replaceScene，还可以使用转场动画
	     *
	     * @example
	     *
	     * var app = new Tiny.Application({..});
	     * app.replaceScene(scene, 'SlideInR', 800);
	     *
	     * @param {Tiny.DisplayObject}  scene
	     * @param {string}  transition
	     * @param {number}  duration
	     */

	  }, {
	    key: 'replaceScene',
	    value: function replaceScene(scene, transition, duration) {
	      if (transition) {
	        var instance = new _Transition2.default(this.stage, scene, duration);
	        var trans = transition;
	        Array.prototype.splice.call(arguments, 0, 3);
	        instance[trans](arguments);
	      } else {
	        this.stage.removeChildren();
	        this.stage.addChild(scene);
	      }
	    }

	    /**
	     * @private
	     */

	  }, {
	    key: 'mainLoop',
	    value: function mainLoop() {
	      /**
	       * Ticker for doing render updates.
	       * @member {Tiny.ticker.Ticker}
	       */
	      this.ticker = new _Ticker2.default();

	      this.ticker.add(function () {
	        this.render();
	        _tween2.default.update();
	      }, this);
	      this.ticker.add(function (t) {
	        this._accumDt += t;
	        if (this._label && this._accumDt > _settings2.default.TARGET_FPMS * 1000) {
	          this._accumDt = 0;
	          this._label.text = 'SPF: ' + (1 / this.ticker.FPS).toFixed(3) + '\nFPS: ' + this.ticker.FPS.toFixed(1);
	        }
	      }, this);

	      // Start the rendering
	      this.start();
	    }

	    /**
	     * @param expanding
	     * @private
	     */

	  }, {
	    key: 'resize',
	    value: function resize(expanding) {
	      var width = _settings.config.fullScreen === false ? _settings.config.width : window.innerWidth;
	      var height = _settings.config.fullScreen === false ? _settings.config.height : window.innerHeight;

	      var multiplier = void 0;
	      var cWidth = _settings.config.width;
	      var cHeight = _settings.config.height;
	      var ratio = height / width;

	      +_settings.config.orientation === 1 && (ratio = width / height);
	      ratio = Number(parseFloat(ratio).toFixed(3));

	      if (_settings.config.fullScreen !== false) {
	        //cHeight = config.height;

	        if (+_settings.config.orientation === 1) {
	          var w = cWidth;
	          cWidth = cHeight;
	          cHeight = w;
	        }
	      }

	      cWidth = cWidth * _settings.config.dpi;
	      cHeight = cHeight * _settings.config.dpi;

	      if (expanding) {
	        multiplier = Math.max(height / cHeight, width / cWidth);
	      } else {
	        multiplier = Math.min(height / cHeight, width / cWidth);
	      }
	      multiplier = Number(multiplier.toFixed(4));
	      //console.log(multiplier)
	      _settings.config.renderOptions.resolution = Number((1 / multiplier).toFixed(4));
	      //console.log(config.renderOptions.resolution)
	      _settings.config.renderOptions.autoResize = true;
	      _settings.config.newWidth = Math.round(cWidth * multiplier);
	      _settings.config.newHeight = Math.round(cHeight * multiplier);
	      _settings.config.multiplier = multiplier;

	      //ipad
	      if (_settings.config.fullScreen && ratio <= 1.333) {}
	    }

	    /**
	     *
	     * @method _createStatsLabel
	     * @return {HTMLElement}
	     * @private
	     */

	  }, {
	    key: '_createStatsLabel',
	    value: function _createStatsLabel() {
	      this._label = new _Text2.default('SPF: -\nFPS: -', {
	        fontSize: 18,
	        fontFamily: 'Helvetica',
	        fill: '#ffffff',
	        stroke: '#666666',
	        strokeThickness: 0.2
	      });

	      this._label.position.set(10, _settings.config.newHeight - this._label.height - 10);
	      this.camera.addChild(this._label);
	    }

	    /**
	     * Destroy and don't use after this.
	     * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(removeView) {
	      this.stop();
	      this.ticker.remove(this.render, this);
	      this.ticker = null;

	      this.stage.destroy();
	      this.stage = null;

	      this.camera.destroy();
	      this.camera = null;

	      this.renderer.destroy(removeView);
	      this.renderer = null;

	      _tween2.default.removeAll();
	    }
	  }]);

	  return Application;
	}();

	exports.default = Application;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _ActionInterval = __webpack_require__(121);

	var ActionInterval = _interopRequireWildcard(_ActionInterval);

	var _Action = __webpack_require__(122);

	var _Action2 = _interopRequireDefault(_Action);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 各种转场
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Transition = function () {
	  /**
	   *
	   * @param {Tiny.DisplayObject}  stage
	   * @param {Tiny.DisplayObject}  scene
	   * @param {number}  duration
	   */
	  function Transition(stage, scene, duration) {
	    _classCallCheck(this, Transition);

	    this.stage = stage;
	    this.scene = scene;
	    this.duration = duration || 600;
	  }

	  /**
	   *
	   */


	  _createClass(Transition, [{
	    key: 'Fade',
	    value: function Fade(color) {
	      var self = this;
	      var fadeOutAction = ActionInterval.FadeOut(this.duration);
	      var fadeInAction = ActionInterval.FadeIn(this.duration);

	      var g = new core.Graphics();
	      g.beginFill(color || 0x000000);
	      g.drawRect(0, 0, core.WIN_SIZE.width, core.WIN_SIZE.height);
	      g.endFill();
	      g.setOpacity(0);

	      self.stage.addChild(g);

	      fadeInAction.onComplete = function () {
	        self.stage.removeChildren();
	        self.stage.addChild(self.scene);
	        self.stage.addChild(g);
	        g.runAction(fadeOutAction);
	      };

	      g.runAction(fadeInAction);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'FadeWhite',
	    value: function FadeWhite() {
	      this.Fade(0xFFFFFF);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'FadeColor',
	    value: function FadeColor(arg) {
	      this.Fade(arg[0]);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'Progress',
	    value: function Progress(action, g) {
	      var self = this;

	      self.stage.addChild(self.scene);
	      self.stage.addChild(g);

	      self.scene.mask = g;

	      //    self.stage.children.forEach(function (child) {
	      //        child.mask = g;
	      //    });

	      action.onComplete = function () {
	        self.scene.mask = null;
	        self.stage.removeChildren();
	        self.stage.addChild(self.scene);
	      };

	      g.runAction(action);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressH',
	    value: function ProgressH() {
	      var moveToAction = ActionInterval.MoveTo(this.duration, { x: core.WIN_SIZE.width });

	      var g = new core.Graphics();
	      g.beginFill(0xFFFFFF);
	      g.drawRect(-core.WIN_SIZE.width, 0, core.WIN_SIZE.width, core.WIN_SIZE.height);
	      g.endFill();

	      this.Progress(moveToAction, g);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressV',
	    value: function ProgressV() {
	      var moveToAction = ActionInterval.MoveTo(this.duration, { y: core.WIN_SIZE.height });

	      var g = new core.Graphics();
	      g.beginFill(0xFFFFFF);
	      g.drawRect(0, -core.WIN_SIZE.height, core.WIN_SIZE.width, core.WIN_SIZE.height);
	      g.endFill();

	      this.Progress(moveToAction, g);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressInOut',
	    value: function ProgressInOut() {
	      var scaleToAction = ActionInterval.ScaleTo(this.duration, core.scale(core.WIN_SIZE.width, core.WIN_SIZE.height));

	      var g = new core.Graphics();
	      g.beginFill(0xFFFFFF);
	      g.drawRect(0, 0, 1, 1);
	      g.endFill();
	      g.setPosition(core.WIN_SIZE.width / 2, core.WIN_SIZE.height / 2);
	      g.setPivot(0.5);

	      this.Progress(scaleToAction, g);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressOutIn',
	    value: function ProgressOutIn() {
	      var self = this;
	      var scaleToAction = ActionInterval.ScaleTo(this.duration, core.scale(0));
	      var moveToAction = ActionInterval.MoveTo(this.duration, core.point(core.WIN_SIZE.width / 2, core.WIN_SIZE.height / 2));

	      var g = new core.Graphics();
	      g.beginFill(0xFFFFFF);
	      g.drawRect(0, 0, core.WIN_SIZE.width, core.WIN_SIZE.height);
	      g.endFill();
	      g.setPivot(0.5);

	      var container = new core.Container();
	      self.stage.children.forEach(function (child) {
	        container.addChild(child);
	      });
	      container.mask = g;
	      self.stage.removeChildren();
	      self.stage.addChild(self.scene);
	      self.stage.addChild(container);
	      self.stage.addChild(g);

	      scaleToAction.onComplete = function () {
	        container.mask = null;
	        self.stage.removeChild(container);
	        self.stage.removeChild(g);
	      };

	      g.runAction([scaleToAction, moveToAction]);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressRadial',
	    value: function ProgressRadial(ccw) {
	      var rotateXY = function rotateXY(x, y, angle) {
	        var rad = Math.PI * angle / 180;

	        if (ccw) {
	          rad = -rad;
	        }

	        var cosVal = Math.cos(rad);
	        var sinVal = Math.sin(rad);
	        return new core.Point(cosVal * x - sinVal * y, sinVal * x + cosVal * y);
	      };
	      var computeMaskPolygon = function computeMaskPolygon(x, y, radius, angle) {
	        while (angle < 0) {
	          angle += 360;
	        }
	        angle %= 360;

	        var delta = rotateXY(0, -2 * radius, angle);
	        var a270 = 270;
	        var a90 = 90;
	        var pts = [new core.Point(x, y - 2 * radius), new core.Point(x, y), new core.Point(x + delta.x, y + delta.y)];

	        if (ccw) {
	          a270 = 90;
	          a90 = 270;
	          pts.reverse();
	        }

	        if (angle > a270) {
	          pts.push(new core.Point(x - 2 * radius, y));
	        }
	        if (angle > 180) {
	          pts.push(new core.Point(x, y + 2 * radius));
	        }
	        if (angle > a90) {
	          pts.push(new core.Point(x + 2 * radius, y));
	        }

	        return pts;
	      };

	      var centerX = core.WIN_SIZE.width / 2;
	      var centerY = core.WIN_SIZE.height / 2;
	      var radius = Math.max(core.WIN_SIZE.width, core.WIN_SIZE.height);

	      var g = new core.Graphics();

	      var updatePieMask = function updatePieMask(angle) {
	        g.clear();
	        var pts = computeMaskPolygon(centerX, centerY, radius, angle);
	        g.beginFill(0xFFFFFF);
	        g.moveTo(pts[0].x, pts[0].y);
	        for (var i = 1; i < pts.length; ++i) {
	          g.lineTo(pts[i].x, pts[i].y);
	        }
	        g.lineTo(pts[0].x, pts[0].y);
	        g.endFill();
	      };

	      var action = new _Action2.default(this.duration, { angle: 360 });
	      action.yoyo = false;
	      action.repeatTimes = 0;
	      action.onUpdate = function (tween, object) {
	        updatePieMask(~~tween.angle);
	      };

	      this.Progress(action, g);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressRadialCW',
	    value: function ProgressRadialCW() {
	      this.ProgressRadial(false);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'ProgressRadialCCW',
	    value: function ProgressRadialCCW() {
	      this.ProgressRadial(true);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'MoveIn',
	    value: function MoveIn() {
	      var self = this;
	      var action = ActionInterval.MoveTo(this.duration, new core.Point());

	      self.stage.addChild(self.scene);

	      action.onComplete = function () {
	        self.stage.removeChildren();
	        self.stage.addChild(self.scene);
	      };

	      self.scene.runAction(action);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'MoveInL',
	    value: function MoveInL() {
	      this.scene.setPositionX(-core.WIN_SIZE.width);
	      this.MoveIn();
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'MoveInR',
	    value: function MoveInR() {
	      this.scene.setPositionX(core.WIN_SIZE.width);
	      this.MoveIn();
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'MoveInT',
	    value: function MoveInT() {
	      this.scene.setPositionY(-core.WIN_SIZE.height);
	      this.MoveIn();
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'MoveInB',
	    value: function MoveInB() {
	      this.scene.setPositionY(core.WIN_SIZE.height);
	      this.MoveIn();
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'SlideIn',
	    value: function SlideIn(x, y) {
	      var self = this;
	      var container = new core.Container();
	      self.stage.children.forEach(function (child) {
	        container.addChild(child);
	      });
	      self.stage.removeChildren();

	      container.addChild(self.scene);

	      self.scene.setPosition(x, y);
	      self.stage.addChild(container);
	      var action = ActionInterval.MoveTo(this.duration, { x: -x, y: -y });

	      action.onComplete = function () {
	        self.stage.removeChildren();
	        self.scene.setPosition(0);
	        self.stage.addChild(self.scene);
	      };

	      container.runAction(action);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'SlideInL',
	    value: function SlideInL() {
	      this.SlideIn(-core.WIN_SIZE.width, 0);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'SlideInR',
	    value: function SlideInR() {
	      this.SlideIn(core.WIN_SIZE.width, 0);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'SlideInT',
	    value: function SlideInT() {
	      this.SlideIn(0, -core.WIN_SIZE.height);
	    }

	    /**
	     *
	     */

	  }, {
	    key: 'SlideInB',
	    value: function SlideInB() {
	      this.SlideIn(0, core.WIN_SIZE.height);
	    }
	  }]);

	  return Transition;
	}();

	exports.default = Transition;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MoveBy = MoveBy;
	exports.MoveTo = MoveTo;
	exports.ScaleBy = ScaleBy;
	exports.ScaleTo = ScaleTo;
	exports.RotateBy = RotateBy;
	exports.RotateTo = RotateTo;
	exports.JumpTo = JumpTo;
	exports.Blink = Blink;
	exports.FadeTo = FadeTo;
	exports.FadeIn = FadeIn;
	exports.FadeOut = FadeOut;
	exports.TintBy = TintBy;
	exports.TintTo = TintTo;
	exports.RepeatForever = RepeatForever;
	exports.Repeat = Repeat;

	var _Action = __webpack_require__(122);

	var _Action2 = _interopRequireDefault(_Action);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @static
	 * @memberof Tiny
	 * @function MoveBy
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function MoveBy(duration, to) {
	  var action = new _Action2.default(duration, to);
	  action.yoyo = true;
	  action.onUpdate = function (tween, object) {
	    object.setPosition(tween.x, tween.y);
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function MoveTo
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function MoveTo(duration, to) {
	  var action = MoveBy(duration, to);
	  action.yoyo = false;
	  action.repeatTimes = 0;

	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function ScaleBy
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function ScaleBy(duration, to) {
	  var action = new _Action2.default(duration, to);
	  action.yoyo = true;
	  action.onUpdate = function (tween, object) {
	    object.setScale(tween.scaleX, tween.scaleY);
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function ScaleTo
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function ScaleTo(duration, to) {
	  var action = ScaleBy(duration, to);
	  action.yoyo = false;
	  action.repeatTimes = 0;

	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function RotateBy
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function RotateBy(duration, to) {
	  var action = new _Action2.default(duration, to);
	  action.yoyo = true;
	  action.onUpdate = function (tween, object) {
	    object.rotation = tween.rotation;
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function RotateTo
	 * @param {number}  duration
	 * @param {object}  to
	 * @return {Tiny.Action}
	 */
	function RotateTo(duration, to) {
	  var action = RotateBy(duration, to);
	  action.yoyo = false;
	  action.repeatTimes = 0;

	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function JumpTo
	 * @param {number}  duration
	 * @param {object}  to
	 * @param {number}  height
	 * @param {number}  times
	 * @return {Tiny.Action}
	 */
	function JumpTo(duration, to, height, times) {
	  var newY = [];
	  for (var i = 0; i < times * 2; i++) {
	    if (i % 2 === 0) {
	      newY.push(to.y - height);
	    } else {
	      newY.push(to.y);
	    }
	  }

	  to.y = newY;

	  var action = new _Action2.default(duration, to);
	  action.yoyo = false;
	  action.repeatTimes = 0;
	  action.onUpdate = function (tween, object) {
	    object.setPosition(tween.x, tween.y);
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function Blink
	 * @param {number}  hideDuration
	 * @param {number}  showDuration
	 * @return {Tiny.Action}
	 */
	function Blink(hideDuration, showDuration) {
	  var newVisible = [];
	  for (var i = 0; i < hideDuration; i++) {
	    newVisible.push(false);
	  }
	  for (var _i = 0; _i < showDuration; _i++) {
	    newVisible.push(true);
	  }

	  var action = new _Action2.default(showDuration + hideDuration, {
	    visible: newVisible
	  });
	  action.yoyo = false;
	  action.repeatTimes = 0;
	  action.onUpdate = function (tween, object) {
	    object.visible = ~~tween.visible;
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function FadeTo
	 * @param {number}  duration
	 * @param {number}  to
	 * @return {Tiny.Action}
	 */
	function FadeTo(duration, to) {
	  var action = new _Action2.default(duration, {
	    alpha: to
	  });
	  action.yoyo = false;
	  action.repeatTimes = 0;
	  action.onUpdate = function (tween, object) {
	    object.setOpacity(tween.alpha);
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function FadeIn
	 * @param {number}  duration
	 * @return {Tiny.Action}
	 */
	function FadeIn(duration) {
	  return FadeTo(duration, 1);
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function FadeOut
	 * @param {number}  duration
	 * @return {Tiny.Action}
	 */
	function FadeOut(duration) {
	  return FadeTo(duration, 0);
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function TintBy
	 * @param {number}  duration
	 * @param {number}  color
	 * @return {Tiny.Action}
	 */
	function TintBy(duration, color) {
	  var action = new _Action2.default(duration, {
	    tint: color
	  });
	  action.yoyo = true;
	  action.onUpdate = function (tween, object) {
	    object.tint = ~~tween.tint;
	  };
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function TintTo
	 * @param {number}  duration
	 * @param {number}  color
	 * @return {Tiny.Action}
	 */
	function TintTo(duration, color) {
	  var action = TintBy(duration, color);
	  action.yoyo = false;
	  action.repeatTimes = 0;

	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function RepeatForever
	 * @param {Tiny.Action} action
	 * @return {Tiny.Action}
	 */
	function RepeatForever(action) {
	  action.repeatTimes = Infinity;
	  return action;
	}

	/**
	 * @static
	 * @memberof Tiny
	 * @function RepeatForever
	 * @param {number}  times
	 * @param {Tiny.Action} action
	 * @return {Tiny.Action}
	 */
	function Repeat(times, action) {
	  action.repeatTimes = times;
	  return action;
	}

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _tween = __webpack_require__(25);

	var _tween2 = _interopRequireDefault(_tween);

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * 动作类
	 *
	 * 对`Tween.js`做了一层封装，你可以通过`new Tiny.TWEEN.Tween(..)`来直接使用`Tween.js`原生方法
	 *
	 * @example
	 *
	 * var action = new Tiny.Action(600, Tiny.p(100, 120));
	 * action.yoyo = true;
	 * //重复4次
	 * action.repeatTimes = 4;
	 * //延迟500ms开始
	 * action.setDelay(500);
	 * //设置动画缓冲为`Quadratic.InOut`
	 * action.setEasing(Tiny.TWEEN.Easing.Quadratic.InOut);
	 * //运动中更改精灵的坐标
	 * action.onUpdate = function (tween, object) {
	 *   sprite.setPosition(tween.x, tween.y);
	 * };
	 * //运动完成后的回调
	 * action.onComplete = function (tween, object) {
	 *   console.log('complete');
	 * };
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Action = function () {
	  /**
	   *
	   * @param {number} duration 动作持续时间（ms）
	   * @param {object} to 运动到的状态
	   */
	  function Action(duration, to) {
	    _classCallCheck(this, Action);

	    /**
	     * action的唯一name
	     *
	     * @member {string}
	     * @default ''
	     * @private
	     */
	    this.name = '';
	    /**
	     * 持续时间
	     *
	     * @member {number}
	     */
	    this.duration = duration;

	    /**
	     *
	     * @member {object}
	     */
	    this.to = to;

	    /**
	     * 延迟
	     *
	     * @member {number}
	     * @default 0
	     * @private
	     */
	    this.delay = 0;

	    /**
	     * @member {boolean}
	     * @default false
	     */
	    this.yoyo = false;

	    /**
	     * 重复次数
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.repeatTimes = 1;

	    /**
	     * 动画缓冲
	     *
	     * @member {Tiny.TWEEN.Easing}
	     * @default Tiny.TWEEN.Easing.Linear.None
	     * @private
	     */
	    this.easing = _tween2.default.Easing.Linear.None;

	    /**
	     * 插值
	     *
	     * @member {Tiny.TWEEN.Interpolation}
	     * @default Tiny.TWEEN.Interpolation.Linear
	     * @private
	     */
	    this.interpolation = _tween2.default.Interpolation.Linear;
	  }

	  _createClass(Action, [{
	    key: 'create',
	    value: function create() {
	      var self = this;
	      return function (object) {
	        var tween = new _tween2.default.Tween(object.getNature()).to(self.to, self.duration).repeat(self.repeatTimes).delay(self.delay).easing(self.easing).yoyo(self.yoyo).interpolation(self.interpolation).onUpdate(function () {
	          self._onUpdate(this, object);
	        }).onComplete(function () {
	          self._onComplete(this, object);
	        });

	        tween.name = self.name;
	        return tween;
	      };
	    }

	    /**
	     * 设置action的name值
	     * @param {string}  name
	     */

	  }, {
	    key: 'setName',
	    value: function setName(name) {
	      this.name = name;
	    }
	  }, {
	    key: '_onUpdate',
	    value: function _onUpdate(tween, object) {
	      this.onUpdate(tween, object);
	    }
	  }, {
	    key: '_onComplete',
	    value: function _onComplete(tween, object) {
	      this.onComplete(tween, object);
	    }

	    /**
	     * 动画更新时的回调
	     *
	     * @param tween
	     * @param object
	     */

	  }, {
	    key: 'onUpdate',
	    value: function onUpdate(tween, object) {}
	    //OVERRIDE


	    /**
	     * 动画完成的回调
	     *
	     * @param tween
	     * @param object
	     */

	  }, {
	    key: 'onComplete',
	    value: function onComplete(tween, object) {}
	    //OVERRIDE


	    /**
	     * 设置动画缓冲
	     * @param {Tiny.TWEEN.Easing} easing
	     * @default Tiny.TWEEN.Easing.Linear.None
	     */

	  }, {
	    key: 'setEasing',
	    value: function setEasing(easing) {
	      this.easing = easing;
	    }

	    /**
	     * 设置插值
	     *
	     * @param {Tiny.TWEEN.Interpolation} interpolation
	     * @default Tiny.TWEEN.Interpolation.Linear
	     */

	  }, {
	    key: 'setInterpolation',
	    value: function setInterpolation(interpolation) {
	      this.interpolation = interpolation;
	    }

	    /**
	     * 设置延迟
	     *
	     * @param {number}  delay
	     * @default 0
	     */

	  }, {
	    key: 'setDelay',
	    value: function setDelay(delay) {
	      this.delay = delay;
	    }
	  }]);

	  return Action;
	}();

	/**
	 * 清除某对象上的所有 Action
	 *
	 * @static
	 * @param {Tiny.DisplayObject}  sprite
	 */


	exports.default = Action;
	Action.cleanup = function (sprite) {
	  if (sprite && sprite.actions.length !== 0) {
	    sprite.actions.forEach(function (action) {
	      _tween2.default.remove(action);
	    });
	    sprite.actions = [];
	  }
	};

	/**
	 * 让 action 们动起来吧
	 *
	 * 多组action同时：`runAction([action1, action2], action3)`
	 *
	 * @example
	 *
	 * var action = Tiny.MoveBy(1000, Tiny.p(100, 100));
	 * container.runAction(Tiny.RepeatForever(action));
	 * //container 会在舞台的(0, 0)位置和(100, 100)位置来回不停的移动
	 *
	 * @memberof Tiny.Container#
	 * @function runAction
	 * @param {Tiny.Action} actions
	 */
	core.Container.prototype.runAction = function (actions) {
	  var actionArray = core.isArray(actions) ? actions : arguments;
	  for (var i = 0; i < actionArray.length; i++) {
	    var action = actionArray[i].create()(this).start();
	    this.actions.push(action);
	  }
	};

	/**
	 * 有顺序的让 action 们动起来吧
	 *
	 * `runSequenceAction(action1, action2)`
	 *
	 * @example
	 *
	 * var action1 = Tiny.MoveTo(1000, Tiny.p(100, 100));
	 * var action2 = Tiny.ScaleBy(1200, Tiny.scale(0.25, 2));
	 * var action3 = Tiny.RotateTo(2000, {rotation: Tiny.CONST.PI_2});
	 * container.runSequenceAction(action1, action2, action3);
	 * //container 先在1000ms内从坐标(0, 0)移动到(100, 100)，然后在1200ms内横向缩小0.25倍，纵向拉伸2倍，最后在2000ms内顺时针旋转360度
	 *
	 * @memberof Tiny.Container#
	 * @function runSequenceAction
	 * @param {Tiny.Action} actions
	 */
	core.Container.prototype.runSequenceAction = function (actions) {
	  var self = this;

	  var actionArray = core.isArray(actions) ? actions : arguments;
	  var tempArray = [];

	  if (actionArray.length > 0 && actionArray[actionArray.length - 1] == null) throw new Error('parameters should not be ending with null');

	  for (var i = 0; i < actionArray.length; i++) {
	    tempArray.push(actionArray[i].create()(self));
	  }

	  for (var _i = tempArray.length - 1; _i > 0; _i--) {
	    tempArray[_i - 1].chain(tempArray[_i]);
	  }

	  tempArray[0].start();
	};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Action = __webpack_require__(122);

	Object.defineProperty(exports, 'Action', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Action).default;
	  }
	});

	var _ActionInterval = __webpack_require__(121);

	Object.keys(_ActionInterval).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ActionInterval[key];
	    }
	  });
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _InteractionData = __webpack_require__(125);

	Object.defineProperty(exports, 'InteractionData', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_InteractionData).default;
	  }
	});

	var _InteractionManager = __webpack_require__(126);

	Object.defineProperty(exports, 'InteractionManager', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_InteractionManager).default;
	  }
	});

	var _interactiveTarget = __webpack_require__(128);

	Object.defineProperty(exports, 'interactiveTarget', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_interactiveTarget).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Holds all information related to an Interaction event
	 *
	 * @class
	 * @memberof Tiny.interaction
	 */
	var InteractionData = function () {
	  /**
	   *
	   */
	  function InteractionData() {
	    _classCallCheck(this, InteractionData);

	    /**
	     * This point stores the global coords of where the touch/mouse event happened
	     *
	     * @member {Tiny.Point}
	     */
	    this.global = new core.Point();

	    /**
	     * The target Sprite that was interacted with
	     *
	     * @member {Tiny.Sprite}
	     */
	    this.target = null;

	    /**
	     * When passed to an event handler, this will be the original DOM Event that was captured
	     *
	     * @member {Event}
	     */
	    this.originalEvent = null;
	  }

	  /**
	   * This will return the local coordinates of the specified displayObject for this InteractionData
	   *
	   * @param {Tiny.DisplayObject} displayObject - The DisplayObject that you would like the local
	   *  coords off
	   * @param {Tiny.Point} [point] - A Point object in which to store the value, optional (otherwise
	   *  will create a new point)
	   * @param {Tiny.Point} [globalPos] - A Point object containing your custom global coords, optional
	   *  (otherwise will use the current global coords)
	   * @return {Tiny.Point} A point containing the coordinates of the InteractionData position relative
	   *  to the DisplayObject
	   */


	  _createClass(InteractionData, [{
	    key: 'getLocalPosition',
	    value: function getLocalPosition(displayObject, point, globalPos) {
	      return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
	    }
	  }]);

	  return InteractionData;
	}();

	exports.default = InteractionData;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _InteractionData = __webpack_require__(125);

	var _InteractionData2 = _interopRequireDefault(_InteractionData);

	var _InteractionEvent = __webpack_require__(127);

	var _InteractionEvent2 = _interopRequireDefault(_InteractionEvent);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _interactiveTarget = __webpack_require__(128);

	var _interactiveTarget2 = _interopRequireDefault(_interactiveTarget);

	var _ismobilejs = __webpack_require__(22);

	var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Mix interactiveTarget into core.DisplayObject.prototype
	Object.assign(core.DisplayObject.prototype, _interactiveTarget2.default);

	/**
	 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * An instance of this class is automatically created by default, and can be found at renderer.plugins.interaction
	 *
	 * @class
	 * @extends EventEmitter
	 * @memberof Tiny.interaction
	 */

	var InteractionManager = function (_EventEmitter) {
	  _inherits(InteractionManager, _EventEmitter);

	  /**
	   * @param {Tiny.CanvasRenderer|Tiny.WebGLRenderer} renderer - A reference to the current renderer
	   * @param {object} [options] - The options for the manager.
	   * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.
	   * @param {number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
	   */
	  function InteractionManager(renderer, options) {
	    _classCallCheck(this, InteractionManager);

	    var _this = _possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));

	    options = options || {};

	    /**
	     * The renderer this interaction manager works for.
	     *
	     * @member {Tiny.SystemRenderer}
	     */
	    _this.renderer = renderer;

	    /**
	     * Should default browser actions automatically be prevented.
	     * Does not apply to pointer events for backwards compatibility
	     * preventDefault on pointer events stops mouse events from firing
	     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    _this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

	    /**
	     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.
	     *
	     * @member {number}
	     * @default 10
	     */
	    _this.interactionFrequency = options.interactionFrequency || 10;

	    /**
	     * The mouse data
	     *
	     * @member {Tiny.interaction.InteractionData}
	     */
	    _this.mouse = new _InteractionData2.default();

	    // setting the mouse to start off far off screen will mean that mouse over does
	    //  not get called before we even move the mouse.
	    _this.mouse.global.set(-999999);

	    /**
	     * The pointer data
	     *
	     * @member {Tiny.interaction.InteractionData}
	     */
	    _this.pointer = new _InteractionData2.default();

	    // setting the pointer to start off far off screen will mean that pointer over does
	    //  not get called before we even move the pointer.
	    _this.pointer.global.set(-999999);

	    /**
	     * An event data object to handle all the event tracking/dispatching
	     *
	     * @member {object}
	     */
	    _this.eventData = new _InteractionEvent2.default();

	    /**
	     * Tiny little interactiveData pool !
	     *
	     * @member {Tiny.interaction.InteractionData[]}
	     */
	    _this.interactiveDataPool = [];

	    /**
	     * The DOM element to bind to.
	     *
	     * @private
	     * @member {HTMLElement}
	     */
	    _this.interactionDOMElement = null;

	    /**
	     * This property determines if mousemove and touchmove events are fired only when the cursor
	     * is over the object.
	     * Setting to true will make things work more in line with how the DOM verison works.
	     * Setting to false can make things easier for things like dragging
	     * It is currently set to false as this is how Tiny used to work. This will be set to true in
	     * future versions of Tiny.
	     *
	     * @member {boolean}
	     * @default false
	     */
	    _this.moveWhenInside = false;

	    /**
	     * Have events been attached to the dom element?
	     *
	     * @private
	     * @member {boolean}
	     */
	    _this.eventsAdded = false;

	    /**
	     * Is the mouse hovering over the renderer?
	     *
	     * @private
	     * @member {boolean}
	     */
	    _this.mouseOverRenderer = false;

	    /**
	     * Does the device support touch events
	     * https://www.w3.org/TR/touch-events/
	     *
	     * @readonly
	     * @member {boolean}
	     */
	    _this.supportsTouchEvents = 'ontouchstart' in window;

	    /**
	     * Does the device support pointer events
	     * https://www.w3.org/Submission/pointer-events/
	     *
	     * @readonly
	     * @member {boolean}
	     */
	    _this.supportsPointerEvents = !!window.PointerEvent;

	    /**
	     * Are touch events being 'normalized' and converted into pointer events if pointer events are not supported
	     * For example, on a touch screen mobile device, a touchstart would also be emitted as a pointerdown
	     *
	     * @private
	     * @readonly
	     * @member {boolean}
	     */
	    _this.normalizeTouchEvents = !_this.supportsPointerEvents && _this.supportsTouchEvents;

	    /**
	     * Are mouse events being 'normalized' and converted into pointer events if pointer events are not supported
	     * For example, on a desktop pc, a mousedown would also be emitted as a pointerdown
	     *
	     * @private
	     * @readonly
	     * @member {boolean}
	     */
	    _this.normalizeMouseEvents = !_this.supportsPointerEvents && !_ismobilejs2.default.any;

	    // this will make it so that you don't have to call bind all the time

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onMouseUp = _this.onMouseUp.bind(_this);
	    _this.processMouseUp = _this.processMouseUp.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onMouseDown = _this.onMouseDown.bind(_this);
	    _this.processMouseDown = _this.processMouseDown.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onMouseMove = _this.onMouseMove.bind(_this);
	    _this.processMouseMove = _this.processMouseMove.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onMouseOut = _this.onMouseOut.bind(_this);
	    _this.processMouseOverOut = _this.processMouseOverOut.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onMouseOver = _this.onMouseOver.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onPointerUp = _this.onPointerUp.bind(_this);
	    _this.processPointerUp = _this.processPointerUp.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onPointerDown = _this.onPointerDown.bind(_this);
	    _this.processPointerDown = _this.processPointerDown.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onPointerMove = _this.onPointerMove.bind(_this);
	    _this.processPointerMove = _this.processPointerMove.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onPointerOut = _this.onPointerOut.bind(_this);
	    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onPointerOver = _this.onPointerOver.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onTouchStart = _this.onTouchStart.bind(_this);
	    _this.processTouchStart = _this.processTouchStart.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onTouchEnd = _this.onTouchEnd.bind(_this);
	    _this.processTouchEnd = _this.processTouchEnd.bind(_this);

	    /**
	     * @private
	     * @member {Function}
	     */
	    _this.onTouchMove = _this.onTouchMove.bind(_this);
	    _this.processTouchMove = _this.processTouchMove.bind(_this);

	    /**
	     * Every update cursor will be reset to this value, if some element wont override it in
	     * its hitTest.
	     *
	     * @member {string}
	     * @default 'inherit'
	     */
	    _this.defaultCursorStyle = 'inherit';

	    /**
	     * The css style of the cursor that is being used.
	     *
	     * @member {string}
	     */
	    _this.currentCursorStyle = 'inherit';

	    /**
	     * Internal cached let.
	     *
	     * @private
	     * @member {Tiny.Point}
	     */
	    _this._tempPoint = new core.Point();

	    /**
	     * The current resolution / device pixel ratio.
	     *
	     * @member {number}
	     * @default 1
	     */
	    _this.resolution = 1;

	    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);

	    /**
	     * Fired when a pointer device button (usually a mouse button) is pressed on the display
	     * object.
	     *
	     * @event mousedown
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
	     * on the display object.
	     *
	     * @event rightdown
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button (usually a mouse button) is released over the display
	     * object.
	     *
	     * @event mouseup
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device secondary button (usually a mouse right-button) is released
	     * over the display object.
	     *
	     * @event rightup
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button (usually a mouse button) is pressed and released on
	     * the display object.
	     *
	     * @event click
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
	     * and released on the display object.
	     *
	     * @event rightclick
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button (usually a mouse button) is released outside the
	     * display object that initially registered a
	     * [mousedown]{@link Tiny.interaction.InteractionManager#event:mousedown}.
	     *
	     * @event mouseupoutside
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device secondary button (usually a mouse right-button) is released
	     * outside the display object that initially registered a
	     * [rightdown]{@link Tiny.interaction.InteractionManager#event:rightdown}.
	     *
	     * @event rightupoutside
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device (usually a mouse) is moved while over the display object
	     *
	     * @event mousemove
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device (usually a mouse) is moved onto the display object
	     *
	     * @event mouseover
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device (usually a mouse) is moved off the display object
	     *
	     * @event mouseout
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button is pressed on the display object.
	     *
	     * @event pointerdown
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button is released over the display object.
	     *
	     * @event pointerup
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button is pressed and released on the display object.
	     *
	     * @event pointertap
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device button is released outside the display object that initially
	     * registered a [pointerdown]{@link Tiny.interaction.InteractionManager#event:pointerdown}.
	     *
	     * @event pointerupoutside
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device is moved while over the display object
	     *
	     * @event pointermove
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device is moved onto the display object
	     *
	     * @event pointerover
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a pointer device is moved off the display object
	     *
	     * @event pointerout
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a touch point is placed on the display object.
	     *
	     * @event touchstart
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a touch point is removed from the display object.
	     *
	     * @event touchend
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a touch point is placed and removed from the display object.
	     *
	     * @event tap
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a touch point is removed outside of the display object that initially
	     * registered a [touchstart]{@link Tiny.interaction.InteractionManager#event:touchstart}.
	     *
	     * @event touchendoutside
	     * @memberof Tiny.interaction.InteractionManager#
	     */

	    /**
	     * Fired when a touch point is moved along the display object.
	     *
	     * @event touchmove
	     * @memberof Tiny.interaction.InteractionManager#
	     */
	    return _this;
	  }

	  /**
	   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
	   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
	   * another DOM element to receive those events.
	   *
	   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.
	   * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).
	   * @private
	   */


	  _createClass(InteractionManager, [{
	    key: 'setTargetElement',
	    value: function setTargetElement(element) {
	      var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	      this.removeEvents();

	      this.interactionDOMElement = element;

	      this.resolution = resolution;

	      this.addEvents();
	    }

	    /**
	     * Registers all the DOM events
	     *
	     * @private
	     */

	  }, {
	    key: 'addEvents',
	    value: function addEvents() {
	      if (!this.interactionDOMElement) {
	        return;
	      }

	      core.ticker.shared.add(this.update, this);

	      if (window.navigator.msPointerEnabled) {
	        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
	        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
	      } else if (this.supportsPointerEvents) {
	        this.interactionDOMElement.style['touch-action'] = 'none';
	      }

	      /**
	       * These events are added first, so that if pointer events are normalised, they are fired
	       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd
	       */
	      if (this.supportsPointerEvents) {
	        window.document.addEventListener('pointermove', this.onPointerMove, true);
	        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);
	        this.interactionDOMElement.addEventListener('pointerout', this.onPointerOut, true);
	        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
	        window.addEventListener('pointerup', this.onPointerUp, true);
	      } else {
	        /**
	         * If pointer events aren't available on a device, this will turn either the touch or
	         * mouse events into pointer events. This allows a developer to just listen for emitted
	         * pointer events on interactive sprites
	         */
	        if (this.normalizeTouchEvents) {
	          this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
	          this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
	          this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
	        }

	        if (this.normalizeMouseEvents) {
	          window.document.addEventListener('mousemove', this.onPointerMove, true);
	          this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
	          this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
	          this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
	          window.addEventListener('mouseup', this.onPointerUp, true);
	        }
	      }

	      window.document.addEventListener('mousemove', this.onMouseMove, true);
	      this.interactionDOMElement.addEventListener('mousedown', this.onMouseDown, true);
	      this.interactionDOMElement.addEventListener('mouseout', this.onMouseOut, true);
	      this.interactionDOMElement.addEventListener('mouseover', this.onMouseOver, true);
	      window.addEventListener('mouseup', this.onMouseUp, true);

	      if (this.supportsTouchEvents) {
	        this.interactionDOMElement.addEventListener('touchstart', this.onTouchStart, true);
	        this.interactionDOMElement.addEventListener('touchend', this.onTouchEnd, true);
	        this.interactionDOMElement.addEventListener('touchmove', this.onTouchMove, true);
	      }

	      this.eventsAdded = true;
	    }

	    /**
	     * Removes all the DOM events that were previously registered
	     *
	     * @private
	     */

	  }, {
	    key: 'removeEvents',
	    value: function removeEvents() {
	      if (!this.interactionDOMElement) {
	        return;
	      }

	      core.ticker.shared.remove(this.update, this);

	      if (window.navigator.msPointerEnabled) {
	        this.interactionDOMElement.style['-ms-content-zooming'] = '';
	        this.interactionDOMElement.style['-ms-touch-action'] = '';
	      } else if (this.supportsPointerEvents) {
	        this.interactionDOMElement.style['touch-action'] = '';
	      }

	      if (this.supportsPointerEvents) {
	        window.document.removeEventListener('pointermove', this.onPointerMove, true);
	        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
	        this.interactionDOMElement.removeEventListener('pointerout', this.onPointerOut, true);
	        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
	        window.removeEventListener('pointerup', this.onPointerUp, true);
	      } else {
	        /**
	         * If pointer events aren't available on a device, this will turn either the touch or
	         * mouse events into pointer events. This allows a developer to just listen for emitted
	         * pointer events on interactive sprites
	         */
	        if (this.normalizeTouchEvents) {
	          this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
	          this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
	          this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
	        }

	        if (this.normalizeMouseEvents) {
	          window.document.removeEventListener('mousemove', this.onPointerMove, true);
	          this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
	          this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
	          this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
	          window.removeEventListener('mouseup', this.onPointerUp, true);
	        }
	      }

	      window.document.removeEventListener('mousemove', this.onMouseMove, true);
	      this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
	      this.interactionDOMElement.removeEventListener('mouseout', this.onMouseOut, true);
	      this.interactionDOMElement.removeEventListener('mouseover', this.onMouseOver, true);
	      window.removeEventListener('mouseup', this.onMouseUp, true);

	      if (this.supportsTouchEvents) {
	        this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
	        this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);
	        this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);
	      }

	      this.interactionDOMElement = null;

	      this.eventsAdded = false;
	    }

	    /**
	     * Updates the state of interactive objects.
	     * Invoked by a throttled ticker update from {@link Tiny.ticker.shared}.
	     *
	     * @param {number} deltaTime - time delta since last tick
	     */

	  }, {
	    key: 'update',
	    value: function update(deltaTime) {
	      this._deltaTime += deltaTime;

	      if (this._deltaTime < this.interactionFrequency) {
	        return;
	      }

	      this._deltaTime = 0;

	      if (!this.interactionDOMElement) {
	        return;
	      }

	      // if the user move the mouse this check has already been dfone using the mouse move!
	      if (this.didMove) {
	        this.didMove = false;

	        return;
	      }

	      this.cursor = this.defaultCursorStyle;

	      // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
	      // but there was a scenario of a display object moving under a static mouse cursor.
	      // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function
	      this.eventData._reset();

	      this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true);

	      if (this.currentCursorStyle !== this.cursor) {
	        this.currentCursorStyle = this.cursor;
	        this.interactionDOMElement.style.cursor = this.cursor;
	      }

	      // TODO
	    }

	    /**
	     * Dispatches an event on the display object that was interacted with
	     *
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - the display object in question
	     * @param {string} eventString - the name of the event (e.g, mousedown)
	     * @param {object} eventData - the event data object
	     * @private
	     */

	  }, {
	    key: 'dispatchEvent',
	    value: function dispatchEvent(displayObject, eventString, eventData) {
	      if (!eventData.stopped) {
	        eventData.currentTarget = displayObject;
	        eventData.type = eventString;

	        displayObject.emit(eventString, eventData);

	        if (displayObject[eventString]) {
	          displayObject[eventString](eventData);
	        }
	      }
	    }

	    /**
	     * Maps x and y coords from a DOM object and maps them correctly to the Tiny view. The
	     * resulting value is stored in the point. This takes into account the fact that the DOM
	     * element could be scaled and positioned anywhere on the screen.
	     *
	     * @param  {Tiny.Point} point - the point that the result will be stored in
	     * @param  {number} x - the x coord of the position to map
	     * @param  {number} y - the y coord of the position to map
	     */

	  }, {
	    key: 'mapPositionToPoint',
	    value: function mapPositionToPoint(point, x, y) {
	      var rect = void 0;

	      // IE 11 fix
	      if (!this.interactionDOMElement.parentElement) {
	        rect = { x: 0, y: 0, width: 0, height: 0 };
	      } else {
	        rect = this.interactionDOMElement.getBoundingClientRect();
	      }

	      var resolutionMultiplier = navigator.isCocoonJS ? this.resolution : 1.0 / this.resolution;

	      point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
	      point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
	    }

	    /**
	     * This function is provides a neat way of crawling through the scene graph and running a
	     * specified function on all interactive objects it finds. It will also take care of hit
	     * testing the interactive objects and passes the hit across in the function.
	     *
	     * @param {Tiny.Point} point - the point that is tested for collision
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - the displayObject
	     *  that will be hit test (recursively crawls its children)
	     * @param {Function} [func] - the function that will be called on each interactive object. The
	     *  displayObject and hit will be passed to the function
	     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
	     * @param {boolean} [interactive] - Whether the displayObject is interactive
	     * @return {boolean} returns true if the displayObject hit the point
	     */

	  }, {
	    key: 'processInteractive',
	    value: function processInteractive(point, displayObject, func, hitTest, interactive) {
	      if (!displayObject || !displayObject.visible) {
	        return false;
	      }

	      // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
	      //
	      // This function will now loop through all objects and then only hit test the objects it HAS
	      // to, not all of them. MUCH faster..
	      // An object will be hit test if the following is true:
	      //
	      // 1: It is interactive.
	      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
	      //
	      // As another little optimisation once an interactive object has been hit we can carry on
	      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
	      // A final optimisation is that an object is not hit test directly if a child has already been hit.

	      interactive = displayObject.interactive || interactive;

	      var hit = false;
	      var interactiveParent = interactive;

	      // if the displayobject has a hitArea, then it does not need to hitTest children.
	      if (displayObject.hitArea) {
	        interactiveParent = false;
	      }

	      // it has a mask! Then lets hit test that before continuing..
	      if (hitTest && displayObject._mask) {
	        if (!displayObject._mask.containsPoint(point)) {
	          hitTest = false;
	        }
	      }

	      // it has a filterArea! Same as mask but easier, its a rectangle
	      if (hitTest && displayObject.filterArea) {
	        if (!displayObject.filterArea.contains(point.x, point.y)) {
	          hitTest = false;
	        }
	      }

	      // ** FREE TIP **! If an object is not interactive or has no buttons in it
	      // (such as a game scene!) set interactiveChildren to false for that displayObject.
	      // This will allow Tiny to completely ignore and bypass checking the displayObjects children.
	      if (displayObject.interactiveChildren && displayObject.children) {
	        var children = displayObject.children;

	        for (var i = children.length - 1; i >= 0; i--) {
	          var child = children[i];

	          // time to get recursive.. if this function will return if something is hit..
	          if (this.processInteractive(point, child, func, hitTest, interactiveParent)) {
	            // its a good idea to check if a child has lost its parent.
	            // this means it has been removed whilst looping so its best
	            if (!child.parent) {
	              continue;
	            }

	            hit = true;

	            // we no longer need to hit test any more objects in this container as we we
	            // now know the parent has been hit
	            interactiveParent = false;

	            // If the child is interactive , that means that the object hit was actually
	            // interactive and not just the child of an interactive object.
	            // This means we no longer need to hit test anything else. We still need to run
	            // through all objects, but we don't need to perform any hit tests.

	            // {
	            hitTest = false;
	            // }

	            // we can break now as we have hit an object.
	          }
	        }
	      }

	      // no point running this if the item is not interactive or does not have an interactive parent.
	      if (interactive) {
	        // if we are hit testing (as in we have no hit any objects yet)
	        // We also don't need to worry about hit testing if once of the displayObjects children
	        // has already been hit!
	        if (hitTest && !hit) {
	          if (displayObject.hitArea) {
	            displayObject.worldTransform.applyInverse(point, this._tempPoint);
	            hit = displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y);
	          } else if (displayObject.containsPoint) {
	            hit = displayObject.containsPoint(point);
	          }
	        }

	        if (displayObject.interactive) {
	          if (hit && !this.eventData.target) {
	            this.eventData.target = displayObject;
	            this.mouse.target = displayObject;
	            this.pointer.target = displayObject;
	          }

	          func(displayObject, hit);
	        }
	      }

	      return hit;
	    }

	    /**
	     * Is called when the mouse button is pressed down on the renderer element
	     *
	     * @private
	     * @param {MouseEvent} event - The DOM event of a mouse button being pressed down
	     */

	  }, {
	    key: 'onMouseDown',
	    value: function onMouseDown(event) {
	      this.mouse.originalEvent = event;
	      this.eventData.data = this.mouse;
	      this.eventData._reset();

	      // Update internal mouse reference
	      this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);

	      if (this.autoPreventDefault) {
	        this.mouse.originalEvent.preventDefault();
	      }

	      this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true);

	      var isRightButton = event.button === 2 || event.which === 3;

	      this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
	    }

	    /**
	     * Processes the result of the mouse down check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processMouseDown',
	    value: function processMouseDown(displayObject, hit) {
	      var e = this.mouse.originalEvent;

	      var isRightButton = e.button === 2 || e.which === 3;

	      if (hit) {
	        displayObject[isRightButton ? '_isRightDown' : '_isLeftDown'] = true;
	        this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData);
	      }
	    }

	    /**
	     * Is called when the mouse button is released on the renderer element
	     *
	     * @private
	     * @param {MouseEvent} event - The DOM event of a mouse button being released
	     */

	  }, {
	    key: 'onMouseUp',
	    value: function onMouseUp(event) {
	      this.mouse.originalEvent = event;
	      this.eventData.data = this.mouse;
	      this.eventData._reset();

	      // Update internal mouse reference
	      this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);

	      this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true);

	      var isRightButton = event.button === 2 || event.which === 3;

	      this.emit(isRightButton ? 'rightup' : 'mouseup', this.eventData);
	    }

	    /**
	     * Processes the result of the mouse up check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processMouseUp',
	    value: function processMouseUp(displayObject, hit) {
	      var e = this.mouse.originalEvent;

	      var isRightButton = e.button === 2 || e.which === 3;
	      var isDown = isRightButton ? '_isRightDown' : '_isLeftDown';

	      if (hit) {
	        this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData);

	        if (displayObject[isDown]) {
	          displayObject[isDown] = false;
	          this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', this.eventData);
	        }
	      } else if (displayObject[isDown]) {
	        displayObject[isDown] = false;
	        this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData);
	      }
	    }

	    /**
	     * Is called when the mouse moves across the renderer element
	     *
	     * @private
	     * @param {MouseEvent} event - The DOM event of the mouse moving
	     */

	  }, {
	    key: 'onMouseMove',
	    value: function onMouseMove(event) {
	      this.mouse.originalEvent = event;
	      this.eventData.data = this.mouse;
	      this.eventData._reset();

	      this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);

	      this.didMove = true;

	      this.cursor = this.defaultCursorStyle;

	      this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true);

	      this.emit('mousemove', this.eventData);

	      if (this.currentCursorStyle !== this.cursor) {
	        this.currentCursorStyle = this.cursor;
	        this.interactionDOMElement.style.cursor = this.cursor;
	      }

	      // TODO BUG for parents interactive object (border order issue)
	    }

	    /**
	     * Processes the result of the mouse move check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processMouseMove',
	    value: function processMouseMove(displayObject, hit) {
	      this.processMouseOverOut(displayObject, hit);

	      // only display on mouse over
	      if (!this.moveWhenInside || hit) {
	        this.dispatchEvent(displayObject, 'mousemove', this.eventData);
	      }
	    }

	    /**
	     * Is called when the mouse is moved out of the renderer element
	     *
	     * @private
	     * @param {MouseEvent} event - The DOM event of the mouse being moved out
	     */

	  }, {
	    key: 'onMouseOut',
	    value: function onMouseOut(event) {
	      this.mouseOverRenderer = false;

	      this.mouse.originalEvent = event;
	      this.eventData.data = this.mouse;
	      this.eventData._reset();

	      // Update internal mouse reference
	      this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);

	      this.interactionDOMElement.style.cursor = this.defaultCursorStyle;

	      // TODO optimize by not check EVERY TIME! maybe half as often? //
	      this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);

	      this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false);

	      this.emit('mouseout', this.eventData);
	    }

	    /**
	     * Processes the result of the mouse over/out check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processMouseOverOut',
	    value: function processMouseOverOut(displayObject, hit) {
	      if (hit && this.mouseOverRenderer) {
	        if (!displayObject._mouseOver) {
	          displayObject._mouseOver = true;
	          this.dispatchEvent(displayObject, 'mouseover', this.eventData);
	        }

	        if (displayObject.buttonMode) {
	          this.cursor = displayObject.defaultCursor;
	        }
	      } else if (displayObject._mouseOver) {
	        displayObject._mouseOver = false;
	        this.dispatchEvent(displayObject, 'mouseout', this.eventData);
	      }
	    }

	    /**
	     * Is called when the mouse enters the renderer element area
	     *
	     * @private
	     * @param {MouseEvent} event - The DOM event of the mouse moving into the renderer view
	     */

	  }, {
	    key: 'onMouseOver',
	    value: function onMouseOver(event) {
	      this.mouseOverRenderer = true;

	      this.mouse.originalEvent = event;
	      this.eventData.data = this.mouse;
	      this.eventData._reset();

	      this.emit('mouseover', this.eventData);
	    }

	    /**
	     * Is called when the pointer button is pressed down on the renderer element
	     *
	     * @private
	     * @param {PointerEvent} event - The DOM event of a pointer button being pressed down
	     */

	  }, {
	    key: 'onPointerDown',
	    value: function onPointerDown(event) {
	      this.normalizeToPointerData(event);
	      this.pointer.originalEvent = event;
	      this.eventData.data = this.pointer;
	      this.eventData._reset();

	      // Update internal pointer reference
	      this.mapPositionToPoint(this.pointer.global, event.clientX, event.clientY);

	      /**
	       * No need to prevent default on natural pointer events, as there are no side effects
	       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
	       * so still need to be prevented.
	       */
	      if (this.autoPreventDefault && (this.normalizeMouseEvents || this.normalizeTouchEvents)) {
	        this.pointer.originalEvent.preventDefault();
	      }

	      this.processInteractive(this.pointer.global, this.renderer._lastObjectRendered, this.processPointerDown, true);

	      this.emit('pointerdown', this.eventData);
	    }

	    /**
	     * Processes the result of the pointer down check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processPointerDown',
	    value: function processPointerDown(displayObject, hit) {
	      if (hit) {
	        displayObject._pointerDown = true;
	        this.dispatchEvent(displayObject, 'pointerdown', this.eventData);
	      }
	    }

	    /**
	     * Is called when the pointer button is released on the renderer element
	     *
	     * @private
	     * @param {PointerEvent} event - The DOM event of a pointer button being released
	     */

	  }, {
	    key: 'onPointerUp',
	    value: function onPointerUp(event) {
	      this.normalizeToPointerData(event);
	      this.pointer.originalEvent = event;
	      this.eventData.data = this.pointer;
	      this.eventData._reset();

	      // Update internal pointer reference
	      this.mapPositionToPoint(this.pointer.global, event.clientX, event.clientY);

	      this.processInteractive(this.pointer.global, this.renderer._lastObjectRendered, this.processPointerUp, true);

	      this.emit('pointerup', this.eventData);
	    }

	    /**
	     * Processes the result of the pointer up check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processPointerUp',
	    value: function processPointerUp(displayObject, hit) {
	      if (hit) {
	        this.dispatchEvent(displayObject, 'pointerup', this.eventData);

	        if (displayObject._pointerDown) {
	          displayObject._pointerDown = false;
	          this.dispatchEvent(displayObject, 'pointertap', this.eventData);
	        }
	      } else if (displayObject._pointerDown) {
	        displayObject._pointerDown = false;
	        this.dispatchEvent(displayObject, 'pointerupoutside', this.eventData);
	      }
	    }

	    /**
	     * Is called when the pointer moves across the renderer element
	     *
	     * @private
	     * @param {PointerEvent} event - The DOM event of a pointer moving
	     */

	  }, {
	    key: 'onPointerMove',
	    value: function onPointerMove(event) {
	      this.normalizeToPointerData(event);
	      this.pointer.originalEvent = event;
	      this.eventData.data = this.pointer;
	      this.eventData._reset();

	      this.mapPositionToPoint(this.pointer.global, event.clientX, event.clientY);

	      this.processInteractive(this.pointer.global, this.renderer._lastObjectRendered, this.processPointerMove, true);

	      this.emit('pointermove', this.eventData);
	    }

	    /**
	     * Processes the result of the pointer move check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processPointerMove',
	    value: function processPointerMove(displayObject, hit) {
	      if (!this.pointer.originalEvent.changedTouches) {
	        this.processPointerOverOut(displayObject, hit);
	      }

	      if (!this.moveWhenInside || hit) {
	        this.dispatchEvent(displayObject, 'pointermove', this.eventData);
	      }
	    }

	    /**
	     * Is called when the pointer is moved out of the renderer element
	     *
	     * @private
	     * @param {PointerEvent} event - The DOM event of a pointer being moved out
	     */

	  }, {
	    key: 'onPointerOut',
	    value: function onPointerOut(event) {
	      this.normalizeToPointerData(event);
	      this.pointer.originalEvent = event;
	      this.eventData.data = this.pointer;
	      this.eventData._reset();

	      // Update internal pointer reference
	      this.mapPositionToPoint(this.pointer.global, event.clientX, event.clientY);

	      this.processInteractive(this.pointer.global, this.renderer._lastObjectRendered, this.processPointerOverOut, false);

	      this.emit('pointerout', this.eventData);
	    }

	    /**
	     * Processes the result of the pointer over/out check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processPointerOverOut',
	    value: function processPointerOverOut(displayObject, hit) {
	      if (hit && this.mouseOverRenderer) {
	        if (!displayObject._pointerOver) {
	          displayObject._pointerOver = true;
	          this.dispatchEvent(displayObject, 'pointerover', this.eventData);
	        }
	      } else if (displayObject._pointerOver) {
	        displayObject._pointerOver = false;
	        this.dispatchEvent(displayObject, 'pointerout', this.eventData);
	      }
	    }

	    /**
	     * Is called when the pointer is moved into the renderer element
	     *
	     * @private
	     * @param {PointerEvent} event - The DOM event of a pointer button being moved into the renderer view
	     */

	  }, {
	    key: 'onPointerOver',
	    value: function onPointerOver(event) {
	      this.pointer.originalEvent = event;
	      this.eventData.data = this.pointer;
	      this.eventData._reset();

	      this.emit('pointerover', this.eventData);
	    }

	    /**
	     * Is called when a touch is started on the renderer element
	     *
	     * @private
	     * @param {TouchEvent} event - The DOM event of a touch starting on the renderer view
	     */

	  }, {
	    key: 'onTouchStart',
	    value: function onTouchStart(event) {
	      if (this.autoPreventDefault) {
	        event.preventDefault();
	      }

	      var changedTouches = event.changedTouches;
	      var cLength = changedTouches.length;

	      for (var i = 0; i < cLength; i++) {
	        var touch = changedTouches[i];
	        var touchData = this.getTouchData(touch);

	        touchData.originalEvent = event;

	        this.eventData.data = touchData;
	        this.eventData._reset();

	        this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true);

	        this.emit('touchstart', this.eventData);

	        this.returnTouchData(touchData);
	      }
	    }

	    /**
	     * Processes the result of a touch check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processTouchStart',
	    value: function processTouchStart(displayObject, hit) {
	      if (hit) {
	        displayObject._touchDown = true;
	        this.dispatchEvent(displayObject, 'touchstart', this.eventData);
	      }
	    }

	    /**
	     * Is called when a touch ends on the renderer element
	     *
	     * @private
	     * @param {TouchEvent} event - The DOM event of a touch ending on the renderer view
	     */

	  }, {
	    key: 'onTouchEnd',
	    value: function onTouchEnd(event) {
	      if (this.autoPreventDefault) {
	        event.preventDefault();
	      }

	      var changedTouches = event.changedTouches;
	      var cLength = changedTouches.length;

	      for (var i = 0; i < cLength; i++) {
	        var touchEvent = changedTouches[i];

	        var touchData = this.getTouchData(touchEvent);

	        touchData.originalEvent = event;

	        // TODO this should be passed along.. no set
	        this.eventData.data = touchData;
	        this.eventData._reset();

	        this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true);

	        this.emit('touchend', this.eventData);

	        this.returnTouchData(touchData);
	      }
	    }

	    /**
	     * Processes the result of the end of a touch and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processTouchEnd',
	    value: function processTouchEnd(displayObject, hit) {
	      if (hit) {
	        this.dispatchEvent(displayObject, 'touchend', this.eventData);

	        if (displayObject._touchDown) {
	          displayObject._touchDown = false;
	          this.dispatchEvent(displayObject, 'tap', this.eventData);
	        }
	      } else if (displayObject._touchDown) {
	        displayObject._touchDown = false;
	        this.dispatchEvent(displayObject, 'touchendoutside', this.eventData);
	      }
	    }

	    /**
	     * Is called when a touch is moved across the renderer element
	     *
	     * @private
	     * @param {TouchEvent} event - The DOM event of a touch moving accross the renderer view
	     */

	  }, {
	    key: 'onTouchMove',
	    value: function onTouchMove(event) {
	      if (this.autoPreventDefault) {
	        event.preventDefault();
	      }

	      var changedTouches = event.changedTouches;
	      var cLength = changedTouches.length;

	      for (var i = 0; i < cLength; i++) {
	        var touchEvent = changedTouches[i];

	        var touchData = this.getTouchData(touchEvent);

	        touchData.originalEvent = event;

	        this.eventData.data = touchData;
	        this.eventData._reset();

	        this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, this.moveWhenInside);

	        this.emit('touchmove', this.eventData);

	        this.returnTouchData(touchData);
	      }
	    }

	    /**
	     * Processes the result of a touch move check and dispatches the event if need be
	     *
	     * @private
	     * @param {Tiny.Container|Tiny.Sprite|Tiny.TilingSprite} displayObject - The display object that was tested
	     * @param {boolean} hit - the result of the hit test on the display object
	     */

	  }, {
	    key: 'processTouchMove',
	    value: function processTouchMove(displayObject, hit) {
	      if (!this.moveWhenInside || hit) {
	        this.dispatchEvent(displayObject, 'touchmove', this.eventData);
	      }
	    }

	    /**
	     * Grabs an interaction data object from the internal pool
	     *
	     * @private
	     * @param {Touch} touch - The touch data we need to pair with an interactionData object
	     * @return {Tiny.interaction.InteractionData} The built data object.
	     */

	  }, {
	    key: 'getTouchData',
	    value: function getTouchData(touch) {
	      var touchData = this.interactiveDataPool.pop() || new _InteractionData2.default();

	      touchData.identifier = touch.identifier;
	      this.mapPositionToPoint(touchData.global, touch.clientX, touch.clientY);

	      if (navigator.isCocoonJS) {
	        touchData.global.x = touchData.global.x / this.resolution;
	        touchData.global.y = touchData.global.y / this.resolution;
	      }

	      touch.globalX = touchData.global.x;
	      touch.globalY = touchData.global.y;

	      return touchData;
	    }

	    /**
	     * Returns an interaction data object to the internal pool
	     *
	     * @private
	     * @param {Tiny.interaction.InteractionData} touchData - The touch data object we want to return to the pool
	     */

	  }, {
	    key: 'returnTouchData',
	    value: function returnTouchData(touchData) {
	      this.interactiveDataPool.push(touchData);
	    }

	    /**
	     * Ensures that the original event object contains all data that a regular pointer event would have
	     *
	     * @private
	     * @param {TouchEvent|MouseEvent} event - The original event data from a touch or mouse event
	     */

	  }, {
	    key: 'normalizeToPointerData',
	    value: function normalizeToPointerData(event) {
	      if (this.normalizeTouchEvents && event.changedTouches) {
	        if (typeof event.button === 'undefined') event.button = event.touches.length ? 1 : 0;
	        if (typeof event.buttons === 'undefined') event.buttons = event.touches.length ? 1 : 0;
	        if (typeof event.isPrimary === 'undefined') event.isPrimary = event.touches.length === 1;
	        if (typeof event.width === 'undefined') event.width = event.changedTouches[0].radiusX || 1;
	        if (typeof event.height === 'undefined') event.height = event.changedTouches[0].radiusY || 1;
	        if (typeof event.tiltX === 'undefined') event.tiltX = 0;
	        if (typeof event.tiltY === 'undefined') event.tiltY = 0;
	        if (typeof event.pointerType === 'undefined') event.pointerType = 'touch';
	        if (typeof event.pointerId === 'undefined') event.pointerId = event.changedTouches[0].identifier || 0;
	        if (typeof event.pressure === 'undefined') event.pressure = event.changedTouches[0].force || 0.5;
	        if (typeof event.rotation === 'undefined') event.rotation = event.changedTouches[0].rotationAngle || 0;

	        if (typeof event.clientX === 'undefined') event.clientX = event.changedTouches[0].clientX;
	        if (typeof event.clientY === 'undefined') event.clientY = event.changedTouches[0].clientY;
	        if (typeof event.pageX === 'undefined') event.pageX = event.changedTouches[0].pageX;
	        if (typeof event.pageY === 'undefined') event.pageY = event.changedTouches[0].pageY;
	        if (typeof event.screenX === 'undefined') event.screenX = event.changedTouches[0].screenX;
	        if (typeof event.screenY === 'undefined') event.screenY = event.changedTouches[0].screenY;
	        if (typeof event.layerX === 'undefined') event.layerX = event.offsetX = event.clientX;
	        if (typeof event.layerY === 'undefined') event.layerY = event.offsetY = event.clientY;
	      } else if (this.normalizeMouseEvents) {
	        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;
	        if (typeof event.width === 'undefined') event.width = 1;
	        if (typeof event.height === 'undefined') event.height = 1;
	        if (typeof event.tiltX === 'undefined') event.tiltX = 0;
	        if (typeof event.tiltY === 'undefined') event.tiltY = 0;
	        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';
	        if (typeof event.pointerId === 'undefined') event.pointerId = 1;
	        if (typeof event.pressure === 'undefined') event.pressure = 0.5;
	        if (typeof event.rotation === 'undefined') event.rotation = 0;
	      }
	    }

	    /**
	     * Destroys the interaction manager
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.removeEvents();

	      this.removeAllListeners();

	      this.renderer = null;

	      this.mouse = null;

	      this.eventData = null;

	      this.interactiveDataPool = null;

	      this.interactionDOMElement = null;

	      this.onMouseDown = null;
	      this.processMouseDown = null;

	      this.onMouseUp = null;
	      this.processMouseUp = null;

	      this.onMouseMove = null;
	      this.processMouseMove = null;

	      this.onMouseOut = null;
	      this.processMouseOverOut = null;

	      this.onMouseOver = null;

	      this.onPointerDown = null;
	      this.processPointerDown = null;

	      this.onPointerUp = null;
	      this.processPointerUp = null;

	      this.onPointerMove = null;
	      this.processPointerMove = null;

	      this.onPointerOut = null;
	      this.processPointerOverOut = null;

	      this.onPointerOver = null;

	      this.onTouchStart = null;
	      this.processTouchStart = null;

	      this.onTouchEnd = null;
	      this.processTouchEnd = null;

	      this.onTouchMove = null;
	      this.processTouchMove = null;

	      this._tempPoint = null;
	    }
	  }]);

	  return InteractionManager;
	}(_eventemitter2.default);

	exports.default = InteractionManager;


	core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
	core.CanvasRenderer.registerPlugin('interaction', InteractionManager);

/***/ }),
/* 127 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Event class that mimics native DOM events.
	 *
	 * @class
	 * @memberof Tiny.interaction
	 */
	var InteractionEvent = function () {
	  /**
	   *
	   */
	  function InteractionEvent() {
	    _classCallCheck(this, InteractionEvent);

	    /**
	     * Whether this event will continue propagating in the tree
	     *
	     * @member {boolean}
	     */
	    this.stopped = false;

	    /**
	     * The object which caused this event to be dispatched.
	     * For listener callback see {@link Tiny.interaction.InteractionEvent.currentTarget}.
	     *
	     * @member {Tiny.DisplayObject}
	     */
	    this.target = null;

	    /**
	     * The object whose event listener’s callback is currently being invoked.
	     *
	     * @member {Tiny.DisplayObject}
	     */
	    this.currentTarget = null;

	    /*
	     * Type of the event
	     *
	     * @member {string}
	     */
	    this.type = null;

	    /*
	     * InteractionData related to this event
	     *
	     * @member {Tiny.interaction.InteractionData}
	     */
	    this.data = null;
	  }

	  /**
	   * Prevents event from reaching any objects other than the current object.
	   *
	   */


	  _createClass(InteractionEvent, [{
	    key: "stopPropagation",
	    value: function stopPropagation() {
	      this.stopped = true;
	    }

	    /**
	     * Prevents event from reaching any objects other than the current object.
	     *
	     * @private
	     */

	  }, {
	    key: "_reset",
	    value: function _reset() {
	      this.stopped = false;
	      this.currentTarget = null;
	      this.target = null;
	    }
	  }]);

	  return InteractionEvent;
	}();

	exports.default = InteractionEvent;

/***/ }),
/* 128 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Default property values of interactive objects
	 * Used by {@link Tiny.interaction.InteractionManager} to automatically give all DisplayObjects these properties
	 *
	 * @mixin
	 * @name interactiveTarget
	 * @memberof Tiny.interaction
	 * @example
	 *      function MyObject() {}
	 *
	 *      Object.assign(
	 *          MyObject.prototype,
	 *          Tiny.interaction.interactiveTarget
	 *      );
	 */
	exports.default = {
	  /**
	   * Determines if the displayObject be clicked/touched
	   *
	   * @inner {boolean}
	   */
	  interactive: false,

	  /**
	   * Determines if the children to the displayObject can be clicked/touched
	   * Setting this to false allows Tiny to bypass a recursive hitTest function
	   *
	   * @inner {boolean}
	   */
	  interactiveChildren: true,

	  /**
	   * Interaction shape. Children will be hit first, then this shape will be checked.
	   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
	   *
	   * @inner {Tiny.Rectangle|Tiny.Circle|Tiny.Ellipse|Tiny.Polygon|Tiny.RoundedRectangle}
	   */
	  hitArea: null,

	  /**
	   * If enabled, the mouse cursor will change when hovered over the displayObject if it is interactive
	   *
	   * @inner {boolean}
	   */
	  buttonMode: false,

	  /**
	   * If buttonMode is enabled, this defines what CSS cursor property is used when the mouse cursor
	   * is hovered over the displayObject
	   *
	   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
	   *
	   * @inner {string}
	   */
	  defaultCursor: 'pointer',

	  // some internal checks..
	  /**
	   * Internal check to detect if the mouse cursor is hovered over the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _over: false,

	  /**
	   * Internal check to detect if the left mouse button is pressed on the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _isLeftDown: false,

	  /**
	   * Internal check to detect if the right mouse button is pressed on the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _isRightDown: false,

	  /**
	   * Internal check to detect if the pointer cursor is hovered over the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _pointerOver: false,

	  /**
	   * Internal check to detect if the pointer is down on the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _pointerDown: false,

	  /**
	   * Internal check to detect if a user has touched the displayObject
	   *
	   * @inner {boolean}
	   * @private
	   */
	  _touchDown: false
	};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _loader = __webpack_require__(130);

	Object.defineProperty(exports, 'Loader', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_loader).default;
	  }
	});

	var _bitmapFontParser = __webpack_require__(141);

	Object.defineProperty(exports, 'bitmapFontParser', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_bitmapFontParser).default;
	  }
	});
	Object.defineProperty(exports, 'parseBitmapFontData', {
	  enumerable: true,
	  get: function get() {
	    return _bitmapFontParser.parse;
	  }
	});

	var _spritesheetParser = __webpack_require__(140);

	Object.defineProperty(exports, 'spritesheetParser', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_spritesheetParser).default;
	  }
	});

	var _textureParser = __webpack_require__(139);

	Object.defineProperty(exports, 'textureParser', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_textureParser).default;
	  }
	});

	var _resourceLoader = __webpack_require__(131);

	Object.defineProperty(exports, 'Resource', {
	  enumerable: true,
	  get: function get() {
	    return _resourceLoader.Resource;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _resourceLoader = __webpack_require__(131);

	var _resourceLoader2 = _interopRequireDefault(_resourceLoader);

	var _blob = __webpack_require__(138);

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _utils = __webpack_require__(18);

	var utils = _interopRequireWildcard(_utils);

	var _textureParser = __webpack_require__(139);

	var _textureParser2 = _interopRequireDefault(_textureParser);

	var _spritesheetParser = __webpack_require__(140);

	var _spritesheetParser2 = _interopRequireDefault(_spritesheetParser);

	var _bitmapFontParser = __webpack_require__(141);

	var _bitmapFontParser2 = _interopRequireDefault(_bitmapFontParser);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 *
	 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
	 *
	 * ```js
	 * let loader = Tiny.Loader; // Tiny exposes a premade instance for you to use.
	 * //or
	 * let loader = new Tiny.loaders.Loader(); // you can also create your own if you want
	 *
	 * loader.add('bunny', 'data/bunny.png');
	 * loader.add('spaceship', 'assets/spritesheet.json');
	 * loader.add('scoreFont', 'assets/score.fnt');
	 *
	 * loader.once('complete',onAssetsLoaded);
	 *
	 * loader.load();
	 * ```
	 *
	 * @see https://github.com/englercj/resource-loader
	 *
	 * @class
	 * @extends module:resource-loader.ResourceLoader
	 * @memberof Tiny.loaders
	 */
	var Loader = function (_ResourceLoader) {
	  _inherits(Loader, _ResourceLoader);

	  /**
	   * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
	   * @param {number} [concurrency=10] - The number of resources to load concurrently.
	   */
	  function Loader(baseUrl, concurrency) {
	    _classCallCheck(this, Loader);

	    var _this = _possibleConstructorReturn(this, (Loader.__proto__ || Object.getPrototypeOf(Loader)).call(this, baseUrl, concurrency));

	    _eventemitter2.default.call(_this);

	    for (var i = 0; i < Loader._tinyMiddleware.length; ++i) {
	      _this.use(Loader._tinyMiddleware[i]());
	    }

	    // Compat layer, translate the new v2 signals into old v1 events.
	    _this.onStart.add(function (l) {
	      return _this.emit('start', l);
	    });
	    _this.onProgress.add(function (l, r) {
	      return _this.emit('progress', l, r);
	    });
	    _this.onError.add(function (e, l, r) {
	      return _this.emit('error', e, l, r);
	    });
	    _this.onLoad.add(function (l, r) {
	      return _this.emit('load', l, r);
	    });
	    _this.onComplete.add(function (l, r) {
	      return _this.emit('complete', l, r);
	    });
	    return _this;
	  }

	  /**
	   * Adds a default middleware to the Tiny loader.
	   *
	   * @static
	   * @param {Function} fn - The middleware to add.
	   */


	  _createClass(Loader, [{
	    key: 'run',


	    /**
	     *
	     * @param {array}  opts.resources
	     * @param {function}  opts.onProgress
	     * @param {function}  opts.onComplete
	     * @param {function}  opts.onError
	     * @param {function}  opts.onAllComplete
	     */
	    value: function run(opts) {
	      if (!opts) {
	        opts = {};
	      }
	      var res = opts.resources;

	      if (utils.isArray(res)) {
	        this.add(res);
	      } else {
	        throw new Error('The param [resources] must be array');
	      }

	      //单个文件加载出错时调用
	      var onError = function onError(error, resourceLoader, resource) {
	        var errorMsg = error + ', url: ' + resource.url;
	        (opts.onError || function () {
	          throw errorMsg;
	        })(errorMsg, resourceLoader, resource);
	      };

	      var onProgress = function onProgress(resourceLoader, resource) {
	        (opts.onProgress || function () {})(Number(resourceLoader.progress.toFixed(2)), resource);
	      };

	      //单个资源文件加载完成调用
	      var onComplete = function onComplete(resourceLoader, resource) {
	        (opts.onComplete || function () {})(resourceLoader, resource);
	      };

	      var onAllComplete = function onAllComplete(resourceLoader, object) {
	        (opts.onAllComplete || function () {})(resourceLoader, object);
	      };

	      this.on('load', onComplete);

	      //单个文件加载失败
	      this.on('error', onError);

	      //全部加载完成
	      this.on('complete', onAllComplete);

	      this.on('progress', onProgress);

	      this.load();
	    }
	  }], [{
	    key: 'addTinyMiddleware',
	    value: function addTinyMiddleware(fn) {
	      Loader._tinyMiddleware.push(fn);
	    }
	  }]);

	  return Loader;
	}(_resourceLoader2.default);

	// Copy EE3 prototype (mixin)


	exports.default = Loader;
	for (var i in _eventemitter2.default.prototype) {
	  Loader.prototype[i] = _eventemitter2.default.prototype[i];
	}

	Loader._tinyMiddleware = [
	// parse any blob into more usable objects (e.g. Image)
	_blob.blobMiddlewareFactory,
	// parse any Image objects into textures
	_textureParser2.default,
	// parse any spritesheet data into multiple textures
	_spritesheetParser2.default,
	// parse bitmap font data into multiple textures
	_bitmapFontParser2.default];

	// Add custom extentions
	var Resource = _resourceLoader2.default.Resource;

	Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _Loader = __webpack_require__(132);

	var _Loader2 = _interopRequireDefault(_Loader);

	var _Resource = __webpack_require__(136);

	var _Resource2 = _interopRequireDefault(_Resource);

	var _async = __webpack_require__(135);

	var async = _interopRequireWildcard(_async);

	var _b = __webpack_require__(137);

	var b64 = _interopRequireWildcard(_b);

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	_Loader2.default.Resource = _Resource2.default;
	_Loader2.default.async = async;
	_Loader2.default.base64 = b64;

	// export manually, and also as default
	module.exports = _Loader2.default; // eslint-disable-line no-undef
	exports.default = _Loader2.default;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _miniSignals = __webpack_require__(133);

	var _miniSignals2 = _interopRequireDefault(_miniSignals);

	var _parseUri = __webpack_require__(134);

	var _parseUri2 = _interopRequireDefault(_parseUri);

	var _async = __webpack_require__(135);

	var async = _interopRequireWildcard(_async);

	var _Resource = __webpack_require__(136);

	var _Resource2 = _interopRequireDefault(_Resource);

	function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	        return obj;
	    } else {
	        var newObj = {};if (obj != null) {
	            for (var key in obj) {
	                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	            }
	        }newObj.default = obj;return newObj;
	    }
	}

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	// some constants
	var MAX_PROGRESS = 100;
	var rgxExtractUrlHash = /(#[\w-]+)?$/;

	/**
	 * Manages the state and loading of multiple resources to load.
	 *
	 * @class
	 */

	var Loader = function () {
	    /**
	     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
	     * @param {number} [concurrency=10] - The number of resources to load concurrently.
	     */
	    function Loader() {
	        var _this = this;

	        var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

	        _classCallCheck(this, Loader);

	        /**
	         * The base url for all resources loaded by this loader.
	         *
	         * @member {string}
	         */
	        this.baseUrl = baseUrl;

	        /**
	         * The progress percent of the loader going through the queue.
	         *
	         * @member {number}
	         */
	        this.progress = 0;

	        /**
	         * Loading state of the loader, true if it is currently loading resources.
	         *
	         * @member {boolean}
	         */
	        this.loading = false;

	        /**
	         * A querystring to append to every URL added to the loader.
	         *
	         * This should be a valid query string *without* the question-mark (`?`). The loader will
	         * also *not* escape values for you. Make sure to escape your parameters with
	         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.
	         *
	         * @example
	         * const loader = new Loader();
	         *
	         * loader.defaultQueryString = 'user=me&password=secret';
	         *
	         * // This will request 'image.png?user=me&password=secret'
	         * loader.add('image.png').load();
	         *
	         * loader.reset();
	         *
	         * // This will request 'image.png?v=1&user=me&password=secret'
	         * loader.add('iamge.png?v=1').load();
	         */
	        this.defaultQueryString = '';

	        /**
	         * The middleware to run before loading each resource.
	         *
	         * @member {function[]}
	         */
	        this._beforeMiddleware = [];

	        /**
	         * The middleware to run after loading each resource.
	         *
	         * @member {function[]}
	         */
	        this._afterMiddleware = [];

	        /**
	         * The tracks the resources we are currently completing parsing for.
	         *
	         * @member {Resource[]}
	         */
	        this._resourcesParsing = [];

	        /**
	         * The `_loadResource` function bound with this object context.
	         *
	         * @private
	         * @member {function}
	         * @param {Resource} r - The resource to load
	         * @param {Function} d - The dequeue function
	         * @return {undefined}
	         */
	        this._boundLoadResource = function (r, d) {
	            return _this._loadResource(r, d);
	        };

	        /**
	         * The resources waiting to be loaded.
	         *
	         * @private
	         * @member {Resource[]}
	         */
	        this._queue = async.queue(this._boundLoadResource, concurrency);

	        this._queue.pause();

	        /**
	         * All the resources for this loader keyed by name.
	         *
	         * @member {object<string, Resource>}
	         */
	        this.resources = {};

	        /**
	         * Dispatched once per loaded or errored resource.
	         *
	         * The callback looks like {@link Loader.OnProgressSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onProgress = new _miniSignals2.default();

	        /**
	         * Dispatched once per errored resource.
	         *
	         * The callback looks like {@link Loader.OnErrorSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onError = new _miniSignals2.default();

	        /**
	         * Dispatched once per loaded resource.
	         *
	         * The callback looks like {@link Loader.OnLoadSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onLoad = new _miniSignals2.default();

	        /**
	         * Dispatched when the loader begins to process the queue.
	         *
	         * The callback looks like {@link Loader.OnStartSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onStart = new _miniSignals2.default();

	        /**
	         * Dispatched when the queued resources all load.
	         *
	         * The callback looks like {@link Loader.OnCompleteSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onComplete = new _miniSignals2.default();

	        /**
	         * When the progress changes the loader and resource are disaptched.
	         *
	         * @memberof Loader
	         * @callback OnProgressSignal
	         * @param {Loader} loader - The loader the progress is advancing on.
	         * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.
	         */

	        /**
	         * When an error occurrs the loader and resource are disaptched.
	         *
	         * @memberof Loader
	         * @callback OnErrorSignal
	         * @param {Loader} loader - The loader the error happened in.
	         * @param {Resource} resource - The resource that caused the error.
	         */

	        /**
	         * When a load completes the loader and resource are disaptched.
	         *
	         * @memberof Loader
	         * @callback OnLoadSignal
	         * @param {Loader} loader - The loader that laoded the resource.
	         * @param {Resource} resource - The resource that has completed loading.
	         */

	        /**
	         * When the loader starts loading resources it dispatches this callback.
	         *
	         * @memberof Loader
	         * @callback OnStartSignal
	         * @param {Loader} loader - The loader that has started loading resources.
	         */

	        /**
	         * When the loader completes loading resources it dispatches this callback.
	         *
	         * @memberof Loader
	         * @callback OnCompleteSignal
	         * @param {Loader} loader - The loader that has finished loading resources.
	         */
	    }

	    /**
	     * Adds a resource (or multiple resources) to the loader queue.
	     *
	     * This function can take a wide variety of different parameters. The only thing that is always
	     * required the url to load. All the following will work:
	     *
	     * ```js
	     * loader
	     *     // normal param syntax
	     *     .add('key', 'http://...', function () {})
	     *     .add('http://...', function () {})
	     *     .add('http://...')
	     *
	     *     // object syntax
	     *     .add({
	     *         name: 'key2',
	     *         url: 'http://...'
	     *     }, function () {})
	     *     .add({
	     *         url: 'http://...'
	     *     }, function () {})
	     *     .add({
	     *         name: 'key3',
	     *         url: 'http://...'
	     *         onComplete: function () {}
	     *     })
	     *     .add({
	     *         url: 'https://...',
	     *         onComplete: function () {},
	     *         crossOrigin: true
	     *     })
	     *
	     *     // you can also pass an array of objects or urls or both
	     *     .add([
	     *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	     *         { url: 'http://...', onComplete: function () {} },
	     *         'http://...'
	     *     ])
	     *
	     *     // and you can use both params and options
	     *     .add('key', 'http://...', { crossOrigin: true }, function () {})
	     *     .add('http://...', { crossOrigin: true }, function () {});
	     * ```
	     *
	     * @param {string} [name] - The name of the resource to load, if not passed the url is used.
	     * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.
	     * @param {object} [options] - The options for the load.
	     * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.
	     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?
	     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should
	     *      the data being loaded be interpreted when using XHR?
	     * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.
	     * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The
	     *      element to use for loading, instead of creating one.
	     * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This
	     *      is useful if you want to pass in a `loadElement` that you already added load sources to.
	     * @param {function} [cb] - Function to call when this specific resource completes loading.
	     * @return {Loader} Returns itself.
	     */

	    Loader.prototype.add = function add(name, url, options, cb) {
	        // special case of an array of objects or urls
	        if (Array.isArray(name)) {
	            for (var i = 0; i < name.length; ++i) {
	                this.add(name[i]);
	            }

	            return this;
	        }

	        // if an object is passed instead of params
	        if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	            cb = url || name.callback || name.onComplete;
	            options = name;
	            url = name.url;
	            name = name.name || name.key || name.url;
	        }

	        // case where no name is passed shift all args over by one.
	        if (typeof url !== 'string') {
	            cb = options;
	            options = url;
	            url = name;
	        }

	        // now that we shifted make sure we have a proper url.
	        if (typeof url !== 'string') {
	            throw new Error('No url passed to add resource to loader.');
	        }

	        // options are optional so people might pass a function and no options
	        if (typeof options === 'function') {
	            cb = options;
	            options = null;
	        }

	        // if loading already you can only add resources that have a parent.
	        if (this.loading && (!options || !options.parentResource)) {
	            throw new Error('Cannot add resources while the loader is running.');
	        }

	        // check if resource already exists.
	        if (this.resources[name]) {
	            throw new Error('Resource named "' + name + '" already exists.');
	        }

	        // add base url if this isn't an absolute url
	        url = this._prepareUrl(url);

	        // create the store the resource
	        this.resources[name] = new _Resource2.default(name, url, options);

	        if (typeof cb === 'function') {
	            this.resources[name].onAfterMiddleware.once(cb);
	        }

	        // if actively loading, make sure to adjust progress chunks for that parent and its children
	        if (this.loading) {
	            var parent = options.parentResource;
	            var incompleteChildren = [];

	            for (var _i = 0; _i < parent.children.length; ++_i) {
	                if (!parent.children[_i].isComplete) {
	                    incompleteChildren.push(parent.children[_i]);
	                }
	            }

	            var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent
	            var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child

	            parent.children.push(this.resources[name]);
	            parent.progressChunk = eachChunk;

	            for (var _i2 = 0; _i2 < incompleteChildren.length; ++_i2) {
	                incompleteChildren[_i2].progressChunk = eachChunk;
	            }

	            this.resources[name].progressChunk = eachChunk;
	        }

	        // add the resource to the queue
	        this._queue.push(this.resources[name]);

	        return this;
	    };

	    /**
	     * Sets up a middleware function that will run *before* the
	     * resource is loaded.
	     *
	     * @method before
	     * @param {function} fn - The middleware function to register.
	     * @return {Loader} Returns itself.
	     */

	    Loader.prototype.pre = function pre(fn) {
	        this._beforeMiddleware.push(fn);

	        return this;
	    };

	    /**
	     * Sets up a middleware function that will run *after* the
	     * resource is loaded.
	     *
	     * @alias use
	     * @method after
	     * @param {function} fn - The middleware function to register.
	     * @return {Loader} Returns itself.
	     */

	    Loader.prototype.use = function use(fn) {
	        this._afterMiddleware.push(fn);

	        return this;
	    };

	    /**
	     * Resets the queue of the loader to prepare for a new load.
	     *
	     * @return {Loader} Returns itself.
	     */

	    Loader.prototype.reset = function reset() {
	        this.progress = 0;
	        this.loading = false;

	        this._queue.kill();
	        this._queue.pause();

	        // abort all resource loads
	        for (var k in this.resources) {
	            var res = this.resources[k];

	            if (res._onLoadBinding) {
	                res._onLoadBinding.detach();
	            }

	            if (res.isLoading) {
	                res.abort();
	            }
	        }

	        this.resources = {};

	        return this;
	    };

	    /**
	     * Starts loading the queued resources.
	     *
	     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.
	     * @return {Loader} Returns itself.
	     */

	    Loader.prototype.load = function load(cb) {
	        // register complete callback if they pass one
	        if (typeof cb === 'function') {
	            this.onComplete.once(cb);
	        }

	        // if the queue has already started we are done here
	        if (this.loading) {
	            return this;
	        }

	        // distribute progress chunks
	        var chunk = 100 / this._queue._tasks.length;

	        for (var i = 0; i < this._queue._tasks.length; ++i) {
	            this._queue._tasks[i].data.progressChunk = chunk;
	        }

	        // update loading state
	        this.loading = true;

	        // notify of start
	        this.onStart.dispatch(this);

	        // start loading
	        this._queue.resume();

	        return this;
	    };

	    /**
	     * Prepares a url for usage based on the configuration of this object
	     *
	     * @private
	     * @param {string} url - The url to prepare.
	     * @return {string} The prepared url.
	     */

	    Loader.prototype._prepareUrl = function _prepareUrl(url) {
	        var parsedUrl = (0, _parseUri2.default)(url, { strictMode: true });
	        var result = void 0;

	        // absolute url, just use it as is.
	        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {
	            result = url;
	        }
	        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
	        else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {
	                result = this.baseUrl + '/' + url;
	            } else {
	                result = this.baseUrl + url;
	            }

	        // if we need to add a default querystring, there is a bit more work
	        if (this.defaultQueryString) {
	            var hash = rgxExtractUrlHash.exec(result)[0];

	            result = result.substr(0, result.length - hash.length);

	            if (result.indexOf('?') !== -1) {
	                result += '&' + this.defaultQueryString;
	            } else {
	                result += '?' + this.defaultQueryString;
	            }

	            result += hash;
	        }

	        return result;
	    };

	    /**
	     * Loads a single resource.
	     *
	     * @private
	     * @param {Resource} resource - The resource to load.
	     * @param {function} dequeue - The function to call when we need to dequeue this item.
	     */

	    Loader.prototype._loadResource = function _loadResource(resource, dequeue) {
	        var _this2 = this;

	        resource._dequeue = dequeue;

	        // run before middleware
	        async.eachSeries(this._beforeMiddleware, function (fn, next) {
	            fn.call(_this2, resource, function () {
	                // if the before middleware marks the resource as complete,
	                // break and don't process any more before middleware
	                next(resource.isComplete ? {} : null);
	            });
	        }, function () {
	            if (resource.isComplete) {
	                _this2._onLoad(resource);
	            } else {
	                resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
	                resource.load();
	            }
	        });
	    };

	    /**
	     * Called once each resource has loaded.
	     *
	     * @private
	     */

	    Loader.prototype._onComplete = function _onComplete() {
	        this.loading = false;

	        this.onComplete.dispatch(this, this.resources);
	    };

	    /**
	     * Called each time a resources is loaded.
	     *
	     * @private
	     * @param {Resource} resource - The resource that was loaded
	     */

	    Loader.prototype._onLoad = function _onLoad(resource) {
	        var _this3 = this;

	        resource._onLoadBinding = null;

	        // remove this resource from the async queue, and add it to our list of resources that are being parsed
	        resource._dequeue();
	        this._resourcesParsing.push(resource);

	        // run middleware, this *must* happen before dequeue so sub-assets get added properly
	        async.eachSeries(this._afterMiddleware, function (fn, next) {
	            fn.call(_this3, resource, next);
	        }, function () {
	            resource.onAfterMiddleware.dispatch(resource);

	            _this3.progress += resource.progressChunk;
	            _this3.onProgress.dispatch(_this3, resource);

	            if (resource.error) {
	                _this3.onError.dispatch(resource.error, _this3, resource);
	            } else {
	                _this3.onLoad.dispatch(_this3, resource);
	            }

	            _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);

	            // do completion check
	            if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
	                _this3.progress = MAX_PROGRESS;
	                _this3._onComplete();
	            }
	        });
	    };

	    return Loader;
	}();

	exports.default = Loader;
	//# sourceMappingURL=Loader.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	var MiniSignalBinding = function () {
	  function MiniSignalBinding(fn, once, thisArg) {
	    if (once === undefined) once = false;

	    _classCallCheck(this, MiniSignalBinding);

	    this._fn = fn;
	    this._once = once;
	    this._thisArg = thisArg;
	    this._next = this._prev = this._owner = null;
	  }

	  _createClass(MiniSignalBinding, [{
	    key: 'detach',
	    value: function detach() {
	      if (this._owner === null) return false;
	      this._owner.detach(this);
	      return true;
	    }
	  }]);

	  return MiniSignalBinding;
	}();

	function _addMiniSignalBinding(self, node) {
	  if (!self._head) {
	    self._head = node;
	    self._tail = node;
	  } else {
	    self._tail._next = node;
	    node._prev = self._tail;
	    self._tail = node;
	  }

	  node._owner = self;

	  return node;
	}

	var MiniSignal = function () {
	  function MiniSignal() {
	    _classCallCheck(this, MiniSignal);

	    this._head = this._tail = undefined;
	  }

	  _createClass(MiniSignal, [{
	    key: 'handlers',
	    value: function handlers() {
	      var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

	      var node = this._head;

	      if (exists) return !!node;

	      var ee = [];

	      while (node) {
	        ee.push(node);
	        node = node._next;
	      }

	      return ee;
	    }
	  }, {
	    key: 'has',
	    value: function has(node) {
	      if (!(node instanceof MiniSignalBinding)) {
	        throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');
	      }

	      return node._owner === this;
	    }
	  }, {
	    key: 'dispatch',
	    value: function dispatch() {
	      var node = this._head;

	      if (!node) return false;

	      while (node) {
	        if (node._once) this.detach(node);
	        node._fn.apply(node._thisArg, arguments);
	        node = node._next;
	      }

	      return true;
	    }
	  }, {
	    key: 'add',
	    value: function add(fn) {
	      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	      if (typeof fn !== 'function') {
	        throw new Error('MiniSignal#add(): First arg must be a Function.');
	      }
	      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
	    }
	  }, {
	    key: 'once',
	    value: function once(fn) {
	      var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	      if (typeof fn !== 'function') {
	        throw new Error('MiniSignal#once(): First arg must be a Function.');
	      }
	      return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
	    }
	  }, {
	    key: 'detach',
	    value: function detach(node) {
	      if (!(node instanceof MiniSignalBinding)) {
	        throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');
	      }
	      if (node._owner !== this) return this;

	      if (node._prev) node._prev._next = node._next;
	      if (node._next) node._next._prev = node._prev;

	      if (node === this._head) {
	        this._head = node._next;
	        if (node._next === null) {
	          this._tail = null;
	        }
	      } else if (node === this._tail) {
	        this._tail = node._prev;
	        this._tail._next = null;
	      }

	      node._owner = null;
	      return this;
	    }
	  }, {
	    key: 'detachAll',
	    value: function detachAll() {
	      var node = this._head;
	      if (!node) return this;

	      this._head = this._tail = null;

	      while (node) {
	        node._owner = null;
	        node = node._next;
	      }
	      return this;
	    }
	  }]);

	  return MiniSignal;
	}();

	MiniSignal.MiniSignalBinding = MiniSignalBinding;

	exports['default'] = MiniSignal;
	module.exports = exports['default'];

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function parseURI(str, opts) {
	  opts = opts || {};

	  var o = {
	    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
	    q: {
	      name: 'queryKey',
	      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	    },
	    parser: {
	      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
	      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	    }
	  };

	  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str);
	  var uri = {};
	  var i = 14;

	  while (i--) {
	    uri[o.key[i]] = m[i] || '';
	  }uri[o.q.name] = {};
	  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
	    if ($1) uri[o.q.name][$1] = $2;
	  });

	  return uri;
	};

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.eachSeries = eachSeries;
	exports.queue = queue;
	/**
	 * Smaller version of the async library constructs.
	 *
	 */
	function _noop() {} /* empty */

	/**
	 * Iterates an array in series.
	 *
	 * @param {Array.<*>} array - Array to iterate.
	 * @param {function} iterator - Function to call for each element.
	 * @param {function} callback - Function to call when done, or on error.
	 */
	function eachSeries(array, iterator, callback) {
	    var i = 0;
	    var len = array.length;

	    (function next(err) {
	        if (err || i === len) {
	            if (callback) {
	                callback(err);
	            }

	            return;
	        }

	        iterator(array[i++], next);
	    })();
	}

	/**
	 * Ensures a function is only called once.
	 *
	 * @param {function} fn - The function to wrap.
	 * @return {function} The wrapping function.
	 */
	function onlyOnce(fn) {
	    return function onceWrapper() {
	        if (fn === null) {
	            throw new Error('Callback was already called.');
	        }

	        var callFn = fn;

	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}

	/**
	 * Async queue implementation,
	 *
	 * @param {function} worker - The worker function to call for each task.
	 * @param {number} concurrency - How many workers to run in parrallel.
	 * @return {*} The async queue object.
	 */
	function queue(worker, concurrency) {
	    if (concurrency == null) {
	        // eslint-disable-line no-eq-null,eqeqeq
	        concurrency = 1;
	    } else if (concurrency === 0) {
	        throw new Error('Concurrency must not be zero');
	    }

	    var workers = 0;
	    var q = {
	        _tasks: [],
	        concurrency: concurrency,
	        saturated: _noop,
	        unsaturated: _noop,
	        buffer: concurrency / 4,
	        empty: _noop,
	        drain: _noop,
	        error: _noop,
	        started: false,
	        paused: false,
	        push: function push(data, callback) {
	            _insert(data, false, callback);
	        },
	        kill: function kill() {
	            workers = 0;
	            q.drain = _noop;
	            q.started = false;
	            q._tasks = [];
	        },
	        unshift: function unshift(data, callback) {
	            _insert(data, true, callback);
	        },
	        process: function process() {
	            while (!q.paused && workers < q.concurrency && q._tasks.length) {
	                var task = q._tasks.shift();

	                if (q._tasks.length === 0) {
	                    q.empty();
	                }

	                workers += 1;

	                if (workers === q.concurrency) {
	                    q.saturated();
	                }

	                worker(task.data, onlyOnce(_next(task)));
	            }
	        },
	        length: function length() {
	            return q._tasks.length;
	        },
	        running: function running() {
	            return workers;
	        },
	        idle: function idle() {
	            return q._tasks.length + workers === 0;
	        },
	        pause: function pause() {
	            if (q.paused === true) {
	                return;
	            }

	            q.paused = true;
	        },
	        resume: function resume() {
	            if (q.paused === false) {
	                return;
	            }

	            q.paused = false;

	            // Need to call q.process once per concurrent
	            // worker to preserve full concurrency after pause
	            for (var w = 1; w <= q.concurrency; w++) {
	                q.process();
	            }
	        }
	    };

	    function _insert(data, insertAtFront, callback) {
	        if (callback != null && typeof callback !== 'function') {
	            // eslint-disable-line no-eq-null,eqeqeq
	            throw new Error('task callback must be a function');
	        }

	        q.started = true;

	        if (data == null && q.idle()) {
	            // eslint-disable-line no-eq-null,eqeqeq
	            // call drain immediately if there are no tasks
	            setTimeout(function () {
	                return q.drain();
	            }, 1);

	            return;
	        }

	        var item = {
	            data: data,
	            callback: typeof callback === 'function' ? callback : _noop
	        };

	        if (insertAtFront) {
	            q._tasks.unshift(item);
	        } else {
	            q._tasks.push(item);
	        }

	        setTimeout(function () {
	            return q.process();
	        }, 1);
	    }

	    function _next(task) {
	        return function next() {
	            workers -= 1;

	            task.callback.apply(task, arguments);

	            if (arguments[0] != null) {
	                // eslint-disable-line no-eq-null,eqeqeq
	                q.error(arguments[0], task.data);
	            }

	            if (workers <= q.concurrency - q.buffer) {
	                q.unsaturated();
	            }

	            if (q.idle()) {
	                q.drain();
	            }

	            q.process();
	        };
	    }

	    return q;
	}
	//# sourceMappingURL=async.js.map

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();

	var _parseUri = __webpack_require__(134);

	var _parseUri2 = _interopRequireDefault(_parseUri);

	var _miniSignals = __webpack_require__(133);

	var _miniSignals2 = _interopRequireDefault(_miniSignals);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	// tests is CORS is supported in XHR, if not we need to use XDR
	var useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));
	var tempAnchor = null;

	// some status constants
	var STATUS_NONE = 0;
	var STATUS_OK = 200;
	var STATUS_EMPTY = 204;
	var STATUS_IE_BUG_EMPTY = 1223;
	var STATUS_TYPE_OK = 2;

	// noop
	function _noop() {} /* empty */

	/**
	 * Manages the state and loading of a resource and all child resources.
	 *
	 * @class
	 */

	var Resource = function () {
	    /**
	     * Sets the load type to be used for a specific extension.
	     *
	     * @static
	     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
	     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
	     */
	    Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
	        setExtMap(Resource._loadTypeMap, extname, loadType);
	    };

	    /**
	     * Sets the load type to be used for a specific extension.
	     *
	     * @static
	     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
	     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
	     */

	    Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
	        setExtMap(Resource._xhrTypeMap, extname, xhrType);
	    };

	    /**
	     * @param {string} name - The name of the resource to load.
	     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
	     *      an array of sources.
	     * @param {object} [options] - The options for the load.
	     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
	     *      determine automatically.
	     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource
	     *      be loaded?
	     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
	     *      should the data being loaded be interpreted when using XHR?
	     * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.
	     * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The
	     *      element to use for loading, instead of creating one.
	     * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This
	     *      is useful if you want to pass in a `loadElement` that you already added load sources to.
	     */

	    function Resource(name, url, options) {
	        _classCallCheck(this, Resource);

	        if (typeof name !== 'string' || typeof url !== 'string') {
	            throw new Error('Both name and url are required for constructing a resource.');
	        }

	        options = options || {};

	        /**
	         * The state flags of this resource.
	         *
	         * @member {number}
	         */
	        this._flags = 0;

	        // set data url flag, needs to be set early for some _determineX checks to work.
	        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);

	        /**
	         * The name of this resource.
	         *
	         * @member {string}
	         * @readonly
	         */
	        this.name = name;

	        /**
	         * The url used to load this resource.
	         *
	         * @member {string}
	         * @readonly
	         */
	        this.url = url;

	        /**
	         * The extension used to load this resource.
	         *
	         * @member {string}
	         * @readonly
	         */
	        this.extension = this._getExtension();

	        /**
	         * The data that was loaded by the resource.
	         *
	         * @member {any}
	         */
	        this.data = null;

	        /**
	         * Is this request cross-origin? If unset, determined automatically.
	         *
	         * @member {string}
	         */
	        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;

	        /**
	         * The method of loading to use for this resource.
	         *
	         * @member {Resource.LOAD_TYPE}
	         */
	        this.loadType = options.loadType || this._determineLoadType();

	        /**
	         * The type used to load the resource via XHR. If unset, determined automatically.
	         *
	         * @member {string}
	         */
	        this.xhrType = options.xhrType;

	        /**
	         * Extra info for middleware, and controlling specifics about how the resource loads.
	         *
	         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
	         * Meaning it will modify it as it sees fit.
	         *
	         * @member {object}
	         * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
	         *  element to use for loading, instead of creating one.
	         * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
	         *  is useful if you want to pass in a `loadElement` that you already added load sources
	         *  to.
	         */
	        this.metadata = options.metadata || {};

	        /**
	         * The error that occurred while loading (if any).
	         *
	         * @member {Error}
	         * @readonly
	         */
	        this.error = null;

	        /**
	         * The XHR object that was used to load this resource. This is only set
	         * when `loadType` is `Resource.LOAD_TYPE.XHR`.
	         *
	         * @member {XMLHttpRequest}
	         * @readonly
	         */
	        this.xhr = null;

	        /**
	         * The child resources this resource owns.
	         *
	         * @member {Resource[]}
	         * @readonly
	         */
	        this.children = [];

	        /**
	         * The resource type.
	         *
	         * @member {Resource.TYPE}
	         * @readonly
	         */
	        this.type = Resource.TYPE.UNKNOWN;

	        /**
	         * The progress chunk owned by this resource.
	         *
	         * @member {number}
	         * @readonly
	         */
	        this.progressChunk = 0;

	        /**
	         * The `dequeue` method that will be used a storage place for the async queue dequeue method
	         * used privately by the loader.
	         *
	         * @private
	         * @member {function}
	         */
	        this._dequeue = _noop;

	        /**
	         * Used a storage place for the on load binding used privately by the loader.
	         *
	         * @private
	         * @member {function}
	         */
	        this._onLoadBinding = null;

	        /**
	         * The `complete` function bound to this resource's context.
	         *
	         * @private
	         * @member {function}
	         */
	        this._boundComplete = this.complete.bind(this);

	        /**
	         * The `_onError` function bound to this resource's context.
	         *
	         * @private
	         * @member {function}
	         */
	        this._boundOnError = this._onError.bind(this);

	        /**
	         * The `_onProgress` function bound to this resource's context.
	         *
	         * @private
	         * @member {function}
	         */
	        this._boundOnProgress = this._onProgress.bind(this);

	        // xhr callbacks
	        this._boundXhrOnError = this._xhrOnError.bind(this);
	        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
	        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
	        this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);

	        /**
	         * Dispatched when the resource beings to load.
	         *
	         * The callback looks like {@link Resource.OnStartSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onStart = new _miniSignals2.default();

	        /**
	         * Dispatched each time progress of this resource load updates.
	         * Not all resources types and loader systems can support this event
	         * so sometimes it may not be available. If the resource
	         * is being loaded on a modern browser, using XHR, and the remote server
	         * properly sets Content-Length headers, then this will be available.
	         *
	         * The callback looks like {@link Resource.OnProgressSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onProgress = new _miniSignals2.default();

	        /**
	         * Dispatched once this resource has loaded, if there was an error it will
	         * be in the `error` property.
	         *
	         * The callback looks like {@link Resource.OnCompleteSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onComplete = new _miniSignals2.default();

	        /**
	         * Dispatched after this resource has had all the *after* middleware run on it.
	         *
	         * The callback looks like {@link Resource.OnCompleteSignal}.
	         *
	         * @member {Signal}
	         */
	        this.onAfterMiddleware = new _miniSignals2.default();

	        /**
	         * When the resource starts to load.
	         *
	         * @memberof Resource
	         * @callback OnStartSignal
	         * @param {Resource} resource - The resource that the event happened on.
	         */

	        /**
	         * When the resource reports loading progress.
	         *
	         * @memberof Resource
	         * @callback OnProgressSignal
	         * @param {Resource} resource - The resource that the event happened on.
	         * @param {number} percentage - The progress of the load in the range [0, 1].
	         */

	        /**
	         * When the resource finishes loading.
	         *
	         * @memberof Resource
	         * @callback OnCompleteSignal
	         * @param {Resource} resource - The resource that the event happened on.
	         */
	    }

	    /**
	     * Stores whether or not this url is a data url.
	     *
	     * @member {boolean}
	     * @readonly
	     */

	    /**
	     * Marks the resource as complete.
	     *
	     */
	    Resource.prototype.complete = function complete() {
	        // TODO: Clean this up in a wrapper or something...gross....
	        if (this.data && this.data.removeEventListener) {
	            this.data.removeEventListener('error', this._boundOnError, false);
	            this.data.removeEventListener('load', this._boundComplete, false);
	            this.data.removeEventListener('progress', this._boundOnProgress, false);
	            this.data.removeEventListener('canplaythrough', this._boundComplete, false);
	        }

	        if (this.xhr) {
	            if (this.xhr.removeEventListener) {
	                this.xhr.removeEventListener('error', this._boundXhrOnError, false);
	                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
	                this.xhr.removeEventListener('progress', this._boundOnProgress, false);
	                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
	            } else {
	                this.xhr.onerror = null;
	                this.xhr.ontimeout = null;
	                this.xhr.onprogress = null;
	                this.xhr.onload = null;
	            }
	        }

	        if (this.isComplete) {
	            throw new Error('Complete called again for an already completed resource.');
	        }

	        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);
	        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);

	        this.onComplete.dispatch(this);
	    };

	    /**
	     * Aborts the loading of this resource, with an optional message.
	     *
	     * @param {string} message - The message to use for the error
	     */

	    Resource.prototype.abort = function abort(message) {
	        // abort can be called multiple times, ignore subsequent calls.
	        if (this.error) {
	            return;
	        }

	        // store error
	        this.error = new Error(message);

	        // abort the actual loading
	        if (this.xhr) {
	            this.xhr.abort();
	        } else if (this.xdr) {
	            this.xdr.abort();
	        } else if (this.data) {
	            // single source
	            if (this.data.src) {
	                this.data.src = Resource.EMPTY_GIF;
	            }
	            // multi-source
	            else {
	                    while (this.data.firstChild) {
	                        this.data.removeChild(this.data.firstChild);
	                    }
	                }
	        }

	        // done now.
	        this.complete();
	    };

	    /**
	     * Kicks off loading of this resource. This method is asynchronous.
	     *
	     * @param {function} [cb] - Optional callback to call once the resource is loaded.
	     */

	    Resource.prototype.load = function load(cb) {
	        var _this = this;

	        if (this.isLoading) {
	            return;
	        }

	        if (this.isComplete) {
	            if (cb) {
	                setTimeout(function () {
	                    return cb(_this);
	                }, 1);
	            }

	            return;
	        } else if (cb) {
	            this.onComplete.once(cb);
	        }

	        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);

	        this.onStart.dispatch(this);

	        // if unset, determine the value
	        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
	            this.crossOrigin = this._determineCrossOrigin(this.url);
	        }

	        switch (this.loadType) {
	            case Resource.LOAD_TYPE.IMAGE:
	                this.type = Resource.TYPE.IMAGE;
	                this._loadElement('image');
	                break;

	            case Resource.LOAD_TYPE.AUDIO:
	                this.type = Resource.TYPE.AUDIO;
	                this._loadSourceElement('audio');
	                break;

	            case Resource.LOAD_TYPE.VIDEO:
	                this.type = Resource.TYPE.VIDEO;
	                this._loadSourceElement('video');
	                break;

	            case Resource.LOAD_TYPE.XHR:
	            /* falls through */
	            default:
	                if (useXdr && this.crossOrigin) {
	                    this._loadXdr();
	                } else {
	                    this._loadXhr();
	                }
	                break;
	        }
	    };

	    /**
	     * Checks if the flag is set.
	     *
	     * @private
	     * @param {number} flag - The flag to check.
	     * @return {boolean} True if the flag is set.
	     */

	    Resource.prototype._hasFlag = function _hasFlag(flag) {
	        return !!(this._flags & flag);
	    };

	    /**
	     * (Un)Sets the flag.
	     *
	     * @private
	     * @param {number} flag - The flag to (un)set.
	     * @param {boolean} value - Whether to set or (un)set the flag.
	     */

	    Resource.prototype._setFlag = function _setFlag(flag, value) {
	        this._flags = value ? this._flags | flag : this._flags & ~flag;
	    };

	    /**
	     * Loads this resources using an element that has a single source,
	     * like an HTMLImageElement.
	     *
	     * @private
	     * @param {string} type - The type of element to use.
	     */

	    Resource.prototype._loadElement = function _loadElement(type) {
	        if (this.metadata.loadElement) {
	            this.data = this.metadata.loadElement;
	        } else if (type === 'image' && typeof window.Image !== 'undefined') {
	            this.data = new Image();
	        } else {
	            this.data = document.createElement(type);
	        }

	        if (this.crossOrigin) {
	            this.data.crossOrigin = this.crossOrigin;
	        }

	        if (!this.metadata.skipSource) {
	            this.data.src = this.url;
	        }

	        this.data.addEventListener('error', this._boundOnError, false);
	        this.data.addEventListener('load', this._boundComplete, false);
	        this.data.addEventListener('progress', this._boundOnProgress, false);
	    };

	    /**
	     * Loads this resources using an element that has multiple sources,
	     * like an HTMLAudioElement or HTMLVideoElement.
	     *
	     * @private
	     * @param {string} type - The type of element to use.
	     */

	    Resource.prototype._loadSourceElement = function _loadSourceElement(type) {
	        if (this.metadata.loadElement) {
	            this.data = this.metadata.loadElement;
	        } else if (type === 'audio' && typeof window.Audio !== 'undefined') {
	            this.data = new Audio();
	        } else {
	            this.data = document.createElement(type);
	        }

	        if (this.data === null) {
	            this.abort('Unsupported element: ' + type);

	            return;
	        }

	        if (!this.metadata.skipSource) {
	            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
	            if (navigator.isCocoonJS) {
	                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
	            } else if (Array.isArray(this.url)) {
	                for (var i = 0; i < this.url.length; ++i) {
	                    this.data.appendChild(this._createSource(type, this.url[i]));
	                }
	            } else {
	                this.data.appendChild(this._createSource(type, this.url));
	            }
	        }

	        this.data.addEventListener('error', this._boundOnError, false);
	        this.data.addEventListener('load', this._boundComplete, false);
	        this.data.addEventListener('progress', this._boundOnProgress, false);
	        this.data.addEventListener('canplaythrough', this._boundComplete, false);

	        this.data.load();
	    };

	    /**
	     * Loads this resources using an XMLHttpRequest.
	     *
	     * @private
	     */

	    Resource.prototype._loadXhr = function _loadXhr() {
	        // if unset, determine the value
	        if (typeof this.xhrType !== 'string') {
	            this.xhrType = this._determineXhrType();
	        }

	        var xhr = this.xhr = new XMLHttpRequest();

	        // set the request type and url
	        xhr.open('GET', this.url, true);

	        // load json as text and parse it ourselves. We do this because some browsers
	        // *cough* safari *cough* can't deal with it.
	        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
	            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
	        } else {
	            xhr.responseType = this.xhrType;
	        }

	        xhr.addEventListener('error', this._boundXhrOnError, false);
	        xhr.addEventListener('abort', this._boundXhrOnAbort, false);
	        xhr.addEventListener('progress', this._boundOnProgress, false);
	        xhr.addEventListener('load', this._boundXhrOnLoad, false);

	        xhr.send();
	    };

	    /**
	     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
	     *
	     * @private
	     */

	    Resource.prototype._loadXdr = function _loadXdr() {
	        // if unset, determine the value
	        if (typeof this.xhrType !== 'string') {
	            this.xhrType = this._determineXhrType();
	        }

	        var xdr = this.xhr = new XDomainRequest();

	        // XDomainRequest has a few quirks. Occasionally it will abort requests
	        // A way to avoid this is to make sure ALL callbacks are set even if not used
	        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
	        xdr.timeout = 5000;

	        xdr.onerror = this._boundXhrOnError;
	        xdr.ontimeout = this._boundXdrOnTimeout;
	        xdr.onprogress = this._boundOnProgress;
	        xdr.onload = this._boundXhrOnLoad;

	        xdr.open('GET', this.url, true);

	        // Note: The xdr.send() call is wrapped in a timeout to prevent an
	        // issue with the interface where some requests are lost if multiple
	        // XDomainRequests are being sent at the same time.
	        // Some info here: https://github.com/photonstorm/phaser/issues/1248
	        setTimeout(function () {
	            return xdr.send();
	        }, 1);
	    };

	    /**
	     * Creates a source used in loading via an element.
	     *
	     * @private
	     * @param {string} type - The element type (video or audio).
	     * @param {string} url - The source URL to load from.
	     * @param {string} [mime] - The mime type of the video
	     * @return {HTMLSourceElement} The source element.
	     */

	    Resource.prototype._createSource = function _createSource(type, url, mime) {
	        if (!mime) {
	            mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
	        }

	        var source = document.createElement('source');

	        source.src = url;
	        source.type = mime;

	        return source;
	    };

	    /**
	     * Called if a load errors out.
	     *
	     * @param {Event} event - The error event from the element that emits it.
	     * @private
	     */

	    Resource.prototype._onError = function _onError(event) {
	        this.abort('Failed to load element using: ' + event.target.nodeName);
	    };

	    /**
	     * Called if a load progress event fires for xhr/xdr.
	     *
	     * @private
	     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
	     */

	    Resource.prototype._onProgress = function _onProgress(event) {
	        if (event && event.lengthComputable) {
	            this.onProgress.dispatch(this, event.loaded / event.total);
	        }
	    };

	    /**
	     * Called if an error event fires for xhr/xdr.
	     *
	     * @private
	     * @param {XMLHttpRequestErrorEvent|Event} event - Error event.
	     */

	    Resource.prototype._xhrOnError = function _xhrOnError() {
	        var xhr = this.xhr;

	        this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
	    };

	    /**
	     * Called if an abort event fires for xhr.
	     *
	     * @private
	     * @param {XMLHttpRequestAbortEvent} event - Abort Event
	     */

	    Resource.prototype._xhrOnAbort = function _xhrOnAbort() {
	        this.abort(reqType(this.xhr) + ' Request was aborted by the user.');
	    };

	    /**
	     * Called if a timeout event fires for xdr.
	     *
	     * @private
	     * @param {Event} event - Timeout event.
	     */

	    Resource.prototype._xdrOnTimeout = function _xdrOnTimeout() {
	        this.abort(reqType(this.xhr) + ' Request timed out.');
	    };

	    /**
	     * Called when data successfully loads from an xhr/xdr request.
	     *
	     * @private
	     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
	     */

	    Resource.prototype._xhrOnLoad = function _xhrOnLoad() {
	        var xhr = this.xhr;
	        var text = '';
	        var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.

	        // responseText is accessible only if responseType is '' or 'text' and on older browsers
	        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
	            text = xhr.responseText;
	        }

	        // status can be 0 when using the `file://` protocol so we also check if a response is set.
	        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
	        if (status === STATUS_NONE && text.length > 0) {
	            status = STATUS_OK;
	        }
	        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	        else if (status === STATUS_IE_BUG_EMPTY) {
	                status = STATUS_EMPTY;
	            }

	        var statusType = status / 100 | 0;

	        if (statusType === STATUS_TYPE_OK) {
	            // if text, just return it
	            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
	                this.data = text;
	                this.type = Resource.TYPE.TEXT;
	            }
	            // if json, parse into json object
	            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
	                    try {
	                        this.data = JSON.parse(text);
	                        this.type = Resource.TYPE.JSON;
	                    } catch (e) {
	                        this.abort('Error trying to parse loaded json: ' + e);

	                        return;
	                    }
	                }
	                // if xml, parse into an xml document or div element
	                else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
	                        try {
	                            if (window.DOMParser) {
	                                var domparser = new DOMParser();

	                                this.data = domparser.parseFromString(text, 'text/xml');
	                            } else {
	                                var div = document.createElement('div');

	                                div.innerHTML = text;

	                                this.data = div;
	                            }

	                            this.type = Resource.TYPE.XML;
	                        } catch (e) {
	                            this.abort('Error trying to parse loaded xml: ' + e);

	                            return;
	                        }
	                    }
	                    // other types just return the response
	                    else {
	                            this.data = xhr.response || text;
	                        }
	        } else {
	            this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);

	            return;
	        }

	        this.complete();
	    };

	    /**
	     * Sets the `crossOrigin` property for this resource based on if the url
	     * for this resource is cross-origin. If crossOrigin was manually set, this
	     * function does nothing.
	     *
	     * @private
	     * @param {string} url - The url to test.
	     * @param {object} [loc=window.location] - The location object to test against.
	     * @return {string} The crossOrigin value to use (or empty string for none).
	     */

	    Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
	        // data: and javascript: urls are considered same-origin
	        if (url.indexOf('data:') === 0) {
	            return '';
	        }

	        // default is window.location
	        loc = loc || window.location;

	        if (!tempAnchor) {
	            tempAnchor = document.createElement('a');
	        }

	        // let the browser determine the full href for the url of this resource and then
	        // parse with the node url lib, we can't use the properties of the anchor element
	        // because they don't work in IE9 :(
	        tempAnchor.href = url;
	        url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: true });

	        var samePort = !url.port && loc.port === '' || url.port === loc.port;
	        var protocol = url.protocol ? url.protocol + ':' : '';

	        // if cross origin
	        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
	            return 'anonymous';
	        }

	        return '';
	    };

	    /**
	     * Determines the responseType of an XHR request based on the extension of the
	     * resource being loaded.
	     *
	     * @private
	     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
	     */

	    Resource.prototype._determineXhrType = function _determineXhrType() {
	        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;
	    };

	    /**
	     * Determines the loadType of a resource based on the extension of the
	     * resource being loaded.
	     *
	     * @private
	     * @return {Resource.LOAD_TYPE} The loadType to use.
	     */

	    Resource.prototype._determineLoadType = function _determineLoadType() {
	        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;
	    };

	    /**
	     * Extracts the extension (sans '.') of the file being loaded by the resource.
	     *
	     * @private
	     * @return {string} The extension.
	     */

	    Resource.prototype._getExtension = function _getExtension() {
	        var url = this.url;
	        var ext = '';

	        if (this.isDataUrl) {
	            var slashIndex = url.indexOf('/');

	            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
	        } else {
	            var queryStart = url.indexOf('?');

	            if (queryStart !== -1) {
	                url = url.substring(0, queryStart);
	            }

	            ext = url.substring(url.lastIndexOf('.') + 1);
	        }

	        return ext.toLowerCase();
	    };

	    /**
	     * Determines the mime type of an XHR request based on the responseType of
	     * resource being loaded.
	     *
	     * @private
	     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
	     * @return {string} The mime type to use.
	     */

	    Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {
	        switch (type) {
	            case Resource.XHR_RESPONSE_TYPE.BUFFER:
	                return 'application/octet-binary';

	            case Resource.XHR_RESPONSE_TYPE.BLOB:
	                return 'application/blob';

	            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
	                return 'application/xml';

	            case Resource.XHR_RESPONSE_TYPE.JSON:
	                return 'application/json';

	            case Resource.XHR_RESPONSE_TYPE.DEFAULT:
	            case Resource.XHR_RESPONSE_TYPE.TEXT:
	            /* falls through */
	            default:
	                return 'text/plain';

	        }
	    };

	    _createClass(Resource, [{
	        key: 'isDataUrl',
	        get: function get() {
	            return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);
	        }

	        /**
	         * Describes if this resource has finished loading. Is true when the resource has completely
	         * loaded.
	         *
	         * @member {boolean}
	         * @readonly
	         */

	    }, {
	        key: 'isComplete',
	        get: function get() {
	            return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);
	        }

	        /**
	         * Describes if this resource is currently loading. Is true when the resource starts loading,
	         * and is false again when complete.
	         *
	         * @member {boolean}
	         * @readonly
	         */

	    }, {
	        key: 'isLoading',
	        get: function get() {
	            return this._hasFlag(Resource.STATUS_FLAGS.LOADING);
	        }
	    }]);

	    return Resource;
	}();

	/**
	 * The types of resources a resource could represent.
	 *
	 * @static
	 * @readonly
	 * @enum {number}
	 */

	exports.default = Resource;
	Resource.STATUS_FLAGS = {
	    NONE: 0,
	    DATA_URL: 1 << 0,
	    COMPLETE: 1 << 1,
	    LOADING: 1 << 2
	};

	/**
	 * The types of resources a resource could represent.
	 *
	 * @static
	 * @readonly
	 * @enum {number}
	 */
	Resource.TYPE = {
	    UNKNOWN: 0,
	    JSON: 1,
	    XML: 2,
	    IMAGE: 3,
	    AUDIO: 4,
	    VIDEO: 5,
	    TEXT: 6
	};

	/**
	 * The types of loading a resource can use.
	 *
	 * @static
	 * @readonly
	 * @enum {number}
	 */
	Resource.LOAD_TYPE = {
	    /** Uses XMLHttpRequest to load the resource. */
	    XHR: 1,
	    /** Uses an `Image` object to load the resource. */
	    IMAGE: 2,
	    /** Uses an `Audio` object to load the resource. */
	    AUDIO: 3,
	    /** Uses a `Video` object to load the resource. */
	    VIDEO: 4
	};

	/**
	 * The XHR ready states, used internally.
	 *
	 * @static
	 * @readonly
	 * @enum {string}
	 */
	Resource.XHR_RESPONSE_TYPE = {
	    /** string */
	    DEFAULT: 'text',
	    /** ArrayBuffer */
	    BUFFER: 'arraybuffer',
	    /** Blob */
	    BLOB: 'blob',
	    /** Document */
	    DOCUMENT: 'document',
	    /** Object */
	    JSON: 'json',
	    /** String */
	    TEXT: 'text'
	};

	Resource._loadTypeMap = {
	    // images
	    gif: Resource.LOAD_TYPE.IMAGE,
	    png: Resource.LOAD_TYPE.IMAGE,
	    bmp: Resource.LOAD_TYPE.IMAGE,
	    jpg: Resource.LOAD_TYPE.IMAGE,
	    jpeg: Resource.LOAD_TYPE.IMAGE,
	    tif: Resource.LOAD_TYPE.IMAGE,
	    tiff: Resource.LOAD_TYPE.IMAGE,
	    webp: Resource.LOAD_TYPE.IMAGE,
	    tga: Resource.LOAD_TYPE.IMAGE,
	    svg: Resource.LOAD_TYPE.IMAGE,
	    'svg+xml': Resource.LOAD_TYPE.IMAGE, // for SVG data urls

	    // audio
	    mp3: Resource.LOAD_TYPE.AUDIO,
	    ogg: Resource.LOAD_TYPE.AUDIO,
	    wav: Resource.LOAD_TYPE.AUDIO,

	    // videos
	    mp4: Resource.LOAD_TYPE.VIDEO,
	    webm: Resource.LOAD_TYPE.VIDEO
	};

	Resource._xhrTypeMap = {
	    // xml
	    xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

	    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
	    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
	    // this should probably be fine.
	    tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,

	    // images
	    gif: Resource.XHR_RESPONSE_TYPE.BLOB,
	    png: Resource.XHR_RESPONSE_TYPE.BLOB,
	    bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
	    jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
	    jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
	    tif: Resource.XHR_RESPONSE_TYPE.BLOB,
	    tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
	    webp: Resource.XHR_RESPONSE_TYPE.BLOB,
	    tga: Resource.XHR_RESPONSE_TYPE.BLOB,

	    // json
	    json: Resource.XHR_RESPONSE_TYPE.JSON,

	    // text
	    text: Resource.XHR_RESPONSE_TYPE.TEXT,
	    txt: Resource.XHR_RESPONSE_TYPE.TEXT,

	    // fonts
	    ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
	    otf: Resource.XHR_RESPONSE_TYPE.BUFFER
	};

	// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif
	Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

	/**
	 * Quick helper to set a value on one of the extension maps. Ensures there is no
	 * dot at the start of the extension.
	 *
	 * @ignore
	 * @param {object} map - The map to set on.
	 * @param {string} extname - The extension (or key) to set.
	 * @param {number} val - The value to set.
	 */
	function setExtMap(map, extname, val) {
	    if (extname && extname.indexOf('.') === 0) {
	        extname = extname.substring(1);
	    }

	    if (!extname) {
	        return;
	    }

	    map[extname] = val;
	}

	/**
	 * Quick helper to get string xhr type.
	 *
	 * @ignore
	 * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
	 * @return {string} The type.
	 */
	function reqType(xhr) {
	    return xhr.toString().replace('object ', '');
	}
	//# sourceMappingURL=Resource.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.encodeBinary = encodeBinary;
	var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function encodeBinary(input) {
	    var output = '';
	    var inx = 0;

	    while (inx < input.length) {
	        // Fill byte buffer array
	        var bytebuffer = [0, 0, 0];
	        var encodedCharIndexes = [0, 0, 0, 0];

	        for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
	            if (inx < input.length) {
	                // throw away high-order byte, as documented at:
	                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
	                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
	            } else {
	                bytebuffer[jnx] = 0;
	            }
	        }

	        // Get each encoded character, 6 bits at a time
	        // index 1: first 6 bits
	        encodedCharIndexes[0] = bytebuffer[0] >> 2;

	        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
	        encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;

	        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
	        encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;

	        // index 3: forth 6 bits (6 least significant bits from input byte 3)
	        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

	        // Determine whether padding happened, and adjust accordingly
	        var paddingBytes = inx - (input.length - 1);

	        switch (paddingBytes) {
	            case 2:
	                // Set last 2 characters to padding char
	                encodedCharIndexes[3] = 64;
	                encodedCharIndexes[2] = 64;
	                break;

	            case 1:
	                // Set last character to padding char
	                encodedCharIndexes[3] = 64;
	                break;

	            default:
	                break; // No padding - proceed
	        }

	        // Now we will grab each appropriate character out of our keystring
	        // based on our index array and append it to the output string
	        for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
	            output += _keyStr.charAt(encodedCharIndexes[_jnx]);
	        }
	    }

	    return output;
	}
	//# sourceMappingURL=b64.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	exports.blobMiddlewareFactory = blobMiddlewareFactory;

	var _Resource = __webpack_require__(136);

	var _Resource2 = _interopRequireDefault(_Resource);

	var _b = __webpack_require__(137);

	var _b2 = _interopRequireDefault(_b);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	var Url = window.URL || window.webkitURL;

	// a middleware for transforming XHR loaded Blobs into more useful objects
	function blobMiddlewareFactory() {
	    return function blobMiddleware(resource, next) {
	        if (!resource.data) {
	            next();

	            return;
	        }

	        // if this was an XHR load of a blob
	        if (resource.xhr && resource.xhrType === _Resource2.default.XHR_RESPONSE_TYPE.BLOB) {
	            // if there is no blob support we probably got a binary string back
	            if (!window.Blob || typeof resource.data === 'string') {
	                var type = resource.xhr.getResponseHeader('content-type');

	                // this is an image, convert the binary string into a data url
	                if (type && type.indexOf('image') === 0) {
	                    resource.data = new Image();
	                    resource.data.src = 'data:' + type + ';base64,' + _b2.default.encodeBinary(resource.xhr.responseText);

	                    resource.type = _Resource2.default.TYPE.IMAGE;

	                    // wait until the image loads and then callback
	                    resource.data.onload = function () {
	                        resource.data.onload = null;

	                        next();
	                    };

	                    // next will be called on load
	                    return;
	                }
	            }
	            // if content type says this is an image, then we should transform the blob into an Image object
	            else if (resource.data.type.indexOf('image') === 0) {
	                    var _ret = function () {
	                        var src = Url.createObjectURL(resource.data);

	                        resource.blob = resource.data;
	                        resource.data = new Image();
	                        resource.data.src = src;

	                        resource.type = _Resource2.default.TYPE.IMAGE;

	                        // cleanup the no longer used blob after the image loads
	                        // TODO: Is this correct? Will the image be invalid after revoking?
	                        resource.data.onload = function () {
	                            Url.revokeObjectURL(src);
	                            resource.data.onload = null;

	                            next();
	                        };

	                        // next will be called on load.
	                        return {
	                            v: void 0
	                        };
	                    }();

	                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	                }
	        }

	        next();
	    };
	}
	//# sourceMappingURL=blob.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function () {
	  return function textureParser(resource, next) {
	    // create a new texture if the data is an Image object
	    if (resource.data && resource.type === _resourceLoader.Resource.TYPE.IMAGE) {
	      var baseTexture = new core.BaseTexture(resource.data, null, core.getResolutionOfUrl(resource.url));

	      baseTexture.imageUrl = resource.url;
	      resource.texture = new core.Texture(baseTexture);

	      // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
	      core.BaseTextureCache[resource.name] = baseTexture;
	      core.TextureCache[resource.name] = resource.texture;

	      // also add references by url if they are different.
	      if (resource.name !== resource.url) {
	        core.BaseTextureCache[resource.url] = baseTexture;
	        core.TextureCache[resource.url] = resource.texture;
	      }
	    }

	    next();
	  };
	};

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _resourceLoader = __webpack_require__(131);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function () {
	  return function spritesheetParser(resource, next) {
	    var resourcePath = void 0;
	    var imageResourceName = resource.name + '_image';

	    // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
	    if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) {
	      next();

	      return;
	    }

	    var loadOptions = {
	      crossOrigin: resource.crossOrigin,
	      loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE,
	      metadata: resource.metadata.imageMetadata,
	      parentResource: resource
	    };

	    // Prepend url path unless the resource image is a data url
	    if (resource.isDataUrl) {
	      resourcePath = resource.data.meta.image;
	    } else {
	      resourcePath = _path2.default.dirname(resource.url.replace(this.baseUrl, '')) + '/' + resource.data.meta.image;
	    }

	    // load the image for this sheet
	    this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
	      resource.textures = {};

	      var frames = resource.data.frames;
	      var frameKeys = Object.keys(frames);
	      var baseTexture = res.texture.baseTexture;
	      var scale = resource.data.meta.scale;

	      // Use a defaultValue of `null` to check if a url-based resolution is set
	      var resolution = core.getResolutionOfUrl(resource.url, null);

	      // No resolution found via URL
	      if (resolution === null) {
	        // Use the scale value or default to 1
	        resolution = scale !== undefined ? scale : 1;
	      }

	      // For non-1 resolutions, update baseTexture
	      if (resolution !== 1) {
	        baseTexture.resolution = resolution;
	        baseTexture.update();
	      }

	      var batchIndex = 0;

	      function processFrames(initialFrameIndex, maxFrames) {
	        var frameIndex = initialFrameIndex;

	        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < frameKeys.length) {
	          var i = frameKeys[frameIndex];
	          var rect = frames[i].frame;

	          if (rect) {
	            var frame = null;
	            var trim = null;
	            var orig = new core.Rectangle(0, 0, frames[i].sourceSize.w / resolution, frames[i].sourceSize.h / resolution);

	            if (frames[i].rotated) {
	              frame = new core.Rectangle(rect.x / resolution, rect.y / resolution, rect.h / resolution, rect.w / resolution);
	            } else {
	              frame = new core.Rectangle(rect.x / resolution, rect.y / resolution, rect.w / resolution, rect.h / resolution);
	            }

	            //  Check to see if the sprite is trimmed
	            if (frames[i].trimmed) {
	              trim = new core.Rectangle(frames[i].spriteSourceSize.x / resolution, frames[i].spriteSourceSize.y / resolution, rect.w / resolution, rect.h / resolution);
	            }

	            resource.textures[i] = new core.Texture(baseTexture, frame, orig, trim, frames[i].rotated ? 2 : 0);

	            // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
	            core.TextureCache[i] = resource.textures[i];
	          }

	          frameIndex++;
	        }
	      }

	      function shouldProcessNextBatch() {
	        return batchIndex * BATCH_SIZE < frameKeys.length;
	      }

	      function processNextBatch(done) {
	        processFrames(batchIndex * BATCH_SIZE, BATCH_SIZE);
	        batchIndex++;
	        setTimeout(done, 0);
	      }

	      function iteration() {
	        processNextBatch(function () {
	          if (shouldProcessNextBatch()) {
	            iteration();
	          } else {
	            next();
	          }
	        });
	      }

	      if (frameKeys.length <= BATCH_SIZE) {
	        processFrames(0, BATCH_SIZE);
	        next();
	      } else {
	        iteration();
	      }
	    });
	  };
	};

	var _resourceLoader = __webpack_require__(131);

	var _path = __webpack_require__(87);

	var _path2 = _interopRequireDefault(_path);

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var BATCH_SIZE = 1000;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;

	exports.default = function () {
	  return function bitmapFontParser(resource, next) {
	    // skip if no data or not xml data
	    if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.XML) {
	      next();

	      return;
	    }

	    // skip if not bitmap font data, using some silly duck-typing
	    if (resource.data.getElementsByTagName('page').length === 0 || resource.data.getElementsByTagName('info').length === 0 || resource.data.getElementsByTagName('info')[0].getAttribute('face') === null) {
	      next();

	      return;
	    }

	    var xmlUrl = !resource.isDataUrl ? path.dirname(resource.url) : '';

	    if (resource.isDataUrl) {
	      if (xmlUrl === '.') {
	        xmlUrl = '';
	      }

	      if (this.baseUrl && xmlUrl) {
	        // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
	        if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
	          xmlUrl += '/';
	        }

	        // remove baseUrl from xmlUrl
	        xmlUrl = xmlUrl.replace(this.baseUrl, '');
	      }
	    }

	    // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
	    if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
	      xmlUrl += '/';
	    }

	    var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');

	    if (_core.TextureCache[textureUrl]) {
	      // reuse existing texture
	      parse(resource, _core.TextureCache[textureUrl]);
	      next();
	    } else {
	      var loadOptions = {
	        crossOrigin: resource.crossOrigin,
	        loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE,
	        metadata: resource.metadata.imageMetadata,
	        parentResource: resource
	      };

	      // load the texture for the font
	      this.add(resource.name + '_image', textureUrl, loadOptions, function (res) {
	        parse(resource, res.texture);
	        next();
	      });
	    }
	  };
	};

	var _path = __webpack_require__(87);

	var path = _interopRequireWildcard(_path);

	var _core = __webpack_require__(6);

	var _resourceLoader = __webpack_require__(131);

	var _extras = __webpack_require__(142);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function parse(resource, texture) {
	  var data = {};
	  var info = resource.data.getElementsByTagName('info')[0];
	  var common = resource.data.getElementsByTagName('common')[0];

	  data.font = info.getAttribute('face');
	  data.size = parseInt(info.getAttribute('size'), 10);
	  data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
	  data.chars = {};

	  // parse letters
	  var letters = resource.data.getElementsByTagName('char');

	  for (var i = 0; i < letters.length; i++) {
	    var charCode = parseInt(letters[i].getAttribute('id'), 10);

	    var textureRect = new _core.Rectangle(parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x, parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y, parseInt(letters[i].getAttribute('width'), 10), parseInt(letters[i].getAttribute('height'), 10));

	    data.chars[charCode] = {
	      xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
	      yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
	      xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
	      kerning: {},
	      texture: new _core.Texture(texture.baseTexture, textureRect)

	    };
	  }

	  // parse kernings
	  var kernings = resource.data.getElementsByTagName('kerning');

	  for (var _i = 0; _i < kernings.length; _i++) {
	    var first = parseInt(kernings[_i].getAttribute('first'), 10);
	    var second = parseInt(kernings[_i].getAttribute('second'), 10);
	    var amount = parseInt(kernings[_i].getAttribute('amount'), 10);

	    if (data.chars[second]) {
	      data.chars[second].kerning[first] = amount;
	    }
	  }

	  resource.bitmapFont = data;

	  // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
	  // but it's very likely to change
	  _extras.BitmapText.fonts[data.font] = data;
	}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.KeyboardManager = exports.Dust = exports.BinaryLoader = exports.Layer = exports.BitmapText = exports.TilingSpriteRenderer = exports.TilingSprite = exports.TextureTransform = undefined;

	var _TextureTransform = __webpack_require__(143);

	Object.defineProperty(exports, 'TextureTransform', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TextureTransform).default;
	  }
	});

	var _TilingSprite = __webpack_require__(144);

	Object.defineProperty(exports, 'TilingSprite', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TilingSprite).default;
	  }
	});

	var _TilingSpriteRenderer = __webpack_require__(145);

	Object.defineProperty(exports, 'TilingSpriteRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TilingSpriteRenderer).default;
	  }
	});

	var _BitmapText = __webpack_require__(146);

	Object.defineProperty(exports, 'BitmapText', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BitmapText).default;
	  }
	});

	var _Layer = __webpack_require__(147);

	Object.defineProperty(exports, 'Layer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Layer).default;
	  }
	});

	var _BinaryLoader = __webpack_require__(151);

	Object.defineProperty(exports, 'BinaryLoader', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BinaryLoader).default;
	  }
	});

	var _Dust = __webpack_require__(152);

	Object.defineProperty(exports, 'Dust', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Dust).default;
	  }
	});

	var _KeyboardManager = __webpack_require__(153);

	Object.defineProperty(exports, 'KeyboardManager', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_KeyboardManager).default;
	  }
	});

	__webpack_require__(154);

	__webpack_require__(155);

	__webpack_require__(156);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// imported for side effect of extending the prototype only, contains no exports

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Matrix = __webpack_require__(11);

	var _Matrix2 = _interopRequireDefault(_Matrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var tempMat = new _Matrix2.default();

	/**
	 * class controls uv transform and frame clamp for texture
	 *
	 * @class
	 * @memberof Tiny
	 */

	var TextureTransform = function () {
	  /**
	   *
	   * @param {Tiny.Texture} texture observed texture
	   * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
	   * @constructor
	   */
	  function TextureTransform(texture, clampMargin) {
	    _classCallCheck(this, TextureTransform);

	    this._texture = texture;

	    this.mapCoord = new _Matrix2.default();

	    this.uClampFrame = new Float32Array(4);

	    this.uClampOffset = new Float32Array(2);

	    this._lastTextureID = -1;

	    /**
	     * Changes frame clamping
	     * Works with TilingSprite and Mesh
	     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
	     *
	     * @default 0
	     * @member {number}
	     */
	    this.clampOffset = 0;

	    /**
	     * Changes frame clamping
	     * Works with TilingSprite and Mesh
	     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
	     *
	     * @default 0.5
	     * @member {number}
	     */
	    this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;
	  }

	  /**
	   * texture property
	   * @member {Tiny.Texture}
	   */


	  _createClass(TextureTransform, [{
	    key: 'update',


	    /**
	     * updates matrices if texture was changed
	     * @param {boolean} forceUpdate if true, matrices will be updated any case
	     */
	    value: function update(forceUpdate) {
	      var tex = this._texture;

	      if (!tex || !tex.valid) {
	        return;
	      }

	      if (!forceUpdate && this._lastTextureID === tex._updateID) {
	        return;
	      }

	      this._lastTextureID = tex._updateID;

	      var uvs = tex._uvs;

	      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);

	      var orig = tex.orig;
	      var trim = tex.trim;

	      if (trim) {
	        tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
	        this.mapCoord.append(tempMat);
	      }

	      var texBase = tex.baseTexture;
	      var frame = this.uClampFrame;
	      var margin = this.clampMargin / texBase.resolution;
	      var offset = this.clampOffset;

	      frame[0] = (tex._frame.x + margin + offset) / texBase.width;
	      frame[1] = (tex._frame.y + margin + offset) / texBase.height;
	      frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
	      frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
	      this.uClampOffset[0] = offset / texBase.realWidth;
	      this.uClampOffset[1] = offset / texBase.realHeight;
	    }
	  }, {
	    key: 'texture',
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(value) {
	      this._texture = value;
	      this._lastTextureID = -1;
	    }
	  }]);

	  return TextureTransform;
	}();

	exports.default = TextureTransform;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _CanvasTinter = __webpack_require__(78);

	var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

	var _TextureTransform = __webpack_require__(143);

	var _TextureTransform2 = _interopRequireDefault(_TextureTransform);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var tempPoint = new core.Point();

	/**
	 * A tiling sprite is a fast way of rendering a tiling image
	 *
	 * @class
	 * @extends Tiny.Sprite
	 * @memberof Tiny
	 */

	var TilingSprite = function (_core$Sprite) {
	  _inherits(TilingSprite, _core$Sprite);

	  /**
	   * @param {Tiny.Texture} texture - the texture of the tiling sprite
	   * @param {number} [width=100] - the width of the tiling sprite
	   * @param {number} [height=100] - the height of the tiling sprite
	   */
	  function TilingSprite(texture) {
	    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
	    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;

	    _classCallCheck(this, TilingSprite);

	    /**
	     * Tile transform
	     *
	     * @member {Tiny.TransformStatic}
	     */
	    var _this = _possibleConstructorReturn(this, (TilingSprite.__proto__ || Object.getPrototypeOf(TilingSprite)).call(this, texture));

	    _this.tileTransform = new core.TransformStatic();

	    // /// private

	    /**
	     * The with of the tiling sprite
	     *
	     * @member {number}
	     * @private
	     */
	    _this._width = width;

	    /**
	     * The height of the tiling sprite
	     *
	     * @member {number}
	     * @private
	     */
	    _this._height = height;

	    /**
	     * Canvas pattern
	     *
	     * @type {CanvasPattern}
	     * @private
	     */
	    _this._canvasPattern = null;

	    /**
	     * transform that is applied to UV to get the texture coords
	     *
	     * @member {Tiny.TextureTransform}
	     */
	    _this.uvTransform = texture.transform || new _TextureTransform2.default(texture);

	    /**
	     * Plugin that is responsible for rendering this element.
	     * Allows to customize the rendering process without overriding '_renderWebGL' method.
	     *
	     * @member {string}
	     * @default 'tilingSprite'
	     */
	    _this.pluginName = 'tilingSprite';

	    /**
	     * Whether or not anchor affects uvs
	     *
	     * @member {boolean}
	     * @default false
	     */
	    _this.uvRespectAnchor = false;
	    return _this;
	  }

	  /**
	   * Changes frame clamping in corresponding textureTransform, shortcut
	   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
	   *
	   * @default 0.5
	   * @member {number}
	   */


	  _createClass(TilingSprite, [{
	    key: '_onTextureUpdate',


	    /**
	     * @private
	     */
	    value: function _onTextureUpdate() {
	      if (this.uvTransform) {
	        this.uvTransform.texture = this._texture;
	      }
	    }

	    /**
	     * Renders the object using the WebGL renderer
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The renderer
	     */

	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      // tweak our texture temporarily..
	      var texture = this._texture;

	      if (!texture || !texture.valid) {
	        return;
	      }

	      this.tileTransform.updateLocalTransform();
	      this.uvTransform.update();

	      renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
	      renderer.plugins[this.pluginName].render(this);
	    }

	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - a reference to the canvas renderer
	     */

	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var texture = this._texture;

	      if (!texture.baseTexture.hasLoaded) {
	        return;
	      }

	      var context = renderer.context;
	      var transform = this.worldTransform;
	      var resolution = renderer.resolution;
	      var baseTexture = texture.baseTexture;
	      var baseTextureResolution = texture.baseTexture.resolution;
	      var modX = this.tilePosition.x / this.tileScale.x % texture._frame.width;
	      var modY = this.tilePosition.y / this.tileScale.y % texture._frame.height;

	      // create a nice shiny pattern!
	      // TODO this needs to be refreshed if texture changes..
	      if (!this._canvasPattern) {
	        // cut an object from a spritesheet..
	        var tempCanvas = new core.CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);

	        // Tint the tiling sprite
	        if (this.tint !== 0xFFFFFF) {
	          if (this.cachedTint !== this.tint) {
	            this.cachedTint = this.tint;

	            this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);
	          }
	          tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
	        } else {
	          tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);
	        }
	        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');
	      }

	      // set context state..
	      context.globalAlpha = this.worldAlpha;
	      context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);

	      // TODO - this should be rolled into the setTransform above..
	      context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);

	      context.translate(modX + this.anchor.x * -this._width, modY + this.anchor.y * -this._height);

	      renderer.setBlendMode(this.blendMode);

	      // fill the pattern!
	      context.fillStyle = this._canvasPattern;
	      context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);
	    }

	    /**
	     * Updates the bounds of the tiling sprite.
	     *
	     * @private
	     */

	  }, {
	    key: '_calculateBounds',
	    value: function _calculateBounds() {
	      var minX = this._width * -this._anchor._x;
	      var minY = this._height * -this._anchor._y;
	      var maxX = this._width * (1 - this._anchor._x);
	      var maxY = this._height * (1 - this._anchor._y);

	      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
	    }

	    /**
	     * Gets the local bounds of the sprite object.
	     *
	     * @param {Tiny.Rectangle} rect - The output rectangle.
	     * @return {Tiny.Rectangle} The bounds.
	     */

	  }, {
	    key: 'getLocalBounds',
	    value: function getLocalBounds(rect) {
	      // we can do a fast local bounds if the sprite has no children!
	      if (this.children.length === 0) {
	        this._bounds.minX = this._width * -this._anchor._x;
	        this._bounds.minY = this._height * -this._anchor._y;
	        this._bounds.maxX = this._width * (1 - this._anchor._x);
	        this._bounds.maxY = this._height * (1 - this._anchor._x);

	        if (!rect) {
	          if (!this._localBoundsRect) {
	            this._localBoundsRect = new core.Rectangle();
	          }

	          rect = this._localBoundsRect;
	        }

	        return this._bounds.getRectangle(rect);
	      }

	      return _get(TilingSprite.prototype.__proto__ || Object.getPrototypeOf(TilingSprite.prototype), 'getLocalBounds', this).call(this, rect);
	    }

	    /**
	     * Checks if a point is inside this tiling sprite.
	     *
	     * @param {Tiny.Point} point - the point to check
	     * @return {boolean} Whether or not the sprite contains the point.
	     */

	  }, {
	    key: 'containsPoint',
	    value: function containsPoint(point) {
	      this.worldTransform.applyInverse(point, tempPoint);

	      var width = this._width;
	      var height = this._height;
	      var x1 = -width * this.anchor._x;

	      if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
	        var y1 = -height * this.anchor._y;

	        if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
	          return true;
	        }
	      }

	      return false;
	    }

	    /**
	     * Destroys this tiling sprite
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      _get(TilingSprite.prototype.__proto__ || Object.getPrototypeOf(TilingSprite.prototype), 'destroy', this).call(this);

	      this.tileTransform = null;
	      this.uvTransform = null;
	    }

	    /**
	     * Helper function that creates a new tiling sprite based on the source you provide.
	     * The source can be - frame id, image url, video url, canvas element, video element, base texture
	     *
	     * @static
	     * @param {number|string|Tiny.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
	     * @param {number} width - the width of the tiling sprite
	     * @param {number} height - the height of the tiling sprite
	     * @return {Tiny.Texture} The newly created texture
	     */

	  }, {
	    key: 'clampMargin',
	    get: function get() {
	      return this.uvTransform.clampMargin;
	    },
	    set: function set(value) {
	      this.uvTransform.clampMargin = value;
	      this.uvTransform.update(true);
	    }

	    /**
	     * The scaling of the image that is being tiled
	     *
	     * @member {Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'tileScale',
	    get: function get() {
	      return this.tileTransform.scale;
	    },
	    set: function set(value) {
	      this.tileTransform.scale.copy(value);
	    }

	    /**
	     * The offset of the image that is being tiled
	     *
	     * @member {Tiny.ObservablePoint}
	     */

	  }, {
	    key: 'tilePosition',
	    get: function get() {
	      return this.tileTransform.position;
	    },
	    set: function set(value) {
	      this.tileTransform.position.copy(value);
	    }
	  }, {
	    key: 'width',


	    /**
	     * The width of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */
	    get: function get() {
	      return this._width;
	    },
	    set: function set(value) {
	      this._width = value;
	    }

	    /**
	     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'height',
	    get: function get() {
	      return this._height;
	    },
	    set: function set(value) {
	      this._height = value;
	    }
	  }], [{
	    key: 'from',
	    value: function from(source, width, height) {
	      return new TilingSprite(core.Texture.from(source), width, height);
	    }

	    /**
	     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
	     * The frame ids are created when a Texture packer file has been loaded
	     *
	     * @static
	     * @param {string} frameId - The frame Id of the texture in the cache
	     * @param {number} width - the width of the tiling sprite
	     * @param {number} height - the height of the tiling sprite
	     * @return {Tiny.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
	     */

	  }, {
	    key: 'fromFrame',
	    value: function fromFrame(frameId, width, height) {
	      var texture = core.TextureCache[frameId];

	      if (!texture) {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
	      }

	      return new TilingSprite(texture, width, height);
	    }

	    /**
	     * Helper function that creates a sprite that will contain a texture based on an image url
	     * If the image is not in the texture cache it will be loaded
	     *
	     * @static
	     * @param {string} imageId - The image url of the texture
	     * @param {number} width - the width of the tiling sprite
	     * @param {number} height - the height of the tiling sprite
	     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter
	     * @param {number} [scaleMode=Tiny.SCALE_MODE] - if you want to specify the scale mode,
	     *  see {@link Tiny.SCALE_MODES} for possible values
	     * @return {Tiny.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
	     */

	  }, {
	    key: 'fromImage',
	    value: function fromImage(imageId, width, height, crossorigin, scaleMode) {
	      return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);
	    }
	  }]);

	  return TilingSprite;
	}(core.Sprite);

	exports.default = TilingSprite;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _const = __webpack_require__(7);

	var _path = __webpack_require__(87);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var tempMat = new core.Matrix();
	var tempArray = new Float32Array(4);

	/**
	 * WebGL renderer plugin for tiling sprites
	 *
	 * @class
	 * @memberof Tiny
	 * @extends Tiny.ObjectRenderer
	 */

	var TilingSpriteRenderer = function (_core$ObjectRenderer) {
	  _inherits(TilingSpriteRenderer, _core$ObjectRenderer);

	  /**
	   * constructor for renderer
	   *
	   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.
	   */
	  function TilingSpriteRenderer(renderer) {
	    _classCallCheck(this, TilingSpriteRenderer);

	    var _this = _possibleConstructorReturn(this, (TilingSpriteRenderer.__proto__ || Object.getPrototypeOf(TilingSpriteRenderer)).call(this, renderer));

	    _this.shader = null;
	    _this.simpleShader = null;
	    _this.quad = null;
	    return _this;
	  }

	  /**
	   * Sets up the renderer context and necessary buffers.
	   *
	   * @private
	   */


	  _createClass(TilingSpriteRenderer, [{
	    key: 'onContextChange',
	    value: function onContextChange() {
	      var gl = this.renderer.gl;

	      this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 sample = texture2D(uSampler, coord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n\n    gl_FragColor = sample * color ;\n}\n');
	      this.simpleShader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n    gl_FragColor = sample * color;\n}\n');

	      this.renderer.bindVao(null);
	      this.quad = new core.Quad(gl, this.renderer.state.attribState);
	      this.quad.initVao(this.shader);
	    }

	    /**
	     *
	     * @param {Tiny.extras.TilingSprite} ts tilingSprite to be rendered
	     */

	  }, {
	    key: 'render',
	    value: function render(ts) {
	      var renderer = this.renderer;
	      var quad = this.quad;

	      renderer.bindVao(quad.vao);

	      var vertices = quad.vertices;

	      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
	      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;

	      vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);
	      vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);

	      if (ts.uvRespectAnchor) {
	        vertices = quad.uvs;

	        vertices[0] = vertices[6] = -ts.anchor.x;
	        vertices[1] = vertices[3] = -ts.anchor.y;

	        vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
	        vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
	      }

	      quad.upload();

	      var tex = ts._texture;
	      var baseTex = tex.baseTexture;
	      var lt = ts.tileTransform.localTransform;
	      var uv = ts.uvTransform;
	      var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;

	      // auto, force repeat wrapMode for big tiling textures
	      if (isSimple) {
	        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
	          if (baseTex.wrapMode === _const.WRAP_MODES.CLAMP) {
	            baseTex.wrapMode = _const.WRAP_MODES.REPEAT;
	          }
	        } else {
	          isSimple = baseTex.wrapMode !== _const.WRAP_MODES.CLAMP;
	        }
	      }

	      var shader = isSimple ? this.simpleShader : this.shader;

	      renderer.bindShader(shader);

	      var w = tex.width;
	      var h = tex.height;
	      var W = ts._width;
	      var H = ts._height;

	      tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);

	      // that part is the same as above:
	      // tempMat.identity();
	      // tempMat.scale(tex.width, tex.height);
	      // tempMat.prepend(lt);
	      // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);

	      tempMat.invert();
	      if (isSimple) {
	        tempMat.append(uv.mapCoord);
	      } else {
	        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
	        shader.uniforms.uClampFrame = uv.uClampFrame;
	        shader.uniforms.uClampOffset = uv.uClampOffset;
	      }

	      shader.uniforms.uTransform = tempMat.toArray(true);

	      var color = tempArray;

	      core.utils.hex2rgb(ts.tint, color);
	      color[3] = ts.worldAlpha;
	      shader.uniforms.uColor = color;
	      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);

	      shader.uniforms.uSampler = renderer.bindTexture(tex);

	      renderer.setBlendMode(ts.blendMode);

	      quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);
	    }
	  }]);

	  return TilingSpriteRenderer;
	}(core.ObjectRenderer);

	exports.default = TilingSpriteRenderer;


	core.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
	 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
	 *
	 * A BitmapText can only be created when the font is loaded
	 *
	 * ```js
	 * // in this case the font is in a file called 'desyrel.fnt'
	 * let bitmapText = new Tiny.extras.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
	 * ```
	 *
	 * http://www.angelcode.com/products/bmfont/ for windows or
	 * http://www.bmglyph.com/ for mac.
	 *
	 * @class
	 * @extends Tiny.Container
	 * @memberof Tiny
	 */
	var BitmapText = function (_core$Container) {
	  _inherits(BitmapText, _core$Container);

	  /**
	   * @param {string} text - The copy that you would like the text to display
	   * @param {object} style - The style parameters
	   * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form
	   *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
	   * @param {string} [style.font.name] - The bitmap font id
	   * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24
	   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect
	   *      single line text
	   * @param {number} [style.tint=0xFFFFFF] - The tint color
	   */
	  function BitmapText(text) {
	    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, BitmapText);

	    /**
	     * Private tracker for the width of the overall text
	     *
	     * @member {number}
	     * @private
	     */
	    var _this = _possibleConstructorReturn(this, (BitmapText.__proto__ || Object.getPrototypeOf(BitmapText)).call(this));

	    _this._textWidth = 0;

	    /**
	     * Private tracker for the height of the overall text
	     *
	     * @member {number}
	     * @private
	     */
	    _this._textHeight = 0;

	    /**
	     * Private tracker for the letter sprite pool.
	     *
	     * @member {Tiny.Sprite[]}
	     * @private
	     */
	    _this._glyphs = [];

	    /**
	     * Private tracker for the current style.
	     *
	     * @member {object}
	     * @private
	     */
	    _this._font = {
	      tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
	      align: style.align || 'left',
	      name: null,
	      size: 0
	    };

	    /**
	     * Private tracker for the current font.
	     *
	     * @member {object}
	     * @private
	     */
	    _this.font = style.font; // run font setter

	    /**
	     * Private tracker for the current text.
	     *
	     * @member {string}
	     * @private
	     */
	    _this._text = text;

	    /**
	     * The max width of this bitmap text in pixels. If the text provided is longer than the
	     * value provided, line breaks will be automatically inserted in the last whitespace.
	     * Disable by setting value to 0
	     *
	     * @member {number}
	     */
	    _this.maxWidth = 0;

	    /**
	     * The max line height. This is useful when trying to use the total height of the Text,
	     * ie: when trying to vertically align.
	     *
	     * @member {number}
	     */
	    _this.maxLineHeight = 0;

	    /**
	     * Text anchor. read-only
	     *
	     * @member {Tiny.ObservablePoint}
	     * @private
	     */
	    _this._anchor = new core.ObservablePoint(function () {
	      _this.dirty = true;
	    }, _this, 0, 0);

	    /**
	     * The dirty state of this object.
	     *
	     * @member {boolean}
	     */
	    _this.dirty = false;

	    _this.updateText();
	    return _this;
	  }

	  /**
	   * Renders text and updates it when needed
	   *
	   * @private
	   */


	  _createClass(BitmapText, [{
	    key: 'updateText',
	    value: function updateText() {
	      var data = BitmapText.fonts[this._font.name];
	      var scale = this._font.size / data.size;
	      var pos = new core.Point();
	      var chars = [];
	      var lineWidths = [];

	      var prevCharCode = null;
	      var lastLineWidth = 0;
	      var maxLineWidth = 0;
	      var line = 0;
	      var lastSpace = -1;
	      var lastSpaceWidth = 0;
	      var maxLineHeight = 0;

	      for (var i = 0; i < this.text.length; i++) {
	        var charCode = this.text.charCodeAt(i);

	        if (/(\s)/.test(this.text.charAt(i))) {
	          lastSpace = i;
	          lastSpaceWidth = lastLineWidth;
	        }

	        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) {
	          lineWidths.push(lastLineWidth);
	          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
	          line++;

	          pos.x = 0;
	          pos.y += data.lineHeight;
	          prevCharCode = null;
	          continue;
	        }

	        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth) {
	          core.removeItems(chars, lastSpace, i - lastSpace);
	          i = lastSpace;
	          lastSpace = -1;

	          lineWidths.push(lastSpaceWidth);
	          maxLineWidth = Math.max(maxLineWidth, lastSpaceWidth);
	          line++;

	          pos.x = 0;
	          pos.y += data.lineHeight;
	          prevCharCode = null;
	          continue;
	        }

	        var charData = data.chars[charCode];

	        if (!charData) {
	          continue;
	        }

	        if (prevCharCode && charData.kerning[prevCharCode]) {
	          pos.x += charData.kerning[prevCharCode];
	        }

	        chars.push({
	          texture: charData.texture,
	          line: line,
	          charCode: charCode,
	          position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
	        });
	        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
	        pos.x += charData.xAdvance;
	        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
	        prevCharCode = charCode;
	      }

	      lineWidths.push(lastLineWidth);
	      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

	      var lineAlignOffsets = [];

	      for (var _i = 0; _i <= line; _i++) {
	        var alignOffset = 0;

	        if (this._font.align === 'right') {
	          alignOffset = maxLineWidth - lineWidths[_i];
	        } else if (this._font.align === 'center') {
	          alignOffset = (maxLineWidth - lineWidths[_i]) / 2;
	        }

	        lineAlignOffsets.push(alignOffset);
	      }

	      var lenChars = chars.length;
	      var tint = this.tint;

	      for (var _i2 = 0; _i2 < lenChars; _i2++) {
	        var c = this._glyphs[_i2]; // get the next glyph sprite

	        if (c) {
	          c.texture = chars[_i2].texture;
	        } else {
	          c = new core.Sprite(chars[_i2].texture);
	          this._glyphs.push(c);
	        }

	        c.position.x = (chars[_i2].position.x + lineAlignOffsets[chars[_i2].line]) * scale;
	        c.position.y = chars[_i2].position.y * scale;
	        c.scale.x = c.scale.y = scale;
	        c.tint = tint;

	        if (!c.parent) {
	          this.addChild(c);
	        }
	      }

	      // remove unnecessary children.
	      for (var _i3 = lenChars; _i3 < this._glyphs.length; ++_i3) {
	        this.removeChild(this._glyphs[_i3]);
	      }

	      this._textWidth = maxLineWidth * scale;
	      this._textHeight = (pos.y + data.lineHeight) * scale;

	      // apply anchor
	      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
	        for (var _i4 = 0; _i4 < lenChars; _i4++) {
	          this._glyphs[_i4].x -= this._textWidth * this.anchor.x;
	          this._glyphs[_i4].y -= this._textHeight * this.anchor.y;
	        }
	      }
	      this.maxLineHeight = maxLineHeight * scale;
	    }

	    /**
	     * Updates the transform of this object
	     *
	     * @private
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform() {
	      this.validate();
	      this.containerUpdateTransform();
	    }

	    /**
	     * Validates text before calling parent's getLocalBounds
	     *
	     * @return {Tiny.Rectangle} The rectangular bounding area
	     */

	  }, {
	    key: 'getLocalBounds',
	    value: function getLocalBounds() {
	      this.validate();

	      return _get(BitmapText.prototype.__proto__ || Object.getPrototypeOf(BitmapText.prototype), 'getLocalBounds', this).call(this);
	    }

	    /**
	     * Updates text when needed
	     *
	     * @private
	     */

	  }, {
	    key: 'validate',
	    value: function validate() {
	      if (this.dirty) {
	        this.updateText();
	        this.dirty = false;
	      }
	    }

	    /**
	     * The tint of the BitmapText object
	     *
	     * @member {number}
	     */

	  }, {
	    key: 'tint',
	    get: function get() {
	      return this._font.tint;
	    },
	    set: function set(value) {
	      this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;

	      this.dirty = true;
	    }

	    /**
	     * The alignment of the BitmapText object
	     *
	     * @member {string}
	     * @default 'left'
	     */

	  }, {
	    key: 'align',
	    get: function get() {
	      return this._font.align;
	    },
	    set: function set(value) {
	      this._font.align = value || 'left';

	      this.dirty = true;
	    }

	    /**
	     * The anchor sets the origin point of the text.
	     * The default is 0,0 this means the text's origin is the top left
	     * Setting the anchor to 0.5,0.5 means the text's origin is centered
	     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner
	     *
	     * @member {Tiny.Point | number}
	     */

	  }, {
	    key: 'anchor',
	    get: function get() {
	      return this._anchor;
	    },
	    set: function set(value) {
	      if (typeof value === 'number') {
	        this._anchor.set(value);
	      } else {
	        this._anchor.copy(value);
	      }
	    }

	    /**
	     * The font descriptor of the BitmapText object
	     *
	     * @member {string|object}
	     */

	  }, {
	    key: 'font',
	    get: function get() {
	      return this._font;
	    },
	    set: function set(value) {
	      if (!value) {
	        return;
	      }

	      if (typeof value === 'string') {
	        value = value.split(' ');

	        this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
	        this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
	      } else {
	        this._font.name = value.name;
	        this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
	      }

	      this.dirty = true;
	    }

	    /**
	     * The text of the BitmapText object
	     *
	     * @member {string}
	     */

	  }, {
	    key: 'text',
	    get: function get() {
	      return this._text;
	    },
	    set: function set(value) {
	      value = value.toString() || ' ';
	      if (this._text === value) {
	        return;
	      }
	      this._text = value;
	      this.dirty = true;
	    }

	    /**
	     * The width of the overall text, different from fontSize,
	     * which is defined in the style object
	     *
	     * @member {number}
	     * @readonly
	     */

	  }, {
	    key: 'textWidth',
	    get: function get() {
	      this.validate();

	      return this._textWidth;
	    }

	    /**
	     * The height of the overall text, different from fontSize,
	     * which is defined in the style object
	     *
	     * @member {number}
	     * @readonly
	     */

	  }, {
	    key: 'textHeight',
	    get: function get() {
	      this.validate();

	      return this._textHeight;
	    }
	  }]);

	  return BitmapText;
	}(core.Container);

	exports.default = BitmapText;


	BitmapText.fonts = {};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _scroller = __webpack_require__(148);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @class
	 * @extends Tiny.Container
	 * @memberof Tiny
	 */
	var Layer = function (_core$Container) {
	  _inherits(Layer, _core$Container);

	  /**
	   *
	   */
	  function Layer() {
	    _classCallCheck(this, Layer);

	    var _this = _possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this));

	    _this._list = [];
	    /**
	     * @property _style
	     * @type {Object}
	     * @default {padding: 10, font: "14px Arial", fill: '#ffffff'}
	     * @private
	     */
	    _this._style = {
	      padding: 10,
	      fontSize: 14
	    };

	    /**
	     * @property scrollWidth
	     * @default 100
	     * @type {number}
	     */
	    _this.scrollHeight = 100;

	    /**
	     * @property scrollWidth
	     * @default 100
	     * @type {number}
	     */
	    _this.scrollWidth = 100;

	    _this.container = new core.Container();
	    _this.container.interactive = true;
	    _this.g = new core.Graphics();
	    _this.container.mask = _this.g;

	    _this.init();
	    return _this;
	  }

	  _createClass(Layer, [{
	    key: 'init',
	    value: function init() {
	      var self = this;
	      this.scroller = new _scroller.Scroller(function (left, top, zoom) {
	        self.container.position.y = -top;
	      }, {
	        scrollingY: true
	      });
	      this._eventBind(this.scroller);
	      this.addChild(this.container);
	    }

	    /**
	     * 设置容器事件区域
	     *
	     * @method setHitArea
	     * @param {Rectangle} rect
	     */

	  }, {
	    key: 'setHitArea',
	    value: function setHitArea(rect) {
	      if (rect instanceof core.Rectangle) {
	        this.container.hitArea = rect;
	      }
	    }
	  }, {
	    key: 'setList',
	    value: function setList(list) {
	      this._list = list;
	      this.refreshList();
	    }
	  }, {
	    key: 'refreshList',
	    value: function refreshList() {
	      var self = this;
	      this.container.removeChildren();

	      this._list.forEach(function (item, i) {
	        var tb = new core.Text(item.title, self._style);
	        tb.anchor.set(0.5);
	        tb.position.set(self.scrollWidth / 2, tb.height * (i + 1));

	        tb.interactive = true;
	        tb.touchstart = tb.mousedown = function (data) {
	          self.timeStamp = data.data.originalEvent.timeStamp;
	          this.scale.set(1.2, 1.2);
	        };
	        tb.mouseup = tb.mouseupoutside = tb.touchend = tb.touchendoutside = function (data) {
	          this.scale.set(1, 1);
	        };
	        tb.tap = tb.click = function (data) {
	          if (data.data.originalEvent.timeStamp - self.timeStamp > 150) {
	            return;
	          }

	          item.action(data);
	        };
	        self.container.addChildAt(tb, i);
	      });

	      this.scroller.setDimensions(this.scrollWidth, this.scrollHeight, self.container.width, self.container.height);
	    }

	    /**
	     * 设置列表项的样式
	     *
	     * @method setStyle
	     * @param {Object} style
	     */

	  }, {
	    key: 'setStyle',
	    value: function setStyle(style) {
	      this._style = style;
	      this.refreshList();
	    }
	  }, {
	    key: '_eventBind',
	    value: function _eventBind(scroller) {
	      var self = this;
	      var object = this.container;
	      object.touchstart = object.mousedown = function (data) {
	        var e = data.data.originalEvent;
	        scroller.doTouchStart(e.touches, e.timeStamp);
	      };

	      object.mousemove = object.touchmove = function (data) {
	        var e = data.data.originalEvent;
	        if (!core.rectContainsPoint(new core.Rectangle(0, 0, self.scrollWidth, self.scrollHeight), data.data.global)) return;
	        scroller.doTouchMove(e.touches, e.timeStamp, e.scale);
	      };

	      object.mouseup = object.mouseupoutside = object.touchend = object.touchendoutside = function (data) {
	        var e = data.data.originalEvent;
	        scroller.doTouchEnd(e.timeStamp);
	      };
	    }

	    /**
	     *
	     * @private
	     */

	  }, {
	    key: '_setMask',
	    value: function _setMask() {
	      this.removeChild(this.g);
	      this.g.beginFill(0xFFFFFF);
	      this.g.drawRect(0, 0, this.scrollWidth, this.scrollHeight);
	      this.g.endFill();
	      this.addChild(this.g);
	    }

	    /**
	     * 设置 ListLayer 的尺寸
	     *
	     * @method setScroll
	     * @param w
	     * @param h
	     */

	  }, {
	    key: 'setScroll',
	    value: function setScroll(w, h) {
	      this.scrollWidth = w;
	      this.scrollHeight = h;
	      this._setMask();
	    }
	  }]);

	  return Layer;
	}(core.Container);

	exports.default = Layer;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function (root, factory) {
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(149), __webpack_require__(150)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
	        // CommonJS
	        factory(exports, require('./lib/animate'), require('./lib/Scroller'));
	    }
	})(undefined, function (exports, animate, Scroller) {
	    exports.animate = animate;
	    exports.Scroller = Scroller;
	});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*
	 * Scroller
	 * http://github.com/zynga/scroller
	 *
	 * Copyright 2011, Zynga Inc.
	 * Licensed under the MIT License.
	 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
	 *
	 * Based on the work of: Unify Project (unify-project.org)
	 * http://unify-project.org
	 * Copyright 2011, Deutsche Telekom AG
	 * License: MIT + Apache (V2)
	 */

	/**
	 * Generic animation class with support for dropped frames both optional easing and duration.
	 *
	 * Optional duration is useful when the lifetime is defined by another condition than time
	 * e.g. speed of an animating object, etc.
	 *
	 * Dropped frame logic allows to keep using the same updater logic independent from the actual
	 * rendering. This eases a lot of cases where it might be pretty complex to break down a state
	 * based on the pure time difference.
	 */
	(function (root, factory) {
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
	        // CommonJS
	        factory(exports);
	    } else {
	        // Browser globals
	        factory(root.animate = {});
	    }
	})(undefined, function (exports) {
	    var global = typeof window === 'undefined' ? this : window;
	    var time = Date.now || function () {
	        return +new Date();
	    };
	    var desiredFrames = 60;
	    var millisecondsPerSecond = 1000;
	    var running = {};
	    var counter = 1;

	    /**
	     * A requestAnimationFrame wrapper / polyfill.
	     *
	     * @param callback {Function} The callback to be invoked before the next repaint.
	     * @param root {HTMLElement} The root element for the repaint
	     */
	    exports.requestAnimationFrame = function () {
	        // Check for request animation Frame support
	        var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
	        var isNative = !!requestFrame;

	        if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
	            isNative = false;
	        }

	        if (isNative) {
	            return function (callback, root) {
	                requestFrame(callback, root);
	            };
	        }

	        var TARGET_FPS = 60;
	        var requests = {};
	        var requestCount = 0;
	        var rafHandle = 1;
	        var intervalHandle = null;
	        var lastActive = +new Date();

	        return function (callback, root) {
	            var callbackHandle = rafHandle++;

	            // Store callback
	            requests[callbackHandle] = callback;
	            requestCount++;

	            // Create timeout at first request
	            if (intervalHandle === null) {

	                intervalHandle = setInterval(function () {

	                    var time = +new Date();
	                    var currentRequests = requests;

	                    // Reset data structure before executing callbacks
	                    requests = {};
	                    requestCount = 0;

	                    for (var key in currentRequests) {
	                        if (currentRequests.hasOwnProperty(key)) {
	                            currentRequests[key](time);
	                            lastActive = time;
	                        }
	                    }

	                    // Disable the timeout when nothing happens for a certain
	                    // period of time
	                    if (time - lastActive > 2500) {
	                        clearInterval(intervalHandle);
	                        intervalHandle = null;
	                    }
	                }, 1000 / TARGET_FPS);
	            }

	            return callbackHandle;
	        };
	    }();

	    /**
	     * Stops the given animation.
	     *
	     * @param id {Integer} Unique animation ID
	     * @return {Boolean} Whether the animation was stopped (aka, was running before)
	     */
	    exports.stop = function (id) {
	        var cleared = running[id] !== null;
	        if (cleared) {
	            running[id] = null;
	        }

	        return cleared;
	    };

	    /**
	     * Whether the given animation is still running.
	     *
	     * @param id {Integer} Unique animation ID
	     * @return {Boolean} Whether the animation is still running
	     */
	    exports.isRunning = function (id) {
	        return running[id] !== null;
	    };

	    /**
	     * Start the animation.
	     *
	     * @param stepCallback {Function} Pointer to function which is executed on every step.
	     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`
	     * @param verifyCallback {Function} Executed before every animation step.
	     *   Signature of the method should be `function() { return continueWithAnimation; }`
	     * @param completedCallback {Function}
	     *   Signature of the method should be `function(droppedFrames, finishedAnimation, optional wasFinished) {}`
	     * @param duration {Integer} Milliseconds to run the animation
	     * @param easingMethod {Function} Pointer to easing function
	     *   Signature of the method should be `function(percent) { return modifiedValue; }`
	     * @param root {Element} Render root. Used for internal usage of requestAnimationFrame.
	     * @return {Integer} Identifier of animation. Can be used to stop it any time.
	     */
	    exports.start = function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
	        var start = time();
	        var lastFrame = start;
	        var percent = 0;
	        var dropCounter = 0;
	        var id = counter++;

	        // Compacting running db automatically every few new animations
	        if (id % 20 === 0) {
	            var newRunning = {};
	            for (var usedId in running) {
	                newRunning[usedId] = true;
	            }
	            running = newRunning;
	        }

	        // This is the internal step method which is called every few milliseconds
	        var step = function step(virtual) {

	            // Normalize virtual value
	            var render = virtual !== true;

	            // Get current time
	            var now = time();

	            // Verification is executed before next animation step
	            if (!running[id] || verifyCallback && !verifyCallback(id)) {

	                running[id] = null;
	                completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);
	                return;
	            }

	            // For the current rendering to apply let's update omitted steps in memory.
	            // This is important to bring internal state variables up-to-date with progress in time.
	            if (render) {

	                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
	                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
	                    step(true);
	                    dropCounter++;
	                }
	            }

	            // Compute percent value
	            if (duration) {
	                percent = (now - start) / duration;
	                if (percent > 1) {
	                    percent = 1;
	                }
	            }

	            // Execute step callback, then...
	            var value = easingMethod ? easingMethod(percent) : percent;
	            if ((stepCallback(value, now, render) === false || percent === 1) && render) {
	                running[id] = null;
	                completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration === undefined);
	            } else if (render) {
	                lastFrame = now;
	                exports.requestAnimationFrame(step, root);
	            }
	        };

	        // Mark as running
	        running[id] = true;

	        // Init first step
	        exports.requestAnimationFrame(step, root);

	        // Return unique animation ID
	        return id;
	    };
	});

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*
	 * Scroller
	 * http://github.com/zynga/scroller
	 *
	 * Copyright 2011, Zynga Inc.
	 * Licensed under the MIT License.
	 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
	 *
	 * Based on the work of: Unify Project (unify-project.org)
	 * http://unify-project.org
	 * Copyright 2011, Deutsche Telekom AG
	 * License: MIT + Apache (V2)
	 */

	(function (root, factory) {
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(149)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {
	        // CommonJS
	        module.exports = factory(require('./animate'));
	    } else {
	        // Browser globals
	        root.Scroller = factory(root.animate);
	    }
	})(undefined, function (animate) {
	    var NOOP = function NOOP() {};

	    /**
	     * A pure logic 'component' for 'virtual' scrolling/zooming.
	     */
	    var Scroller = function Scroller(callback, options) {
	        this.__callback = callback;

	        this.options = {
	            /** Enable scrolling on x-axis */
	            scrollingX: true,

	            /** Enable scrolling on y-axis */
	            scrollingY: true,

	            /** Enable animations for deceleration, snap back, zooming and scrolling */
	            animating: true,

	            /** duration for animations triggered by scrollTo/zoomTo */
	            animationDuration: 250,

	            /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */
	            bouncing: true,

	            /** Enable locking to the main axis if user moves only slightly on one of them at start */
	            locking: true,

	            /** Enable pagination mode (switching between full page content panes) */
	            paging: false,

	            /** Enable snapping of content to a configured pixel grid */
	            snapping: false,

	            /** Enable zooming of content via API, fingers and mouse wheel */
	            zooming: false,

	            /** Minimum zoom level */
	            minZoom: 0.5,

	            /** Maximum zoom level */
	            maxZoom: 3,

	            /** Multiply or decrease scrolling speed **/
	            speedMultiplier: 1,

	            /** Callback that is fired on the later of touch end or deceleration end,
	                provided that another scrolling action has not begun. Used to know
	                when to fade out a scrollbar. */
	            scrollingComplete: NOOP,

	            /** This configures the amount of change applied to deceleration when reaching boundaries  **/
	            penetrationDeceleration: 0.03,

	            /** This configures the amount of change applied to acceleration when reaching boundaries  **/
	            penetrationAcceleration: 0.08
	        };

	        for (var key in options) {
	            this.options[key] = options[key];
	        }
	    };

	    // Easing Equations (c) 2003 Robert Penner, all rights reserved.
	    // Open source under the BSD License.

	    /**
	     * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
	     **/
	    var easeOutCubic = function easeOutCubic(pos) {
	        return Math.pow(pos - 1, 3) + 1;
	    };

	    /**
	     * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
	     **/
	    var easeInOutCubic = function easeInOutCubic(pos) {
	        if ((pos /= 0.5) < 1) {
	            return 0.5 * Math.pow(pos, 3);
	        }

	        return 0.5 * (Math.pow(pos - 2, 3) + 2);
	    };

	    Scroller.prototype = {

	        /*
	          ---------------------------------------------------------------------------
	          INTERNAL FIELDS :: STATUS
	          ---------------------------------------------------------------------------
	        */

	        /** {Boolean} Whether only a single finger is used in touch handling */
	        __isSingleTouch: false,

	        /** {Boolean} Whether a touch event sequence is in progress */
	        __isTracking: false,

	        /** {Boolean} Whether a deceleration animation went to completion. */
	        __didDecelerationComplete: false,

	        /**
	         * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when
	         * a gesturestart event happens. This has higher priority than dragging.
	         */
	        __isGesturing: false,

	        /**
	         * {Boolean} Whether the user has moved by such a distance that we have enabled
	         * dragging mode. Hint: It's only enabled after some pixels of movement to
	         * not interrupt with clicks etc.
	         */
	        __isDragging: false,

	        /**
	         * {Boolean} Not touching and dragging anymore, and smoothly animating the
	         * touch sequence using deceleration.
	         */
	        __isDecelerating: false,

	        /**
	         * {Boolean} Smoothly animating the currently configured change
	         */
	        __isAnimating: false,

	        /*
	          ---------------------------------------------------------------------------
	          INTERNAL FIELDS :: DIMENSIONS
	          ---------------------------------------------------------------------------
	        */

	        /** {Integer} Viewport left boundary */
	        __clientLeft: 0,

	        /** {Integer} Viewport right boundary */
	        __clientTop: 0,

	        /** {Integer} Viewport width */
	        __clientWidth: 0,

	        /** {Integer} Viewport height */
	        __clientHeight: 0,

	        /** {Integer} Full content's width */
	        __contentWidth: 0,

	        /** {Integer} Full content's height */
	        __contentHeight: 0,

	        /** {Integer} Snapping width for content */
	        __snapWidth: 100,

	        /** {Integer} Snapping height for content */
	        __snapHeight: 100,

	        /** {Number} Zoom level */
	        __zoomLevel: 1,

	        /** {Number} Scroll position on x-axis */
	        __scrollLeft: 0,

	        /** {Number} Scroll position on y-axis */
	        __scrollTop: 0,

	        /** {Integer} Maximum allowed scroll position on x-axis */
	        __maxScrollLeft: 0,

	        /** {Integer} Maximum allowed scroll position on y-axis */
	        __maxScrollTop: 0,

	        /* {Number} Scheduled left position (final position when animating) */
	        __scheduledLeft: 0,

	        /* {Number} Scheduled top position (final position when animating) */
	        __scheduledTop: 0,

	        /* {Number} Scheduled zoom level (final scale when animating) */
	        __scheduledZoom: 0,

	        /*
	          ---------------------------------------------------------------------------
	          INTERNAL FIELDS :: LAST POSITIONS
	          ---------------------------------------------------------------------------
	        */

	        /** {Number} Left position of finger at start */
	        __lastTouchLeft: null,

	        /** {Number} Top position of finger at start */
	        __lastTouchTop: null,

	        /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */
	        __lastTouchMove: null,

	        /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */
	        __positions: null,

	        /*
	          ---------------------------------------------------------------------------
	          INTERNAL FIELDS :: DECELERATION SUPPORT
	          ---------------------------------------------------------------------------
	        */

	        /** {Integer} Minimum left scroll position during deceleration */
	        __minDecelerationScrollLeft: null,

	        /** {Integer} Minimum top scroll position during deceleration */
	        __minDecelerationScrollTop: null,

	        /** {Integer} Maximum left scroll position during deceleration */
	        __maxDecelerationScrollLeft: null,

	        /** {Integer} Maximum top scroll position during deceleration */
	        __maxDecelerationScrollTop: null,

	        /** {Number} Current factor to modify horizontal scroll position with on every step */
	        __decelerationVelocityX: null,

	        /** {Number} Current factor to modify vertical scroll position with on every step */
	        __decelerationVelocityY: null,

	        /*
	          ---------------------------------------------------------------------------
	          PUBLIC API
	          ---------------------------------------------------------------------------
	        */

	        /**
	         * Configures the dimensions of the client (outer) and content (inner) elements.
	         * Requires the available space for the outer element and the outer size of the inner element.
	         * All values which are falsy (null or zero etc.) are ignored and the old value is kept.
	         *
	         * @param clientWidth {Integer ? null} Inner width of outer element
	         * @param clientHeight {Integer ? null} Inner height of outer element
	         * @param contentWidth {Integer ? null} Outer width of inner element
	         * @param contentHeight {Integer ? null} Outer height of inner element
	         */
	        setDimensions: function setDimensions(clientWidth, clientHeight, contentWidth, contentHeight) {
	            // Only update values which are defined
	            if (clientWidth !== null) {
	                this.__clientWidth = clientWidth;
	            }

	            if (clientHeight !== null) {
	                this.__clientHeight = clientHeight;
	            }

	            if (contentWidth !== null) {
	                this.__contentWidth = contentWidth;
	            }

	            if (contentHeight !== null) {
	                this.__contentHeight = contentHeight;
	            }

	            // Refresh maximums
	            this.__computeScrollMax();

	            // Refresh scroll position
	            this.scrollTo(this.__scrollLeft, this.__scrollTop, true);
	        },

	        /**
	         * Sets the client coordinates in relation to the document.
	         *
	         * @param left {Integer ? 0} Left position of outer element
	         * @param top {Integer ? 0} Top position of outer element
	         */
	        setPosition: function setPosition(left, top) {
	            this.__clientLeft = left || 0;
	            this.__clientTop = top || 0;
	        },

	        /**
	         * Configures the snapping (when snapping is active)
	         *
	         * @param width {Integer} Snapping width
	         * @param height {Integer} Snapping height
	         */
	        setSnapSize: function setSnapSize(width, height) {
	            this.__snapWidth = width;
	            this.__snapHeight = height;
	        },

	        /**
	         * Returns the scroll position and zooming values
	         *
	         * @return {Map} `left` and `top` scroll position and `zoom` level
	         */
	        getValues: function getValues() {
	            return {
	                left: this.__scrollLeft,
	                top: this.__scrollTop,
	                right: this.__scrollLeft + this.__clientWidth / this.__zoomLevel,
	                bottom: this.__scrollTop + this.__clientHeight / this.__zoomLevel,
	                zoom: this.__zoomLevel
	            };
	        },

	        /**
	         * Get point in in content space from scroll coordinates.
	         */
	        getPoint: function getPoint(scrollLeft, scrollTop) {
	            var values = this.getValues();

	            return {
	                left: scrollLeft / values.zoom,
	                top: scrollTop / values.zoom
	            };
	        },

	        /**
	         * Returns the maximum scroll values
	         *
	         * @return {Map} `left` and `top` maximum scroll values
	         */
	        getScrollMax: function getScrollMax() {
	            return {
	                left: this.__maxScrollLeft,
	                top: this.__maxScrollTop
	            };
	        },

	        /**
	         * Zooms to the given level. Supports optional animation. Zooms
	         * the center when no coordinates are given.
	         *
	         * @param level {Number} Level to zoom to
	         * @param isAnimated {Boolean ? false} Whether to use animation
	         * @param fixedLeft {Number ? undefined} Stationary point's left coordinate (vector in client space)
	         * @param fixedTop {Number ? undefined} Stationary point's top coordinate (vector in client space)
	         * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
	         */
	        zoomTo: function zoomTo(level, isAnimated, fixedLeft, fixedTop, callback) {
	            if (!this.options.zooming) {
	                throw new Error("Zooming is not enabled!");
	            }

	            // Add callback if exists
	            if (callback) {
	                this.__zoomComplete = callback;
	            }

	            // Stop deceleration
	            if (this.__isDecelerating) {
	                animate.stop(this.__isDecelerating);
	                this.__isDecelerating = false;
	            }

	            var oldLevel = this.__zoomLevel;

	            // Normalize fixed point to center of viewport if not defined
	            if (fixedLeft === undefined) {
	                fixedLeft = this.__clientWidth / 2;
	            }

	            if (fixedTop === undefined) {
	                fixedTop = this.__clientHeight / 2;
	            }

	            // Limit level according to configuration
	            level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom);

	            // Recompute maximum values while temporary tweaking maximum scroll ranges
	            this.__computeScrollMax(level);

	            // Recompute left and top scroll positions based on new zoom level.
	            // Choosing the new viewport so that the origin's position remains
	            // fixed, we have central dilation about the origin.
	            // * Fixed point, $F$, remains stationary in content space and in the
	            // viewport.
	            // * Initial scroll position, $S_i$, in content space.
	            // * Final scroll position, $S_f$, in content space.
	            // * Initial scaling factor, $k_i$.
	            // * Final scaling factor, $k_f$.
	            //
	            // * $S_i \mapsto S_f$.
	            // * $(S_i - F) k_i = (S_f - F) k_f$.
	            // * $(S_i - F) k_i/k_f = (S_f - F)$.
	            // * $S_f = F + (S_i - F) k_i/k_f$.
	            //
	            // Fixed point location, $\vector{f} = (F - S_i) k_i$.
	            // * $F = S_i + \vector{f}/k_i$.
	            // * $S_f = S_i + \vector{f}/k_i + (S_i - S_i - \vector{f}/k_i) k_i/k_f$.
	            // * $S_f = S_i + \vector{f}/k_i - \vector{f}/k_f$.
	            // * $S_f k_f = S_i k_f + (k_f/k_i - 1)\vector{f}$.
	            // * $S_f k_f = (k_f/k_i)(S_i k_i) + (k_f/k_i - 1) \vector{f}$.
	            var k = level / oldLevel;
	            var left = k * (this.__scrollLeft + fixedLeft) - fixedLeft;
	            var top = k * (this.__scrollTop + fixedTop) - fixedTop;

	            // Limit x-axis
	            if (left > this.__maxScrollLeft) {
	                left = this.__maxScrollLeft;
	            } else if (left < 0) {
	                left = 0;
	            }

	            // Limit y-axis
	            if (top > this.__maxScrollTop) {
	                top = this.__maxScrollTop;
	            } else if (top < 0) {
	                top = 0;
	            }

	            // Push values out
	            this.__publish(left, top, level, isAnimated);
	        },

	        /**
	         * Zooms the content by the given factor.
	         *
	         * @param factor {Number} Zoom by given factor
	         * @param isAnimated {Boolean ? false} Whether to use animation
	         * @param originLeft {Number ? 0} Zoom in at given left coordinate
	         * @param originTop {Number ? 0} Zoom in at given top coordinate
	         * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
	         */
	        zoomBy: function zoomBy(factor, isAnimated, originLeft, originTop, callback) {
	            this.zoomTo(this.__zoomLevel * factor, isAnimated, originLeft, originTop, callback);
	        },

	        /**
	         * Scrolls to the given position. Respect limitations and snapping automatically.
	         *
	         * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>
	         * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>
	         * @param isAnimated {Boolean?false} Whether the scrolling should happen using an animation
	         * @param zoom {Number} [1.0] Zoom level to go to
	         */
	        scrollTo: function scrollTo(left, top, isAnimated, zoom) {
	            // Stop deceleration
	            if (this.__isDecelerating) {
	                animate.stop(this.__isDecelerating);
	                this.__isDecelerating = false;
	            }

	            // Correct coordinates based on new zoom level
	            if (zoom !== undefined && zoom !== this.__zoomLevel) {
	                if (!this.options.zooming) {
	                    throw new Error("Zooming is not enabled!");
	                }

	                left *= zoom;
	                top *= zoom;

	                // Recompute maximum values while temporary tweaking maximum scroll ranges
	                this.__computeScrollMax(zoom);
	            } else {
	                // Keep zoom when not defined
	                zoom = this.__zoomLevel;
	            }

	            if (!this.options.scrollingX) {
	                left = this.__scrollLeft;
	            } else {
	                if (this.options.paging) {
	                    left = Math.round(left / this.__clientWidth) * this.__clientWidth;
	                } else if (this.options.snapping) {
	                    left = Math.round(left / this.__snapWidth) * this.__snapWidth;
	                }
	            }

	            if (!this.options.scrollingY) {
	                top = this.__scrollTop;
	            } else {
	                if (this.options.paging) {
	                    top = Math.round(top / this.__clientHeight) * this.__clientHeight;
	                } else if (this.options.snapping) {
	                    top = Math.round(top / this.__snapHeight) * this.__snapHeight;
	                }
	            }

	            // Limit for allowed ranges
	            left = Math.max(Math.min(this.__maxScrollLeft, left), 0);
	            top = Math.max(Math.min(this.__maxScrollTop, top), 0);

	            // Don't animate when no change detected, still call publish to make sure
	            // that rendered position is really in-sync with internal data
	            if (left === this.__scrollLeft && top === this.__scrollTop) {
	                isAnimated = false;
	            }

	            // Publish new values
	            this.__publish(left, top, zoom, isAnimated);
	        },

	        /**
	         * Scroll by the given offset
	         *
	         * @param left {Number ? 0} Scroll x-axis by given offset
	         * @param top {Number ? 0} Scroll x-axis by given offset
	         * @param isAnimated {Boolean ? false} Whether to animate the given change
	         */
	        scrollBy: function scrollBy(left, top, isAnimated) {
	            var startLeft = this.__isAnimating ? this.__scheduledLeft : this.__scrollLeft;
	            var startTop = this.__isAnimating ? this.__scheduledTop : this.__scrollTop;

	            this.scrollTo(startLeft + (left || 0), startTop + (top || 0), isAnimated);
	        },

	        /*
	          ---------------------------------------------------------------------------
	          EVENT CALLBACKS
	          ---------------------------------------------------------------------------
	        */

	        /**
	         * Mouse wheel handler for zooming support
	         */
	        doMouseZoom: function doMouseZoom(wheelDelta, timeStamp, pageX, pageY) {
	            var change = wheelDelta > 0 ? 0.97 : 1.03;

	            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
	        },

	        /**
	         * Touch start handler for scrolling support
	         */
	        doTouchStart: function doTouchStart(touches, timeStamp) {
	            // Array-like check is enough here
	            if (touches.length === undefined) {
	                throw new Error("Invalid touch list: " + touches);
	            }

	            if (timeStamp instanceof Date) {
	                timeStamp = timeStamp.valueOf();
	            }
	            if (typeof timeStamp !== "number") {
	                throw new Error("Invalid timestamp value: " + timeStamp);
	            }

	            // Reset interruptedAnimation flag
	            this.__interruptedAnimation = true;

	            // Stop deceleration
	            if (this.__isDecelerating) {
	                animate.stop(this.__isDecelerating);
	                this.__isDecelerating = false;
	                this.__interruptedAnimation = true;
	            }

	            // Stop animation
	            if (this.__isAnimating) {
	                animate.stop(this.__isAnimating);
	                this.__isAnimating = false;
	                this.__interruptedAnimation = true;
	            }

	            // Use center point when dealing with two fingers
	            var currentTouchLeft, currentTouchTop;
	            var isSingleTouch = touches.length === 1;
	            if (isSingleTouch) {
	                currentTouchLeft = touches[0].pageX;
	                currentTouchTop = touches[0].pageY;
	            } else {
	                currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
	                currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
	            }

	            // Store initial positions
	            this.__initialTouchLeft = currentTouchLeft;
	            this.__initialTouchTop = currentTouchTop;

	            // Store current zoom level
	            this.__zoomLevelStart = this.__zoomLevel;

	            // Store initial touch positions
	            this.__lastTouchLeft = currentTouchLeft;
	            this.__lastTouchTop = currentTouchTop;

	            // Store initial move time stamp
	            this.__lastTouchMove = timeStamp;

	            // Reset initial scale
	            this.__lastScale = 1;

	            // Reset locking flags
	            this.__enableScrollX = !isSingleTouch && this.options.scrollingX;
	            this.__enableScrollY = !isSingleTouch && this.options.scrollingY;

	            // Reset tracking flag
	            this.__isTracking = true;

	            // Reset deceleration complete flag
	            this.__didDecelerationComplete = false;

	            // Dragging starts directly with two fingers, otherwise lazy with an offset
	            this.__isDragging = !isSingleTouch;

	            // Some features are disabled in multi touch scenarios
	            this.__isSingleTouch = isSingleTouch;

	            // Clearing data structure
	            this.__positions = [];
	        },

	        /**
	         * Touch move handler for scrolling support
	         * @param {Number} [1.0] scale - ....
	         */
	        doTouchMove: function doTouchMove(touches, timeStamp, scale) {
	            // Array-like check is enough here
	            if (touches.length === undefined) {
	                throw new Error("Invalid touch list: " + touches);
	            }

	            if (timeStamp instanceof Date) {
	                timeStamp = timeStamp.valueOf();
	            }
	            if (typeof timeStamp !== "number") {
	                throw new Error("Invalid timestamp value: " + timeStamp);
	            }

	            // Ignore event when tracking is not enabled (event might be outside of element)
	            if (!this.__isTracking) {
	                return;
	            }

	            var currentTouchLeft, currentTouchTop;

	            // Compute move based around of center of fingers
	            if (touches.length === 2) {
	                currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
	                currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
	            } else {
	                currentTouchLeft = touches[0].pageX;
	                currentTouchTop = touches[0].pageY;
	            }

	            var positions = this.__positions;

	            // Are we already is dragging mode?
	            if (this.__isDragging) {
	                // Compute move distance
	                var moveX = currentTouchLeft - this.__lastTouchLeft;
	                var moveY = currentTouchTop - this.__lastTouchTop;

	                // Read previous scroll position and zooming
	                var scrollLeft = this.__scrollLeft;
	                var scrollTop = this.__scrollTop;
	                var level = this.__zoomLevel;

	                // Work with scaling
	                if (scale !== undefined && this.options.zooming) {
	                    var oldLevel = level;

	                    // Recompute level based on previous scale and new scale
	                    level = level / this.__lastScale * scale;

	                    // Limit level according to configuration
	                    level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom);

	                    // Only do further compution when change happened
	                    if (oldLevel !== level) {
	                        // Compute relative event position to container
	                        var currentTouchLeftRel = currentTouchLeft - this.__clientLeft;
	                        var currentTouchTopRel = currentTouchTop - this.__clientTop;

	                        // Recompute left and top coordinates based on new zoom level
	                        scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;
	                        scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel;

	                        // Recompute max scroll values
	                        this.__computeScrollMax(level);
	                    }
	                }

	                if (this.__enableScrollX) {
	                    scrollLeft -= moveX * this.options.speedMultiplier;
	                    var maxScrollLeft = this.__maxScrollLeft;

	                    if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
	                        // Slow down on the edges
	                        if (this.options.bouncing) {
	                            scrollLeft += moveX / 2 * this.options.speedMultiplier;
	                        } else if (scrollLeft > maxScrollLeft) {
	                            scrollLeft = maxScrollLeft;
	                        } else {
	                            scrollLeft = 0;
	                        }
	                    }
	                }

	                // Compute new vertical scroll position
	                if (this.__enableScrollY) {
	                    scrollTop -= moveY * this.options.speedMultiplier;
	                    var maxScrollTop = this.__maxScrollTop;

	                    if (scrollTop > maxScrollTop || scrollTop < 0) {
	                        // Slow down on the edges
	                        if (this.options.bouncing) {
	                            scrollTop += moveY / 2 * this.options.speedMultiplier;
	                        } else if (scrollTop > maxScrollTop) {
	                            scrollTop = maxScrollTop;
	                        } else {
	                            scrollTop = 0;
	                        }
	                    }
	                }

	                // Keep list from growing infinitely (holding min 10, max 20 measure points)
	                if (positions.length > 60) {
	                    positions.splice(0, 30);
	                }

	                // Track scroll movement for decleration
	                positions.push(scrollLeft, scrollTop, timeStamp);

	                // Sync scroll position
	                this.__publish(scrollLeft, scrollTop, level);

	                // Otherwise figure out whether we are switching into dragging mode now.
	            } else {
	                var minimumTrackingForScroll = this.options.locking ? 3 : 0;
	                var minimumTrackingForDrag = 5;

	                var distanceX = Math.abs(currentTouchLeft - this.__initialTouchLeft);
	                var distanceY = Math.abs(currentTouchTop - this.__initialTouchTop);

	                this.__enableScrollX = this.options.scrollingX && distanceX >= minimumTrackingForScroll;
	                this.__enableScrollY = this.options.scrollingY && distanceY >= minimumTrackingForScroll;

	                positions.push(this.__scrollLeft, this.__scrollTop, timeStamp);

	                this.__isDragging = (this.__enableScrollX || this.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
	                if (this.__isDragging) {
	                    this.__interruptedAnimation = false;
	                }
	            }

	            // Update last touch positions and time stamp for next event
	            this.__lastTouchLeft = currentTouchLeft;
	            this.__lastTouchTop = currentTouchTop;
	            this.__lastTouchMove = timeStamp;
	            this.__lastScale = scale;
	        },

	        /**
	         * Touch end handler for scrolling support
	         */
	        doTouchEnd: function doTouchEnd(timeStamp) {
	            if (timeStamp instanceof Date) {
	                timeStamp = timeStamp.valueOf();
	            }
	            if (typeof timeStamp !== "number") {
	                throw new Error("Invalid timestamp value: " + timeStamp);
	            }

	            // Ignore event when tracking is not enabled (no touchstart event on element)
	            // This is required as this listener ('touchmove') sits on the document and not on the element itself.
	            if (!this.__isTracking) {
	                return;
	            }

	            // Not touching anymore (when two finger hit the screen there are two touch end events)
	            this.__isTracking = false;

	            // Be sure to reset the dragging flag now. Here we also detect whether
	            // the finger has moved fast enough to switch into a deceleration animation.
	            if (this.__isDragging) {
	                // Reset dragging flag
	                this.__isDragging = false;

	                // Start deceleration
	                // Verify that the last move detected was in some relevant time frame
	                if (this.__isSingleTouch && this.options.animating && timeStamp - this.__lastTouchMove <= 100) {
	                    // Then figure out what the scroll position was about 100ms ago
	                    var positions = this.__positions;
	                    var endPos = positions.length - 1;
	                    var startPos = endPos;

	                    // Move pointer to position measured 100ms ago
	                    for (var i = endPos; i > 0 && positions[i] > this.__lastTouchMove - 100; i -= 3) {
	                        startPos = i;
	                    }

	                    // If start and stop position is identical in a 100ms timeframe,
	                    // we cannot compute any useful deceleration.
	                    if (startPos !== endPos) {
	                        // Compute relative movement between these two points
	                        var timeOffset = positions[endPos] - positions[startPos];
	                        var movedLeft = this.__scrollLeft - positions[startPos - 2];
	                        var movedTop = this.__scrollTop - positions[startPos - 1];

	                        // Based on 50ms compute the movement to apply for each render step
	                        this.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
	                        this.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);

	                        // How much velocity is required to start the deceleration
	                        var minVelocityToStartDeceleration = this.options.paging || this.options.snapping ? 4 : 1;

	                        // Verify that we have enough velocity to start deceleration
	                        if (Math.abs(this.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(this.__decelerationVelocityY) > minVelocityToStartDeceleration) {
	                            this.__startDeceleration(timeStamp);
	                        }
	                    } else {
	                        this.options.scrollingComplete();
	                    }
	                } else if (timeStamp - this.__lastTouchMove > 100) {
	                    this.options.scrollingComplete();
	                }
	            }

	            // If this was a slower move it is per default non decelerated, but this
	            // still means that we want snap back to the bounds which is done here.
	            // This is placed outside the condition above to improve edge case stability
	            // e.g. touchend fired without enabled dragging. This should normally do not
	            // have modified the scroll positions or even showed the scrollbars though.
	            if (!this.__isDecelerating) {
	                if (this.__interruptedAnimation || this.__isDragging) {
	                    this.options.scrollingComplete();
	                }
	                this.scrollTo(this.__scrollLeft, this.__scrollTop, true, this.__zoomLevel);
	            }

	            // Fully cleanup list
	            this.__positions.length = 0;
	        },

	        /*
	          ---------------------------------------------------------------------------
	          PRIVATE API
	          ---------------------------------------------------------------------------
	        */

	        /**
	         * Applies the scroll position to the content element
	         *
	         * @param left {Number} Left scroll position
	         * @param top {Number} Top scroll position
	         * @param isAnimated {Boolean?false} Whether animation should be used to move to the new coordinates
	         */
	        __publish: function __publish(left, top, zoom, isAnimated) {
	            // Remember whether we had an animation, then we try to continue
	            // based on the current "drive" of the animation.
	            var wasAnimating = this.__isAnimating;
	            if (wasAnimating) {
	                animate.stop(wasAnimating);
	                this.__isAnimating = false;
	            }

	            if (isAnimated && this.options.animating) {
	                // Keep scheduled positions for scrollBy/zoomBy functionality.
	                this.__scheduledLeft = left;
	                this.__scheduledTop = top;
	                this.__scheduledZoom = zoom;

	                var oldLeft = this.__scrollLeft;
	                var oldTop = this.__scrollTop;
	                var oldZoom = this.__zoomLevel;

	                var diffLeft = left - oldLeft;
	                var diffTop = top - oldTop;
	                var diffZoom = zoom - oldZoom;

	                var step = function (percent, now, render) {
	                    if (render) {
	                        this.__scrollLeft = oldLeft + diffLeft * percent;
	                        this.__scrollTop = oldTop + diffTop * percent;
	                        this.__zoomLevel = oldZoom + diffZoom * percent;

	                        // Push values out
	                        if (this.__callback) {
	                            this.__callback(this.__scrollLeft, this.__scrollTop, this.__zoomLevel);
	                        }
	                    }
	                }.bind(this);

	                var verify = function (id) {
	                    return this.__isAnimating === id;
	                }.bind(this);

	                var completed = function (renderedFramesPerSecond, animationId, wasFinished) {
	                    if (animationId === this.__isAnimating) {
	                        this.__isAnimating = false;
	                    }
	                    if (this.__didDecelerationComplete || wasFinished) {
	                        this.options.scrollingComplete();
	                    }

	                    if (this.options.zooming) {
	                        this.__computeScrollMax();
	                        if (this.__zoomComplete) {
	                            this.__zoomComplete();
	                            this.__zoomComplete = null;
	                        }
	                    }
	                }.bind(this);

	                // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out
	                this.__isAnimating = animate.start(step, verify, completed, this.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
	            } else {
	                this.__scheduledLeft = this.__scrollLeft = left;
	                this.__scheduledTop = this.__scrollTop = top;
	                this.__scheduledZoom = this.__zoomLevel = zoom;

	                // Push values out
	                if (this.__callback) {
	                    this.__callback(left, top, zoom);
	                }

	                // Fix max scroll ranges
	                if (this.options.zooming) {
	                    this.__computeScrollMax();
	                    if (this.__zoomComplete) {
	                        this.__zoomComplete();
	                        this.__zoomComplete = null;
	                    }
	                }
	            }
	        },

	        /**
	         * Recomputes scroll minimum values based on client dimensions and content dimensions.
	         */
	        __computeScrollMax: function __computeScrollMax(zoomLevel) {
	            if (zoomLevel === undefined) {
	                zoomLevel = this.__zoomLevel;
	            }

	            this.__maxScrollLeft = Math.max(this.__contentWidth * zoomLevel - this.__clientWidth, 0);
	            this.__maxScrollTop = Math.max(this.__contentHeight * zoomLevel - this.__clientHeight, 0);
	        },

	        /*
	          ---------------------------------------------------------------------------
	          ANIMATION (DECELERATION) SUPPORT
	          ---------------------------------------------------------------------------
	        */

	        /**
	         * Called when a touch sequence end and the speed of the finger was high enough
	         * to switch into deceleration mode.
	         */
	        __startDeceleration: function __startDeceleration(timeStamp) {
	            if (this.options.paging) {
	                var scrollLeft = Math.max(Math.min(this.__scrollLeft, this.__maxScrollLeft), 0);
	                var scrollTop = Math.max(Math.min(this.__scrollTop, this.__maxScrollTop), 0);
	                var clientWidth = this.__clientWidth;
	                var clientHeight = this.__clientHeight;

	                // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.
	                // Each page should have exactly the size of the client area.
	                this.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
	                this.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
	                this.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
	                this.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
	            } else {
	                this.__minDecelerationScrollLeft = 0;
	                this.__minDecelerationScrollTop = 0;
	                this.__maxDecelerationScrollLeft = this.__maxScrollLeft;
	                this.__maxDecelerationScrollTop = this.__maxScrollTop;
	            }

	            // Wrap class method
	            var step = function (percent, now, render) {
	                this.__stepThroughDeceleration(render);
	            }.bind(this);

	            // How much velocity is required to keep the deceleration running
	            var minVelocityToKeepDecelerating = this.options.snapping ? 4 : 0.1;

	            // Detect whether it's still worth to continue animating steps
	            // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.
	            var verify = function () {
	                var shouldContinue = Math.abs(this.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(this.__decelerationVelocityY) >= minVelocityToKeepDecelerating;
	                if (!shouldContinue) {
	                    this.__didDecelerationComplete = true;
	                }
	                return shouldContinue;
	            }.bind(this);

	            var completed = function (renderedFramesPerSecond, animationId, wasFinished) {
	                this.__isDecelerating = false;
	                if (this.__didDecelerationComplete) {
	                    this.options.scrollingComplete();
	                }

	                // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions
	                this.scrollTo(this.__scrollLeft, this.__scrollTop, this.options.snapping);
	            }.bind(this);

	            // Start animation and switch on flag
	            this.__isDecelerating = animate.start(step, verify, completed);
	        },

	        /**
	         * Called on every step of the animation
	         *
	         * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!
	         */
	        __stepThroughDeceleration: function __stepThroughDeceleration(render) {

	            //
	            // COMPUTE NEXT SCROLL POSITION
	            //

	            // Add deceleration to scroll position
	            var scrollLeft = this.__scrollLeft + this.__decelerationVelocityX;
	            var scrollTop = this.__scrollTop + this.__decelerationVelocityY;

	            //
	            // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE
	            //

	            if (!this.options.bouncing) {
	                var scrollLeftFixed = Math.max(Math.min(this.__maxDecelerationScrollLeft, scrollLeft), this.__minDecelerationScrollLeft);
	                if (scrollLeftFixed !== scrollLeft) {
	                    scrollLeft = scrollLeftFixed;
	                    this.__decelerationVelocityX = 0;
	                }

	                var scrollTopFixed = Math.max(Math.min(this.__maxDecelerationScrollTop, scrollTop), this.__minDecelerationScrollTop);
	                if (scrollTopFixed !== scrollTop) {
	                    scrollTop = scrollTopFixed;
	                    this.__decelerationVelocityY = 0;
	                }
	            }

	            //
	            // UPDATE SCROLL POSITION
	            //

	            if (render) {
	                this.__publish(scrollLeft, scrollTop, this.__zoomLevel);
	            } else {
	                this.__scrollLeft = scrollLeft;
	                this.__scrollTop = scrollTop;
	            }

	            //
	            // SLOW DOWN
	            //

	            // Slow down velocity on every iteration
	            if (!this.options.paging) {
	                // This is the factor applied to every iteration of the animation
	                // to slow down the process. This should emulate natural behavior where
	                // objects slow down when the initiator of the movement is removed
	                var frictionFactor = 0.95;

	                this.__decelerationVelocityX *= frictionFactor;
	                this.__decelerationVelocityY *= frictionFactor;
	            }

	            //
	            // BOUNCING SUPPORT
	            //

	            if (this.options.bouncing) {
	                var scrollOutsideX = 0;
	                var scrollOutsideY = 0;

	                // This configures the amount of change applied to deceleration/acceleration when reaching boundaries
	                var penetrationDeceleration = this.options.penetrationDeceleration;
	                var penetrationAcceleration = this.options.penetrationAcceleration;

	                // Check limits
	                if (scrollLeft < this.__minDecelerationScrollLeft) {
	                    scrollOutsideX = this.__minDecelerationScrollLeft - scrollLeft;
	                } else if (scrollLeft > this.__maxDecelerationScrollLeft) {
	                    scrollOutsideX = this.__maxDecelerationScrollLeft - scrollLeft;
	                }

	                if (scrollTop < this.__minDecelerationScrollTop) {
	                    scrollOutsideY = this.__minDecelerationScrollTop - scrollTop;
	                } else if (scrollTop > this.__maxDecelerationScrollTop) {
	                    scrollOutsideY = this.__maxDecelerationScrollTop - scrollTop;
	                }

	                // Slow down until slow enough, then flip back to snap position
	                if (scrollOutsideX !== 0) {
	                    if (scrollOutsideX * this.__decelerationVelocityX <= 0) {
	                        this.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
	                    } else {
	                        this.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
	                    }
	                }

	                if (scrollOutsideY !== 0) {
	                    if (scrollOutsideY * this.__decelerationVelocityY <= 0) {
	                        this.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
	                    } else {
	                        this.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
	                    }
	                }
	            }
	        }
	    };

	    return Scroller;
	});

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var BinaryLoader = function () {
	  /**
	   *
	   * @param url
	   */
	  function BinaryLoader(url) {
	    _classCallCheck(this, BinaryLoader);

	    this._url = url;
	  }

	  /**
	   *
	   * @param opts
	   */


	  _createClass(BinaryLoader, [{
	    key: 'load',
	    value: function load(opts) {
	      if (!opts) {
	        opts = {};
	      }

	      var self = this;
	      var xhr = core.getXMLHttpRequest();
	      var onComplete = function onComplete(resourceLoader, resource) {
	        (opts.onComplete || function () {})(resourceLoader, resource);
	      };
	      var onError = function onError(error, resourceLoader, resource) {
	        var errorMsg = error + ', url: ' + resource.url;
	        (opts.onError || function () {
	          throw errorMsg;
	        })(errorMsg, resourceLoader, resource);
	      };

	      xhr.open('GET', self._url, true);

	      if (xhr.overrideMimeType) {
	        xhr.overrideMimeType('ext/plain; charset=x-user-defined');
	      }
	      xhr.onload = function () {
	        if (+xhr.readyState === 4 && +xhr.status === 200) {
	          onComplete(self._str2Uint8Array(xhr.responseText));
	        } else {
	          onError();
	        }
	      };
	      xhr.send(null);
	    }

	    /**
	     *
	     * @param strData
	     * @return {*}
	     * @private
	     */

	  }, {
	    key: '_str2Uint8Array',
	    value: function _str2Uint8Array(strData) {
	      if (!strData) {
	        return null;
	      }

	      var arrData = new Uint8Array(strData.length);
	      for (var i = 0; i < strData.length; i++) {
	        arrData[i] = strData.charCodeAt(i) & 0xff;
	      }
	      return arrData;
	    }
	  }]);

	  return BinaryLoader;
	}();

	exports.default = BinaryLoader;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Dust is a quick and easy particle effects engine
	 *
	 * @see https://github.com/kittykatattack/dust
	 *
	 * @class
	 * @memberof Tiny
	 */
	var Dust = function () {
	  /**
	   *
	   * @param x
	   * @param y
	   * @param spriteFn
	   * @param container
	   * @param options
	   */
	  function Dust(x, y, spriteFn, container, options) {
	    _classCallCheck(this, Dust);

	    this.x = x || 0;
	    this.y = y || 0;
	    this.spriteFn = spriteFn;
	    this.container = container || new core.Container();

	    if (!spriteFn) {
	      throw new Error('Sprite is needed.');
	    }

	    options = options || {};

	    this.number = options.number || 20;
	    this.gravity = options.gravity || 0;
	    this.randomSpacing = core.isUndefined(options.randomSpacing) ? true : options.randomSpacing;
	    this.minAngle = options.minAngle || 0;
	    this.maxAngle = options.maxAngle || 6.28;
	    this.minSize = options.minSize || 4;
	    this.maxSize = options.maxSize || 16;
	    this.minSpeed = options.minSpeed || 0.3;
	    this.maxSpeed = options.maxSpeed || 3;
	    this.minScaleSpeed = options.minScaleSpeed || 0.01;
	    this.maxScaleSpeed = options.maxScaleSpeed || 0.05;
	    this.minAlphaSpeed = options.minAlphaSpeed || 0.02;
	    this.maxAlphaSpeed = options.maxAlphaSpeed || 0.02;
	    this.minRotationSpeed = options.minRotationSpeed || 0.01;
	    this.maxRotationSpeed = options.maxRotationSpeed || 0.03;

	    //An array to store the curent batch of particles
	    this.particles = [];

	    //An array to store the angles
	    this.angles = [];

	    var self = this;
	    //A variable to store the current particle's angle
	    var angle = void 0;

	    //Figure out by how many radians each particle should be separated
	    var spacing = (this.maxAngle - this.minAngle) / (this.number - 1);

	    //Add the current `particles` array to the `globalParticles` array
	    Dust.globalParticles.push(this.particles);

	    //Create an angle value for each particle and push that //value into the `angles` array
	    for (var i = 0; i < this.number; i++) {
	      //If `randomSpacing` is `true`, give the particle any angle
	      //value between `minAngle` and `maxAngle`
	      if (this.randomSpacing) {
	        angle = core.randomFloat(this.minAngle, this.maxAngle);
	        this.angles.push(angle);
	      } else {
	        //If `randomSpacing` is `false`, space each particle evenly,
	        //starting with the `minAngle` and ending with the `maxAngle`
	        if (angle === undefined) {
	          angle = this.minAngle;
	        }
	        this.angles.push(angle);
	        angle += spacing;
	      }
	    }

	    //Make a particle for each angle
	    this.angles.forEach(function (angle) {
	      return self.makeParticle(angle);
	    });
	  }

	  _createClass(Dust, [{
	    key: 'makeParticle',
	    value: function makeParticle(angle) {
	      //Create the particle using the supplied sprite function
	      var particle = this.spriteFn();
	      var gravity = this.gravity;
	      var particles = this.particles;
	      var container = this.container;

	      //Display a random frame if the particle has more than 1 frame
	      if (particle.totalFrames > 0) {
	        particle.gotoAndStop(core.randomInt(0, particle.totalFrames - 1));
	      }

	      //Set a random width and height
	      var size = core.randomInt(this.minSize, this.maxSize);
	      particle.width = size;
	      particle.height = size;

	      //Set the particle's `anchor` to its center
	      //particle.anchor.set(0.5, 0.5);

	      //Set the x and y position
	      particle.x = this.x;
	      particle.y = this.y;

	      //Set a random speed to change the scale, alpha and rotation
	      particle.scaleSpeed = core.randomFloat(this.minScaleSpeed, this.maxScaleSpeed);
	      particle.alphaSpeed = core.randomFloat(this.minAlphaSpeed, this.maxAlphaSpeed);
	      particle.rotationSpeed = core.randomFloat(this.minRotationSpeed, this.maxRotationSpeed);

	      //Set a random velocity at which the particle should move
	      var speed = core.randomFloat(this.minSpeed, this.maxSpeed);
	      particle.vx = speed * Math.cos(angle);
	      particle.vy = speed * Math.sin(angle);

	      //Push the particle into the `particles` array.
	      //The `particles` array needs to be updated by the game loop each frame particles.push(particle);
	      particles.push(particle);

	      //Add the particle to its parent container
	      container.addChild(particle);

	      //The particle's `updateParticle` method is called on each frame of the
	      //game loop
	      particle.updateParticle = function () {
	        //Add gravity
	        particle.vy += gravity;

	        //Move the particle
	        particle.x += particle.vx;
	        particle.y += particle.vy;

	        //Change the particle's `scale`
	        if (particle.scale.x - particle.scaleSpeed > 0) {
	          particle.scale.x -= particle.scaleSpeed;
	        }
	        if (particle.scale.y - particle.scaleSpeed > 0) {
	          particle.scale.y -= particle.scaleSpeed;
	        }

	        //Change the particle's rotation
	        particle.rotation += particle.rotationSpeed;

	        //Change the particle's `alpha`
	        particle.alpha -= particle.alphaSpeed;

	        //Remove the particle if its `alpha` reaches zero
	        if (particle.alpha <= 0) {
	          container.removeChild(particle);
	          particles.splice(particles.indexOf(particle), 1);
	        }
	      };
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      //Check so see if the `globalParticles` array contains any
	      //sub-arrays
	      if (Dust.globalParticles.length > 0) {
	        //If it does, Loop through the particle arrays in reverse
	        for (var i = Dust.globalParticles.length - 1; i >= 0; i--) {
	          //Get the current particle sub-array
	          var particles = Dust.globalParticles[i];

	          //Loop through the `particles` sub-array and update the
	          //all the particle sprites that it contains
	          if (particles.length > 0) {
	            for (var j = particles.length - 1; j >= 0; j--) {
	              var particle = particles[j];
	              particle.updateParticle();
	            }
	          } else {
	            //Remove the particle array from the `globalParticles` array if doesn't
	            //contain any more sprites
	            Dust.globalParticles.splice(Dust.globalParticles.indexOf(particles), 1);
	          }
	        }
	      }
	    }
	  }]);

	  return Dust;
	}();

	exports.default = Dust;


	Dust.globalParticles = [];

/***/ }),
/* 153 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @class
	 * @memberof Tiny
	 */
	var KeyboardManager =
	/**
	 *
	 * @param keyCode
	 * @return {{}}
	 */
	function KeyboardManager(keyCode) {
	  _classCallCheck(this, KeyboardManager);

	  var key = {};
	  key.code = keyCode;
	  key.isDown = false;
	  key.isUp = true;
	  key.press = undefined;
	  key.release = undefined;
	  //The `downHandler`
	  key.downHandler = function (event) {
	    if (event.keyCode === key.code) {
	      if (key.isUp && key.press) key.press();
	      key.isDown = true;
	      key.isUp = false;
	    }
	    event.preventDefault();
	  };

	  //The `upHandler`
	  key.upHandler = function (event) {
	    if (event.keyCode === key.code) {
	      if (key.isDown && key.release) key.release();
	      key.isDown = false;
	      key.isUp = true;
	    }
	    event.preventDefault();
	  };

	  //Attach event listeners
	  window.addEventListener('keydown', key.downHandler.bind(key), false);
	  window.addEventListener('keyup', key.upHandler.bind(key), false);
	  return key;
	};

	exports.default = KeyboardManager;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DisplayObject = core.DisplayObject;
	var _tempMatrix = new core.Matrix();

	DisplayObject.prototype._cacheAsBitmap = false;
	DisplayObject.prototype._cacheData = false;

	// figured theres no point adding ALL the extra variables to prototype.
	// this model can hold the information needed. This can also be generated on demand as
	// most objects are not cached as bitmaps.
	/**
	 * @class
	 * @ignore
	 */

	var CacheData =
	/**
	 *
	 */
	function CacheData() {
	  _classCallCheck(this, CacheData);

	  this.originalRenderWebGL = null;
	  this.originalRenderCanvas = null;
	  this.originalCalculateBounds = null;
	  this.originalGetLocalBounds = null;

	  this.originalUpdateTransform = null;
	  this.originalHitTest = null;
	  this.originalDestroy = null;
	  this.originalMask = null;
	  this.originalFilterArea = null;
	  this.sprite = null;
	};

	Object.defineProperties(DisplayObject.prototype, {
	  /**
	   * Set this to true if you want this display object to be cached as a bitmap.
	   * This basically takes a snap shot of the display object as it is at that moment. It can
	   * provide a performance benefit for complex static displayObjects.
	   * To remove simply set this property to 'false'
	   *
	   * @member {boolean}
	   * @memberof Tiny.DisplayObject#
	   */
	  cacheAsBitmap: {
	    get: function get() {
	      return this._cacheAsBitmap;
	    },
	    set: function set(value) {
	      if (this._cacheAsBitmap === value) {
	        return;
	      }

	      this._cacheAsBitmap = value;

	      var data = void 0;

	      if (value) {
	        if (!this._cacheData) {
	          this._cacheData = new CacheData();
	        }

	        data = this._cacheData;

	        data.originalRenderWebGL = this.renderWebGL;
	        data.originalRenderCanvas = this.renderCanvas;

	        data.originalUpdateTransform = this.updateTransform;
	        data.originalCalculateBounds = this._calculateBounds;
	        data.originalGetLocalBounds = this.getLocalBounds;

	        data.originalDestroy = this.destroy;

	        data.originalContainsPoint = this.containsPoint;

	        data.originalMask = this._mask;
	        data.originalFilterArea = this.filterArea;

	        this.renderWebGL = this._renderCachedWebGL;
	        this.renderCanvas = this._renderCachedCanvas;

	        this.destroy = this._cacheAsBitmapDestroy;
	      } else {
	        data = this._cacheData;

	        if (data.sprite) {
	          this._destroyCachedDisplayObject();
	        }

	        this.renderWebGL = data.originalRenderWebGL;
	        this.renderCanvas = data.originalRenderCanvas;
	        this._calculateBounds = data.originalCalculateBounds;
	        this.getLocalBounds = data.originalGetLocalBounds;

	        this.destroy = data.originalDestroy;

	        this.updateTransform = data.originalUpdateTransform;
	        this.containsPoint = data.originalContainsPoint;

	        this._mask = data.originalMask;
	        this.filterArea = data.originalFilterArea;
	      }
	    }
	  }
	});

	/**
	 * Renders a cached version of the sprite with WebGL
	 *
	 * @private
	 * @memberof Tiny.DisplayObject#
	 * @param {Tiny.WebGLRenderer} renderer - the WebGL renderer
	 */
	DisplayObject.prototype._renderCachedWebGL = function _renderCachedWebGL(renderer) {
	  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
	    return;
	  }

	  this._initCachedDisplayObject(renderer);

	  this._cacheData.sprite._transformID = -1;
	  this._cacheData.sprite.worldAlpha = this.worldAlpha;
	  this._cacheData.sprite._renderWebGL(renderer);
	};

	/**
	 * Prepares the WebGL renderer to cache the sprite
	 *
	 * @private
	 * @memberof Tiny.DisplayObject#
	 * @param {Tiny.WebGLRenderer} renderer - the WebGL renderer
	 */
	DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
	  if (this._cacheData && this._cacheData.sprite) {
	    return;
	  }

	  // make sure alpha is set to 1 otherwise it will get rendered as invisible!
	  var cacheAlpha = this.alpha;

	  this.alpha = 1;

	  // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
	  renderer.currentRenderer.flush();
	  // this.filters= [];

	  // next we find the dimensions of the untransformed object
	  // this function also calls updatetransform on all its children as part of the measuring.
	  // This means we don't need to update the transform again in this function
	  // TODO pass an object to clone too? saves having to create a new one each time!
	  var bounds = this.getLocalBounds().clone();

	  // add some padding!
	  if (this._filters) {
	    var padding = this._filters[0].padding;

	    bounds.pad(padding);
	  }

	  // for now we cache the current renderTarget that the webGL renderer is currently using.
	  // this could be more elegent..
	  var cachedRenderTarget = renderer._activeRenderTarget;
	  // We also store the filter stack - I will definitely look to change how this works a little later down the line.
	  var stack = renderer.filterManager.filterStack;

	  // this renderTexture will be used to store the cached DisplayObject

	  var renderTexture = core.RenderTexture.create(bounds.width | 0, bounds.height | 0);

	  // need to set //
	  var m = _tempMatrix;

	  m.tx = -bounds.x;
	  m.ty = -bounds.y;

	  // reset
	  this.transform.worldTransform.identity();

	  // set all properties to there original so we can render to a texture
	  this.renderWebGL = this._cacheData.originalRenderWebGL;

	  renderer.render(this, renderTexture, true, m, true);
	  // now restore the state be setting the new properties

	  renderer.bindRenderTarget(cachedRenderTarget);

	  renderer.filterManager.filterStack = stack;

	  this.renderWebGL = this._renderCachedWebGL;
	  this.updateTransform = this.displayObjectUpdateTransform;

	  this._mask = null;
	  this.filterArea = null;

	  // create our cached sprite
	  var cachedSprite = new core.Sprite(renderTexture);

	  cachedSprite.transform.worldTransform = this.transform.worldTransform;
	  cachedSprite.anchor.x = -(bounds.x / bounds.width);
	  cachedSprite.anchor.y = -(bounds.y / bounds.height);
	  cachedSprite.alpha = cacheAlpha;
	  cachedSprite._bounds = this._bounds;

	  // easy bounds..
	  this._calculateBounds = this._calculateCachedBounds;
	  this.getLocalBounds = this._getCachedLocalBounds;

	  this._cacheData.sprite = cachedSprite;

	  this.transform._parentID = -1;
	  // restore the transform of the cached sprite to avoid the nasty flicker..
	  this.updateTransform();

	  // map the hit test..
	  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
	};

	/**
	 * Renders a cached version of the sprite with canvas
	 *
	 * @private
	 * @memberof Tiny.DisplayObject#
	 * @param {Tiny.WebGLRenderer} renderer - the WebGL renderer
	 */
	DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
	  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
	    return;
	  }

	  this._initCachedDisplayObjectCanvas(renderer);

	  this._cacheData.sprite.worldAlpha = this.worldAlpha;

	  this._cacheData.sprite.renderCanvas(renderer);
	};

	// TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
	/**
	 * Prepares the Canvas renderer to cache the sprite
	 *
	 * @private
	 * @memberof Tiny.DisplayObject#
	 * @param {Tiny.WebGLRenderer} renderer - the WebGL renderer
	 */
	DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
	  if (this._cacheData && this._cacheData.sprite) {
	    return;
	  }

	  // get bounds actually transforms the object for us already!
	  var bounds = this.getLocalBounds();

	  var cacheAlpha = this.alpha;

	  this.alpha = 1;

	  var cachedRenderTarget = renderer.context;

	  var renderTexture = core.RenderTexture.create(bounds.width | 0, bounds.height | 0);

	  // need to set //
	  var m = _tempMatrix;

	  this.transform.localTransform.copy(m);
	  m.invert();

	  m.tx -= bounds.x;
	  m.ty -= bounds.y;

	  // m.append(this.transform.worldTransform.)
	  // set all properties to there original so we can render to a texture
	  this.renderCanvas = this._cacheData.originalRenderCanvas;

	  // renderTexture.render(this, m, true);
	  renderer.render(this, renderTexture, true, m, false);

	  // now restore the state be setting the new properties
	  renderer.context = cachedRenderTarget;

	  this.renderCanvas = this._renderCachedCanvas;
	  this._calculateBounds = this._calculateCachedBounds;

	  this._mask = null;
	  this.filterArea = null;

	  // create our cached sprite
	  var cachedSprite = new core.Sprite(renderTexture);

	  cachedSprite.transform.worldTransform = this.transform.worldTransform;
	  cachedSprite.anchor.x = -(bounds.x / bounds.width);
	  cachedSprite.anchor.y = -(bounds.y / bounds.height);
	  cachedSprite._bounds = this._bounds;
	  cachedSprite.alpha = cacheAlpha;

	  this.updateTransform();
	  this.updateTransform = this.displayObjectUpdateTransform;

	  this._cacheData.sprite = cachedSprite;

	  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
	};

	/**
	 * Calculates the bounds of the cached sprite
	 *
	 * @private
	 */
	DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
	  this._cacheData.sprite._calculateBounds();
	};

	/**
	 * Gets the bounds of the cached sprite.
	 *
	 * @private
	 * @return {Rectangle} The local bounds.
	 */
	DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
	  return this._cacheData.sprite.getLocalBounds();
	};

	/**
	 * Destroys the cached sprite.
	 *
	 * @private
	 */
	DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
	  this._cacheData.sprite._texture.destroy(true);
	  this._cacheData.sprite = null;
	};

	/**
	 * Destroys the cached object.
	 *
	 * @private
	 */
	DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy() {
	  this.cacheAsBitmap = false;
	  this.destroy();
	};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * The instance name of the object.
	 *
	 * @memberof Tiny.DisplayObject#
	 * @member {string}
	 */
	core.DisplayObject.prototype.name = null;

	/**
	 * Returns the display object in the container
	 *
	 * @memberof Tiny.Container#
	 * @param {string} name - instance name
	 * @return {Tiny.DisplayObject} The child with the specified name.
	 */
	core.Container.prototype.getChildByName = function getChildByName(name) {
	  for (var i = 0; i < this.children.length; i++) {
	    if (this.children[i].name === name) {
	      return this.children[i];
	    }
	  }

	  return null;
	};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
	 *
	 * @memberof Tiny.DisplayObject#
	 * @param {Tiny.Point} point - the point to write the global value to. If null a new point will be returned
	 * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
	 *  being updated. This means the calculation returned MAY be out of date BUT will give you a
	 *  nice performance boost
	 * @return {Tiny.Point} The updated point
	 */
	core.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition() {
	  var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new core.Point();
	  var skipUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (this.parent) {
	    this.parent.toGlobal(this.position, point, skipUpdate);
	  } else {
	    point.x = this.position.x;
	    point.y = this.position.y;
	  }

	  return point;
	};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.use = use;

	var _core = __webpack_require__(6);

	var _WebGLExtract = __webpack_require__(158);

	var _WebGLExtract2 = _interopRequireDefault(_WebGLExtract);

	var _CanvasExtract = __webpack_require__(159);

	var _CanvasExtract2 = _interopRequireDefault(_CanvasExtract);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function use(renderer) {
	  if ((0, _core.isWebGLSupported)()) {
	    if (_core.config.renderType !== _core.RENDERER_TYPE.CANVAS) {
	      return new _WebGLExtract2.default(renderer);
	    }
	  }
	  return new _CanvasExtract2.default(renderer);
	}

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TEMP_RECT = new core.Rectangle();
	var BYTES_PER_PIXEL = 4;

	/**
	 * The extract manager provides functionality to export content from the renderers.
	 *
	 * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
	 *
	 * @class
	 * @memberof Tiny
	 */

	var WebGLExtract = function () {
	  /**
	   * @param {Tiny.WebGLRenderer} renderer - A reference to the current renderer
	   */
	  function WebGLExtract(renderer) {
	    _classCallCheck(this, WebGLExtract);

	    this.renderer = renderer;
	    /**
	     * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
	     *
	     * @member {Tiny.WebGLExtract} extract
	     * @memberof Tiny.WebGLRenderer#
	     * @see Tiny.WebGLExtract
	     */
	    renderer.extract = this;
	  }

	  /**
	   * Will return a HTML Image of the target
	   *
	   * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	   *  to convert. If left empty will use use the main renderer
	   * @return {HTMLImageElement} HTML Image of the target
	   */


	  _createClass(WebGLExtract, [{
	    key: 'image',
	    value: function image(target) {
	      var image = new Image();

	      image.src = this.base64(target);

	      return image;
	    }

	    /**
	     * Will return a a base64 encoded string of this target. It works by calling
	     *  `WebGLExtract.getCanvas` and then running toDataURL on that.
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {string} A base64 encoded string of the texture.
	     */

	  }, {
	    key: 'base64',
	    value: function base64(target) {
	      return this.canvas(target).toDataURL();
	    }

	    /**
	     * Creates a Canvas element, renders this target to it and then returns it.
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
	     */

	  }, {
	    key: 'canvas',
	    value: function canvas(target) {
	      var renderer = this.renderer;
	      var textureBuffer = void 0;
	      var resolution = void 0;
	      var frame = void 0;
	      var flipY = false;
	      var renderTexture = void 0;

	      if (target) {
	        if (target instanceof core.RenderTexture) {
	          renderTexture = target;
	        } else {
	          renderTexture = this.renderer.generateTexture(target);
	        }
	      }

	      if (renderTexture) {
	        textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
	        resolution = textureBuffer.resolution;
	        frame = renderTexture.frame;
	        flipY = false;
	      } else {
	        textureBuffer = this.renderer.rootRenderTarget;
	        resolution = textureBuffer.resolution;
	        flipY = true;

	        frame = TEMP_RECT;
	        frame.width = textureBuffer.size.width;
	        frame.height = textureBuffer.size.height;
	      }

	      var width = frame.width * resolution;
	      var height = frame.height * resolution;

	      var canvasBuffer = new core.CanvasRenderTarget(width, height);

	      if (textureBuffer) {
	        // bind the buffer
	        renderer.bindRenderTarget(textureBuffer);

	        // set up an array of pixels
	        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

	        // read pixels to the array
	        var gl = renderer.gl;

	        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);

	        // add the pixels to the canvas
	        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);

	        canvasData.data.set(webglPixels);

	        canvasBuffer.context.putImageData(canvasData, 0, 0);

	        // pulling pixels
	        if (flipY) {
	          canvasBuffer.context.scale(1, -1);
	          canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
	        }
	      }

	      // send the canvas back..
	      return canvasBuffer.canvas;
	    }

	    /**
	     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
	     * order, with integer values between 0 and 255 (included).
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
	     */

	  }, {
	    key: 'pixels',
	    value: function pixels(target) {
	      var renderer = this.renderer;
	      var textureBuffer = void 0;
	      var resolution = void 0;
	      var frame = void 0;
	      var renderTexture = void 0;

	      if (target) {
	        if (target instanceof core.RenderTexture) {
	          renderTexture = target;
	        } else {
	          renderTexture = this.renderer.generateTexture(target);
	        }
	      }

	      if (renderTexture) {
	        textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
	        resolution = textureBuffer.resolution;
	        frame = renderTexture.frame;
	      } else {
	        textureBuffer = this.renderer.rootRenderTarget;
	        resolution = textureBuffer.resolution;

	        frame = TEMP_RECT;
	        frame.width = textureBuffer.size.width;
	        frame.height = textureBuffer.size.height;
	      }

	      var width = frame.width * resolution;
	      var height = frame.height * resolution;

	      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

	      if (textureBuffer) {
	        // bind the buffer
	        renderer.bindRenderTarget(textureBuffer);
	        // read pixels to the array
	        var gl = renderer.gl;

	        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
	      }

	      return webglPixels;
	    }

	    /**
	     * Destroys the extract
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.renderer.extract = null;
	      this.renderer = null;
	    }
	  }]);

	  return WebGLExtract;
	}();

	exports.default = WebGLExtract;


	core.WebGLRenderer.registerPlugin('extract', WebGLExtract);

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TEMP_RECT = new core.Rectangle();

	/**
	 * The extract manager provides functionality to export content from the renderers.
	 *
	 * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract
	 *
	 * @class
	 * @memberof Tiny
	 */

	var CanvasExtract = function () {
	  /**
	   * @param {Tiny.CanvasRenderer} renderer - A reference to the current renderer
	   */
	  function CanvasExtract(renderer) {
	    _classCallCheck(this, CanvasExtract);

	    this.renderer = renderer;
	    /**
	     * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
	     *
	     * @member {Tiny.CanvasExtract} extract
	     * @memberof Tiny.CanvasRenderer#
	     * @see Tiny.CanvasExtract
	     */
	    renderer.extract = this;
	  }

	  /**
	   * Will return a HTML Image of the target
	   *
	   * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	   *  to convert. If left empty will use use the main renderer
	   * @return {HTMLImageElement} HTML Image of the target
	   */


	  _createClass(CanvasExtract, [{
	    key: 'image',
	    value: function image(target) {
	      var image = new Image();

	      image.src = this.base64(target);

	      return image;
	    }

	    /**
	     * Will return a a base64 encoded string of this target. It works by calling
	     *  `CanvasExtract.getCanvas` and then running toDataURL on that.
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {string} A base64 encoded string of the texture.
	     */

	  }, {
	    key: 'base64',
	    value: function base64(target) {
	      return this.canvas(target).toDataURL();
	    }

	    /**
	     * Creates a Canvas element, renders this target to it and then returns it.
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
	     */

	  }, {
	    key: 'canvas',
	    value: function canvas(target) {
	      var renderer = this.renderer;
	      var context = void 0;
	      var resolution = void 0;
	      var frame = void 0;
	      var renderTexture = void 0;

	      if (target) {
	        if (target instanceof core.RenderTexture) {
	          renderTexture = target;
	        } else {
	          renderTexture = renderer.generateTexture(target);
	        }
	      }

	      if (renderTexture) {
	        context = renderTexture.baseTexture._canvasRenderTarget.context;
	        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
	        frame = renderTexture.frame;
	      } else {
	        context = renderer.rootContext;

	        frame = TEMP_RECT;
	        frame.width = this.renderer.width;
	        frame.height = this.renderer.height;
	      }

	      var width = frame.width * resolution;
	      var height = frame.height * resolution;

	      var canvasBuffer = new core.CanvasRenderTarget(width, height);
	      var canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);

	      canvasBuffer.context.putImageData(canvasData, 0, 0);

	      // send the canvas back..
	      return canvasBuffer.canvas;
	    }

	    /**
	     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
	     * order, with integer values between 0 and 255 (included).
	     *
	     * @param {Tiny.DisplayObject|Tiny.RenderTexture} target - A displayObject or renderTexture
	     *  to convert. If left empty will use use the main renderer
	     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
	     */

	  }, {
	    key: 'pixels',
	    value: function pixels(target) {
	      var renderer = this.renderer;
	      var context = void 0;
	      var resolution = void 0;
	      var frame = void 0;
	      var renderTexture = void 0;

	      if (target) {
	        if (target instanceof core.RenderTexture) {
	          renderTexture = target;
	        } else {
	          renderTexture = renderer.generateTexture(target);
	        }
	      }

	      if (renderTexture) {
	        context = renderTexture.baseTexture._canvasRenderTarget.context;
	        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
	        frame = renderTexture.frame;
	      } else {
	        context = renderer.rootContext;

	        frame = TEMP_RECT;
	        frame.width = renderer.width;
	        frame.height = renderer.height;
	      }

	      return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;
	    }

	    /**
	     * Destroys the extract
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.renderer.extract = null;
	      this.renderer = null;
	    }
	  }]);

	  return CanvasExtract;
	}();

	exports.default = CanvasExtract;


	core.CanvasRenderer.registerPlugin('extract', CanvasExtract);

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ParticleContainer = __webpack_require__(161);

	Object.defineProperty(exports, 'ParticleContainer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ParticleContainer).default;
	  }
	});

	var _ParticleRenderer = __webpack_require__(162);

	Object.defineProperty(exports, 'ParticleRenderer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ParticleRenderer).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The ParticleContainer class is a really fast version of the Container built solely for speed,
	 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
	 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
	 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
	 *
	 * It's extremely easy to use :
	 *
	 * ```js
	 * let container = new ParticleContainer();
	 *
	 * for (let i = 0; i < 100; ++i)
	 * {
	 *     let sprite = new Tiny.Sprite.fromImage("myImage.png");
	 *     container.addChild(sprite);
	 * }
	 * ```
	 *
	 * And here you have a hundred sprites that will be renderer at the speed of light.
	 *
	 * @class
	 * @extends Tiny.Container
	 * @memberof Tiny.particles
	 */
	var ParticleContainer = function (_core$Container) {
	  _inherits(ParticleContainer, _core$Container);

	  /**
	   * @param {number} [maxSize=15000] - The maximum number of particles that can be renderer by the container.
	   * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.
	   * @param {boolean} [properties.scale=false] - When true, scale be uploaded and applied.
	   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.
	   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.
	   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.
	   * @param {boolean} [properties.alpha=false] - When true, alpha be uploaded and applied.
	   * @param {number} [batchSize=15000] - Number of particles per batch.
	   */
	  function ParticleContainer() {
	    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;
	    var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;

	    _classCallCheck(this, ParticleContainer);

	    // Making sure the batch size is valid
	    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
	    // so max number of particles is 65536 / 4 = 16384
	    var _this = _possibleConstructorReturn(this, (ParticleContainer.__proto__ || Object.getPrototypeOf(ParticleContainer)).call(this));

	    var maxBatchSize = 16384;

	    if (batchSize > maxBatchSize) {
	      batchSize = maxBatchSize;
	    }

	    if (batchSize > maxSize) {
	      batchSize = maxSize;
	    }

	    /**
	     * Set properties to be dynamic (true) / static (false)
	     *
	     * @member {boolean[]}
	     * @private
	     */
	    _this._properties = [false, true, false, false, false];

	    /**
	     * @member {number}
	     * @private
	     */
	    _this._maxSize = maxSize;

	    /**
	     * @member {number}
	     * @private
	     */
	    _this._batchSize = batchSize;

	    /**
	     * @member {object<number, WebGLBuffer>}
	     * @private
	     */
	    _this._glBuffers = {};

	    /**
	     * @member {number}
	     * @private
	     */
	    _this._bufferToUpdate = 0;

	    /**
	     * @member {boolean}
	     *
	     */
	    _this.interactiveChildren = false;

	    /**
	     * The blend mode to be applied to the sprite. Apply a value of `Tiny.BLEND_MODES.NORMAL`
	     * to reset the blend mode.
	     *
	     * @member {number}
	     * @default Tiny.BLEND_MODES.NORMAL
	     * @see Tiny.BLEND_MODES
	     */
	    _this.blendMode = core.BLEND_MODES.NORMAL;

	    /**
	     * Used for canvas renderering. If true then the elements will be positioned at the
	     * nearest pixel. This provides a nice speed boost.
	     *
	     * @member {boolean}
	     * @default true;
	     */
	    _this.roundPixels = true;

	    /**
	     * The texture used to render the children.
	     *
	     * @readonly
	     * @member {BaseTexture}
	     */
	    _this.baseTexture = null;

	    _this.setProperties(properties);
	    return _this;
	  }

	  /**
	   * Sets the private properties array to dynamic / static based on the passed properties object
	   *
	   * @param {object} properties - The properties to be uploaded
	   */


	  _createClass(ParticleContainer, [{
	    key: 'setProperties',
	    value: function setProperties(properties) {
	      if (properties) {
	        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
	        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
	        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
	        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
	        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
	      }
	    }

	    /**
	     * Updates the object transform for rendering
	     *
	     * @private
	     */

	  }, {
	    key: 'updateTransform',
	    value: function updateTransform() {
	      // TODO don't need to!
	      this.displayObjectUpdateTransform();
	      //  Tiny.Container.prototype.updateTransform.call( this );
	    }

	    /**
	     * Renders the container using the WebGL renderer
	     *
	     * @private
	     * @param {Tiny.WebGLRenderer} renderer - The webgl renderer
	     */

	  }, {
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      var _this2 = this;

	      if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
	        return;
	      }

	      if (!this.baseTexture) {
	        this.baseTexture = this.children[0]._texture.baseTexture;
	        if (!this.baseTexture.hasLoaded) {
	          this.baseTexture.once('update', function () {
	            return _this2.onChildrenChange(0);
	          });
	        }
	      }

	      renderer.setObjectRenderer(renderer.plugins.particle);
	      renderer.plugins.particle.render(this);
	    }

	    /**
	     * Set the flag that static data should be updated to true
	     *
	     * @private
	     * @param {number} smallestChildIndex - The smallest child index
	     */

	  }, {
	    key: 'onChildrenChange',
	    value: function onChildrenChange(smallestChildIndex) {
	      var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);

	      if (bufferIndex < this._bufferToUpdate) {
	        this._bufferToUpdate = bufferIndex;
	      }
	    }

	    /**
	     * Renders the object using the Canvas renderer
	     *
	     * @private
	     * @param {Tiny.CanvasRenderer} renderer - The canvas renderer
	     */

	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
	        return;
	      }

	      var context = renderer.context;
	      var transform = this.worldTransform;
	      var isRotated = true;

	      var positionX = 0;
	      var positionY = 0;

	      var finalWidth = 0;
	      var finalHeight = 0;

	      var compositeOperation = renderer.blendModes[this.blendMode];

	      if (compositeOperation !== context.globalCompositeOperation) {
	        context.globalCompositeOperation = compositeOperation;
	      }

	      context.globalAlpha = this.worldAlpha;

	      this.displayObjectUpdateTransform();

	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i];

	        if (!child.visible) {
	          continue;
	        }

	        var frame = child._texture.frame;

	        context.globalAlpha = this.worldAlpha * child.alpha;

	        if (child.rotation % (Math.PI * 2) === 0) {
	          // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
	          if (isRotated) {
	            context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * renderer.resolution, transform.ty * renderer.resolution);

	            isRotated = false;
	          }

	          positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;
	          positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;

	          finalWidth = frame.width * child.scale.x;
	          finalHeight = frame.height * child.scale.y;
	        } else {
	          if (!isRotated) {
	            isRotated = true;
	          }

	          child.displayObjectUpdateTransform();

	          var childTransform = child.worldTransform;

	          if (renderer.roundPixels) {
	            context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution | 0, childTransform.ty * renderer.resolution | 0);
	          } else {
	            context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution, childTransform.ty * renderer.resolution);
	          }

	          positionX = child.anchor.x * -frame.width + 0.5;
	          positionY = child.anchor.y * -frame.height + 0.5;

	          finalWidth = frame.width;
	          finalHeight = frame.height;
	        }

	        var resolution = child._texture.baseTexture.resolution;

	        context.drawImage(child._texture.baseTexture.source, frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * resolution, positionY * resolution, finalWidth * resolution, finalHeight * resolution);
	      }
	    }

	    /**
	     * Destroys the container
	     *
	     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
	     *  have been set to that value
	     * @param {boolean} [options.children=false] - if set to true, all the children will have their
	     *  destroy method called as well. 'options' will be passed on to those calls.
	     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the texture of the child sprite
	     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
	     *  Should it destroy the base texture of the child sprite
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy(options) {
	      _get(ParticleContainer.prototype.__proto__ || Object.getPrototypeOf(ParticleContainer.prototype), 'destroy', this).call(this, options);

	      if (this._buffers) {
	        for (var i = 0; i < this._buffers.length; ++i) {
	          this._buffers[i].destroy();
	        }
	      }

	      this._properties = null;
	      this._buffers = null;
	    }
	  }]);

	  return ParticleContainer;
	}(core.Container);

	exports.default = ParticleContainer;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _ParticleShader = __webpack_require__(163);

	var _ParticleShader2 = _interopRequireDefault(_ParticleShader);

	var _ParticleBuffer = __webpack_require__(164);

	var _ParticleBuffer2 = _interopRequireDefault(_ParticleBuffer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
	 * share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's ParticleRenderer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
	 */

	/**
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */
	var ParticleRenderer = function (_core$ObjectRenderer) {
	  _inherits(ParticleRenderer, _core$ObjectRenderer);

	  /**
	   * @param {Tiny.WebGLRenderer} renderer - The renderer this sprite batch works for.
	   */
	  function ParticleRenderer(renderer) {
	    _classCallCheck(this, ParticleRenderer);

	    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
	    // so max number of particles is 65536 / 4 = 16384
	    // and max number of element in the index buffer is 16384 * 6 = 98304
	    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
	    // let numIndices = 98304;

	    /**
	     * The default shader that is used if a sprite doesn't have a more specific one.
	     *
	     * @member {Tiny.Shader}
	     */
	    var _this = _possibleConstructorReturn(this, (ParticleRenderer.__proto__ || Object.getPrototypeOf(ParticleRenderer)).call(this, renderer));

	    _this.shader = null;

	    _this.indexBuffer = null;

	    _this.properties = null;

	    _this.tempMatrix = new core.Matrix();

	    _this.CONTEXT_UID = 0;
	    return _this;
	  }

	  /**
	   * When there is a WebGL context change
	   *
	   * @private
	   */


	  _createClass(ParticleRenderer, [{
	    key: 'onContextChange',
	    value: function onContextChange() {
	      var gl = this.renderer.gl;

	      this.CONTEXT_UID = this.renderer.CONTEXT_UID;

	      // setup default shader
	      this.shader = new _ParticleShader2.default(gl);

	      this.properties = [
	      // verticesData
	      {
	        attribute: this.shader.attributes.aVertexPosition,
	        size: 2,
	        uploadFunction: this.uploadVertices,
	        offset: 0
	      },
	      // positionData
	      {
	        attribute: this.shader.attributes.aPositionCoord,
	        size: 2,
	        uploadFunction: this.uploadPosition,
	        offset: 0
	      },
	      // rotationData
	      {
	        attribute: this.shader.attributes.aRotation,
	        size: 1,
	        uploadFunction: this.uploadRotation,
	        offset: 0
	      },
	      // uvsData
	      {
	        attribute: this.shader.attributes.aTextureCoord,
	        size: 2,
	        uploadFunction: this.uploadUvs,
	        offset: 0
	      },
	      // alphaData
	      {
	        attribute: this.shader.attributes.aColor,
	        size: 1,
	        uploadFunction: this.uploadAlpha,
	        offset: 0
	      }];
	    }

	    /**
	     * Starts a new particle batch.
	     *
	     */

	  }, {
	    key: 'start',
	    value: function start() {
	      this.renderer.bindShader(this.shader);
	    }

	    /**
	     * Renders the particle container object.
	     *
	     * @param {Tiny.ParticleContainer} container - The container to render using this ParticleRenderer
	     */

	  }, {
	    key: 'render',
	    value: function render(container) {
	      var children = container.children;
	      var maxSize = container._maxSize;
	      var batchSize = container._batchSize;
	      var renderer = this.renderer;
	      var totalChildren = children.length;

	      if (totalChildren === 0) {
	        return;
	      } else if (totalChildren > maxSize) {
	        totalChildren = maxSize;
	      }

	      var buffers = container._glBuffers[renderer.CONTEXT_UID];

	      if (!buffers) {
	        buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);
	      }

	      // if the uvs have not updated then no point rendering just yet!
	      this.renderer.setBlendMode(container.blendMode);

	      var gl = renderer.gl;

	      var m = container.worldTransform.copy(this.tempMatrix);

	      m.prepend(renderer._activeRenderTarget.projectionMatrix);

	      this.shader.uniforms.projectionMatrix = m.toArray(true);
	      this.shader.uniforms.uAlpha = container.worldAlpha;

	      // make sure the texture is bound..
	      var baseTexture = children[0]._texture.baseTexture;

	      this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);

	      // now lets upload and render the buffers..
	      for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
	        var amount = totalChildren - i;

	        if (amount > batchSize) {
	          amount = batchSize;
	        }

	        var buffer = buffers[j];

	        // we always upload the dynamic
	        buffer.uploadDynamic(children, i, amount);

	        // we only upload the static content when we have to!
	        if (container._bufferToUpdate === j) {
	          buffer.uploadStatic(children, i, amount);
	          container._bufferToUpdate = j + 1;
	        }

	        // bind the buffer
	        renderer.bindVao(buffer.vao);
	        buffer.vao.draw(gl.TRIANGLES, amount * 6);
	      }
	    }

	    /**
	     * Creates one particle buffer for each child in the container we want to render and updates internal properties
	     *
	     * @param {Tiny.ParticleContainer} container - The container to render using this ParticleRenderer
	     * @return {Tiny.ParticleBuffer[]} The buffers
	     */

	  }, {
	    key: 'generateBuffers',
	    value: function generateBuffers(container) {
	      var gl = this.renderer.gl;
	      var buffers = [];
	      var size = container._maxSize;
	      var batchSize = container._batchSize;
	      var dynamicPropertyFlags = container._properties;

	      for (var i = 0; i < size; i += batchSize) {
	        buffers.push(new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize));
	      }

	      return buffers;
	    }

	    /**
	     * Uploads the verticies.
	     *
	     * @param {Tiny.DisplayObject[]} children - the array of display objects to render
	     * @param {number} startIndex - the index to start from in the children array
	     * @param {number} amount - the amount of children that will have their vertices uploaded
	     * @param {number[]} array - The vertices to upload.
	     * @param {number} stride - Stride to use for iteration.
	     * @param {number} offset - Offset to start at.
	     */

	  }, {
	    key: 'uploadVertices',
	    value: function uploadVertices(children, startIndex, amount, array, stride, offset) {
	      var w0 = 0;
	      var w1 = 0;
	      var h0 = 0;
	      var h1 = 0;

	      for (var i = 0; i < amount; ++i) {
	        var sprite = children[startIndex + i];
	        var texture = sprite._texture;
	        var sx = sprite.scale.x;
	        var sy = sprite.scale.y;
	        var trim = texture.trim;
	        var orig = texture.orig;

	        if (trim) {
	          // if the sprite is trimmed and is not a tilingsprite then we need to add the
	          // extra space before transforming the sprite coords..
	          w1 = trim.x - sprite.anchor.x * orig.width;
	          w0 = w1 + trim.width;

	          h1 = trim.y - sprite.anchor.y * orig.height;
	          h0 = h1 + trim.height;
	        } else {
	          w0 = orig.width * (1 - sprite.anchor.x);
	          w1 = orig.width * -sprite.anchor.x;

	          h0 = orig.height * (1 - sprite.anchor.y);
	          h1 = orig.height * -sprite.anchor.y;
	        }

	        array[offset] = w1 * sx;
	        array[offset + 1] = h1 * sy;

	        array[offset + stride] = w0 * sx;
	        array[offset + stride + 1] = h1 * sy;

	        array[offset + stride * 2] = w0 * sx;
	        array[offset + stride * 2 + 1] = h0 * sy;

	        array[offset + stride * 3] = w1 * sx;
	        array[offset + stride * 3 + 1] = h0 * sy;

	        offset += stride * 4;
	      }
	    }

	    /**
	     *
	     * @param {Tiny.DisplayObject[]} children - the array of display objects to render
	     * @param {number} startIndex - the index to start from in the children array
	     * @param {number} amount - the amount of children that will have their positions uploaded
	     * @param {number[]} array - The vertices to upload.
	     * @param {number} stride - Stride to use for iteration.
	     * @param {number} offset - Offset to start at.
	     */

	  }, {
	    key: 'uploadPosition',
	    value: function uploadPosition(children, startIndex, amount, array, stride, offset) {
	      for (var i = 0; i < amount; i++) {
	        var spritePosition = children[startIndex + i].position;

	        array[offset] = spritePosition.x;
	        array[offset + 1] = spritePosition.y;

	        array[offset + stride] = spritePosition.x;
	        array[offset + stride + 1] = spritePosition.y;

	        array[offset + stride * 2] = spritePosition.x;
	        array[offset + stride * 2 + 1] = spritePosition.y;

	        array[offset + stride * 3] = spritePosition.x;
	        array[offset + stride * 3 + 1] = spritePosition.y;

	        offset += stride * 4;
	      }
	    }

	    /**
	     *
	     * @param {Tiny.DisplayObject[]} children - the array of display objects to render
	     * @param {number} startIndex - the index to start from in the children array
	     * @param {number} amount - the amount of children that will have their rotation uploaded
	     * @param {number[]} array - The vertices to upload.
	     * @param {number} stride - Stride to use for iteration.
	     * @param {number} offset - Offset to start at.
	     */

	  }, {
	    key: 'uploadRotation',
	    value: function uploadRotation(children, startIndex, amount, array, stride, offset) {
	      for (var i = 0; i < amount; i++) {
	        var spriteRotation = children[startIndex + i].rotation;

	        array[offset] = spriteRotation;
	        array[offset + stride] = spriteRotation;
	        array[offset + stride * 2] = spriteRotation;
	        array[offset + stride * 3] = spriteRotation;

	        offset += stride * 4;
	      }
	    }

	    /**
	     *
	     * @param {Tiny.DisplayObject[]} children - the array of display objects to render
	     * @param {number} startIndex - the index to start from in the children array
	     * @param {number} amount - the amount of children that will have their rotation uploaded
	     * @param {number[]} array - The vertices to upload.
	     * @param {number} stride - Stride to use for iteration.
	     * @param {number} offset - Offset to start at.
	     */

	  }, {
	    key: 'uploadUvs',
	    value: function uploadUvs(children, startIndex, amount, array, stride, offset) {
	      for (var i = 0; i < amount; ++i) {
	        var textureUvs = children[startIndex + i]._texture._uvs;

	        if (textureUvs) {
	          array[offset] = textureUvs.x0;
	          array[offset + 1] = textureUvs.y0;

	          array[offset + stride] = textureUvs.x1;
	          array[offset + stride + 1] = textureUvs.y1;

	          array[offset + stride * 2] = textureUvs.x2;
	          array[offset + stride * 2 + 1] = textureUvs.y2;

	          array[offset + stride * 3] = textureUvs.x3;
	          array[offset + stride * 3 + 1] = textureUvs.y3;

	          offset += stride * 4;
	        } else {
	          // TODO you know this can be easier!
	          array[offset] = 0;
	          array[offset + 1] = 0;

	          array[offset + stride] = 0;
	          array[offset + stride + 1] = 0;

	          array[offset + stride * 2] = 0;
	          array[offset + stride * 2 + 1] = 0;

	          array[offset + stride * 3] = 0;
	          array[offset + stride * 3 + 1] = 0;

	          offset += stride * 4;
	        }
	      }
	    }

	    /**
	     *
	     * @param {Tiny.DisplayObject[]} children - the array of display objects to render
	     * @param {number} startIndex - the index to start from in the children array
	     * @param {number} amount - the amount of children that will have their rotation uploaded
	     * @param {number[]} array - The vertices to upload.
	     * @param {number} stride - Stride to use for iteration.
	     * @param {number} offset - Offset to start at.
	     */

	  }, {
	    key: 'uploadAlpha',
	    value: function uploadAlpha(children, startIndex, amount, array, stride, offset) {
	      for (var i = 0; i < amount; i++) {
	        var spriteAlpha = children[startIndex + i].alpha;

	        array[offset] = spriteAlpha;
	        array[offset + stride] = spriteAlpha;
	        array[offset + stride * 2] = spriteAlpha;
	        array[offset + stride * 3] = spriteAlpha;

	        offset += stride * 4;
	      }
	    }

	    /**
	     * Destroys the ParticleRenderer.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this.renderer.gl) {
	        this.renderer.gl.deleteBuffer(this.indexBuffer);
	      }

	      _get(ParticleRenderer.prototype.__proto__ || Object.getPrototypeOf(ParticleRenderer.prototype), 'destroy', this).call(this);

	      this.shader.destroy();

	      this.indices = null;
	      this.tempMatrix = null;
	    }
	  }]);

	  return ParticleRenderer;
	}(core.ObjectRenderer);

	exports.default = ParticleRenderer;


	core.WebGLRenderer.registerPlugin('particle', ParticleRenderer);

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Shader2 = __webpack_require__(93);

	var _Shader3 = _interopRequireDefault(_Shader2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @class
	 * @extends Tiny.Shader
	 * @memberof Tiny
	 */
	var ParticleShader = function (_Shader) {
	  _inherits(ParticleShader, _Shader);

	  /**
	   * @param {Tiny.Shader} gl - The webgl shader manager this shader works for.
	   */
	  function ParticleShader(gl) {
	    _classCallCheck(this, ParticleShader);

	    return _possibleConstructorReturn(this, (ParticleShader.__proto__ || Object.getPrototypeOf(ParticleShader)).call(this, gl,
	    // vertex shader
	    ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute float aColor;', 'attribute vec2 aPositionCoord;', 'attribute vec2 aScale;', 'attribute float aRotation;', 'uniform mat3 projectionMatrix;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'void main(void){', '   vec2 v = aVertexPosition;', '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);', '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);', '   v = v + aPositionCoord;', '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = aColor;', '}'].join('\n'),
	    // hello
	    ['varying vec2 vTextureCoord;', 'varying float vColor;', 'uniform sampler2D uSampler;', 'uniform float uAlpha;', 'void main(void){', '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;', '  if (color.a == 0.0) discard;', '  gl_FragColor = color;', '}'].join('\n')));
	  }

	  return ParticleShader;
	}(_Shader3.default);

	exports.default = ParticleShader;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _pixiGlCore = __webpack_require__(28);

	var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

	var _createIndicesForQuads = __webpack_require__(92);

	var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that
	 * they now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's ParticleBuffer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
	 */

	/**
	 * The particle buffer manages the static and dynamic buffers for a particle container.
	 *
	 * @class
	 * @private
	 * @memberof Tiny
	 */
	var ParticleBuffer = function () {
	  /**
	   * @param {WebGLRenderingContext} gl - The rendering context.
	   * @param {object} properties - The properties to upload.
	   * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.
	   * @param {number} size - The size of the batch.
	   */
	  function ParticleBuffer(gl, properties, dynamicPropertyFlags, size) {
	    _classCallCheck(this, ParticleBuffer);

	    /**
	     * The current WebGL drawing context.
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;

	    /**
	     * Size of a single vertex.
	     *
	     * @member {number}
	     */
	    this.vertSize = 2;

	    /**
	     * Size of a single vertex in bytes.
	     *
	     * @member {number}
	     */
	    this.vertByteSize = this.vertSize * 4;

	    /**
	     * The number of particles the buffer can hold
	     *
	     * @member {number}
	     */
	    this.size = size;

	    /**
	     * A list of the properties that are dynamic.
	     *
	     * @member {object[]}
	     */
	    this.dynamicProperties = [];

	    /**
	     * A list of the properties that are static.
	     *
	     * @member {object[]}
	     */
	    this.staticProperties = [];

	    for (var i = 0; i < properties.length; ++i) {
	      var property = properties[i];

	      // Make copy of properties object so that when we edit the offset it doesn't
	      // change all other instances of the object literal
	      property = {
	        attribute: property.attribute,
	        size: property.size,
	        uploadFunction: property.uploadFunction,
	        offset: property.offset
	      };

	      if (dynamicPropertyFlags[i]) {
	        this.dynamicProperties.push(property);
	      } else {
	        this.staticProperties.push(property);
	      }
	    }

	    this.staticStride = 0;
	    this.staticBuffer = null;
	    this.staticData = null;

	    this.dynamicStride = 0;
	    this.dynamicBuffer = null;
	    this.dynamicData = null;

	    this.initBuffers();
	  }

	  /**
	   * Sets up the renderer context and necessary buffers.
	   *
	   * @private
	   */


	  _createClass(ParticleBuffer, [{
	    key: 'initBuffers',
	    value: function initBuffers() {
	      var gl = this.gl;
	      var dynamicOffset = 0;

	      /**
	       * Holds the indices of the geometry (quads) to draw
	       *
	       * @member {Uint16Array}
	       */
	      this.indices = (0, _createIndicesForQuads2.default)(this.size);
	      this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);

	      this.dynamicStride = 0;

	      for (var i = 0; i < this.dynamicProperties.length; ++i) {
	        var property = this.dynamicProperties[i];

	        property.offset = dynamicOffset;
	        dynamicOffset += property.size;
	        this.dynamicStride += property.size;
	      }

	      this.dynamicData = new Float32Array(this.size * this.dynamicStride * 4);
	      this.dynamicBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.dynamicData, gl.STREAM_DRAW);

	      // static //
	      var staticOffset = 0;

	      this.staticStride = 0;

	      for (var _i = 0; _i < this.staticProperties.length; ++_i) {
	        var _property = this.staticProperties[_i];

	        _property.offset = staticOffset;
	        staticOffset += _property.size;
	        this.staticStride += _property.size;
	      }

	      this.staticData = new Float32Array(this.size * this.staticStride * 4);
	      this.staticBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.staticData, gl.STATIC_DRAW);

	      this.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(this.indexBuffer);

	      for (var _i2 = 0; _i2 < this.dynamicProperties.length; ++_i2) {
	        var _property2 = this.dynamicProperties[_i2];

	        this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.FLOAT, false, this.dynamicStride * 4, _property2.offset * 4);
	      }

	      for (var _i3 = 0; _i3 < this.staticProperties.length; ++_i3) {
	        var _property3 = this.staticProperties[_i3];

	        this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.FLOAT, false, this.staticStride * 4, _property3.offset * 4);
	      }
	    }

	    /**
	     * Uploads the dynamic properties.
	     *
	     * @param {Tiny.DisplayObject[]} children - The children to upload.
	     * @param {number} startIndex - The index to start at.
	     * @param {number} amount - The number to upload.
	     */

	  }, {
	    key: 'uploadDynamic',
	    value: function uploadDynamic(children, startIndex, amount) {
	      for (var i = 0; i < this.dynamicProperties.length; i++) {
	        var property = this.dynamicProperties[i];

	        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
	      }

	      this.dynamicBuffer.upload();
	    }

	    /**
	     * Uploads the static properties.
	     *
	     * @param {Tiny.DisplayObject[]} children - The children to upload.
	     * @param {number} startIndex - The index to start at.
	     * @param {number} amount - The number to upload.
	     */

	  }, {
	    key: 'uploadStatic',
	    value: function uploadStatic(children, startIndex, amount) {
	      for (var i = 0; i < this.staticProperties.length; i++) {
	        var property = this.staticProperties[i];

	        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
	      }

	      this.staticBuffer.upload();
	    }

	    /**
	     * Destroys the ParticleBuffer.
	     *
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.dynamicProperties = null;
	      this.dynamicData = null;
	      this.dynamicBuffer.destroy();

	      this.staticProperties = null;
	      this.staticData = null;
	      this.staticBuffer.destroy();
	    }
	  }]);

	  return ParticleBuffer;
	}();

	exports.default = ParticleBuffer;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _utils = __webpack_require__(166);

	var _utils2 = _interopRequireDefault(_utils);

	var _AudioManager = __webpack_require__(167);

	var _AudioManager2 = _interopRequireDefault(_AudioManager);

	var _audioParser = __webpack_require__(169);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var audio = {
	  utils: _utils2.default,
	  AudioManager: _AudioManager2.default,
	  Audio: Audio,
	  audioParser: _audioParser.audioParser,
	  audioUrlParser: _audioParser.audioUrlParser
	};

	exports.default = audio;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _resourceLoader = __webpack_require__(131);

	var isHTMLAudioSupported = !!window.Audio;
	var webAudioContext = window.AudioContext || window.webkitAudioContext;
	var isWebAudioSupported = !!webAudioContext;
	var isAudioSupported = isWebAudioSupported || isHTMLAudioSupported;
	var isMp3Supported = false;
	var isOggSupported = false;
	var isWavSupported = false;
	var isM4aSupported = false;
	var createGainNode = null;
	var globalWebAudioContext = isWebAudioSupported ? new webAudioContext() : null; // eslint-disable-line

	if (isAudioSupported) {
	  var audio = document.createElement('audio');
	  isMp3Supported = audio.canPlayType('audio/mpeg;') !== '';
	  isOggSupported = audio.canPlayType('audio/ogg; codecs="vorbis"') !== '';
	  isWavSupported = audio.canPlayType('audio/wav') !== '';
	  isM4aSupported = audio.canPlayType('audio/mp4; codecs="mp4a.40.5"') !== '';

	  //Add some config to the pixi loader
	  if (isMp3Supported) _setAudioExt('mp3');
	  if (isOggSupported) _setAudioExt('ogg');
	  if (isWavSupported) _setAudioExt('wav');
	  if (isM4aSupported) _setAudioExt('m4a');

	  if (isWebAudioSupported) {
	    createGainNode = function createGainNode(ctx) {
	      return ctx.createGain ? ctx.createGain() : ctx.createGainNode();
	    };
	  }
	}

	function _setAudioExt(ext) {
	  if (isWebAudioSupported) {
	    // fixed
	    delete _resourceLoader.Resource._loadTypeMap['mp3'];
	    delete _resourceLoader.Resource._loadTypeMap['ogg'];
	    delete _resourceLoader.Resource._loadTypeMap['wav'];
	    _resourceLoader.Resource._xhrTypeMap['mp3'] = _resourceLoader.Resource.XHR_RESPONSE_TYPE.BUFFER;
	    _resourceLoader.Resource._xhrTypeMap['ogg'] = _resourceLoader.Resource.XHR_RESPONSE_TYPE.BUFFER;
	    _resourceLoader.Resource._xhrTypeMap['wav'] = _resourceLoader.Resource.XHR_RESPONSE_TYPE.BUFFER;
	    _resourceLoader.Resource.setExtensionXhrType(ext, _resourceLoader.Resource.XHR_RESPONSE_TYPE.BUFFER);
	  } else {
	    _resourceLoader.Resource.setExtensionLoadType(ext, _resourceLoader.Resource.LOAD_TYPE.AUDIO);
	  }
	}

	exports.default = {
	  isHTMLAudioSupported: isHTMLAudioSupported,
	  webAudioContext: webAudioContext,
	  isWebAudioSupported: isWebAudioSupported,
	  isAudioSupported: isAudioSupported,
	  isMp3Supported: isMp3Supported,
	  isOggSupported: isOggSupported,
	  isWavSupported: isWavSupported,
	  isM4aSupported: isM4aSupported,
	  globalWebAudioContext: globalWebAudioContext,
	  createGainNode: createGainNode
	};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _utils = __webpack_require__(166);

	var _utils2 = _interopRequireDefault(_utils);

	var _Audio = __webpack_require__(168);

	var _Audio2 = _interopRequireDefault(_Audio);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AudioManager = function () {
	  function AudioManager() {
	    _classCallCheck(this, AudioManager);

	    this.enabled = _utils2.default.isAudioSupported;
	    this.sounds = [];

	    if (_utils2.default.isWebAudioSupported) {
	      this.context = _utils2.default.globalWebAudioContext;
	      this.gainNode = _utils2.default.createGainNode(this.context);
	      this.gainNode.connect(this.context.destination);
	    }
	  }

	  _createClass(AudioManager, [{
	    key: 'getAudio',
	    value: function getAudio(name) {
	      var audio = new _Audio2.default(AudioManager.audios[name], this);
	      this.sounds.push(audio);
	      return audio;
	    }
	  }, {
	    key: 'removeAudio',
	    value: function removeAudio(audio) {
	      var index = this.sounds.indexOf(audio);
	      if (index !== -1) {
	        this.sounds.splice(index, 1);
	      }
	    }
	  }, {
	    key: 'filterAudios',
	    value: function filterAudios(id, value) {
	      var audios = [];
	      var len = this.sounds.length;
	      var emptyValue = typeof value === 'undefined';

	      for (var i = 0; i < len; i++) {
	        if (emptyValue && !!this.sounds[i][id] || !emptyValue && this.sounds[i][id] === value) {
	          audios.push(this.sounds[i]);
	        }
	      }

	      return audios;
	    }
	  }, {
	    key: 'pause',
	    value: function pause(value) {
	      value = value !== false;
	      var len = this.sounds.length;
	      for (var i = 0; i < len; i++) {
	        this.sounds[i].paused = value;
	      }
	    }
	  }, {
	    key: 'resume',
	    value: function resume() {
	      return this.pause(false);
	    }
	  }]);

	  return AudioManager;
	}();

	AudioManager.audios = {};

	exports.default = AudioManager;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _eventemitter = __webpack_require__(24);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _utils = __webpack_require__(166);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Audio = function (_EventEmitter) {
	  _inherits(Audio, _EventEmitter);

	  function Audio(data, manager) {
	    _classCallCheck(this, Audio);

	    var _this = _possibleConstructorReturn(this, (Audio.__proto__ || Object.getPrototypeOf(Audio)).call(this));

	    _this.manager = manager;
	    _this.data = data;

	    if (!_utils2.default.isWebAudioSupported) {
	      _this.audio = new window.Audio();
	      _this.audio.addEventListener('ended', _this._onEnd.bind(_this));
	    }
	    return _this;
	  }

	  _createClass(Audio, [{
	    key: 'play',
	    value: function play(pause) {
	      if (!pause && this.paused || !pause && this.playing) return this;
	      this.playing = true;
	      this.emit('play');

	      if (_utils2.default.isWebAudioSupported) {
	        this.audio = this.manager.context.createBufferSource();
	        this.audio.start = this.audio.start || this.audio.noteOn;
	        this.audio.stop = this.audio.stop || this.audio.noteOff;

	        this.audio.buffer = this.data;
	        this.audio.loop = this.loop;
	        this._startTime = this.manager.context.currentTime;

	        this.audio.onended = this._onEnd.bind(this);
	        this.audio.gainNode = _utils2.default.createGainNode(this.manager.context);
	        this.audio.gainNode.connect(this.manager.gainNode);

	        this.audio.connect(this.audio.gainNode);
	        this.audio.start(0, pause ? this._lastPauseTime : null);
	      } else {
	        this.audio.src = this.data.children[0].src;
	        this.audio.preload = 'auto';
	        this.audio.load();
	        this.audio.play();
	      }

	      return this;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      if (!this.playing) return this;

	      if (_utils2.default.isWebAudioSupported) {
	        this.audio.stop(0);
	      } else {
	        this.audio.pause();
	        this.audio.currentTime = 0;
	      }
	      this.playing = false;
	      this.emit('stop');

	      return this;
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this._startTime = 0;
	      this._lastPauseTime = 0;
	      this._offsetTime = 0;

	      this.playing = false;
	      //if(utils.isWebAudioSupported)this.audio = null;
	    }
	  }, {
	    key: 'remove',
	    value: function remove() {
	      this.manager.removeAudio(this);
	    }
	  }, {
	    key: '_onEnd',
	    value: function _onEnd() {
	      if (!_utils2.default.isWebAudioSupported) {
	        if (this.loop) {
	          this.audio.currentTime = 0;
	          this.audio.play();
	        } else {
	          this.reset();
	          this.emit('end');
	        }
	      } else {
	        if (!this.paused) {
	          this.reset();
	          this.emit('end');
	        }
	      }
	    }
	  }, {
	    key: 'paused',
	    get: function get() {
	      return this._paused;
	    },
	    set: function set(value) {
	      if (value === this._paused) return;
	      if (value) {
	        if (_utils2.default.isWebAudioSupported) {
	          this._offsetTime += this.manager.context.currentTime - this._startTime;
	          this._lastPauseTime = this._offsetTime % this.audio.buffer.duration;
	          if (this.audio) this.audio.stop(0);
	        } else {
	          if (this.audio) this.audio.pause();
	        }
	        this.emit('pause');
	      } else {
	        if (_utils2.default.isWebAudioSupported) {
	          this.play(true);
	        } else {
	          if (this.audio) this.audio.play();
	        }
	        this.emit('resume');
	      }
	      this._paused = value;
	    }
	  }, {
	    key: 'loop',
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(value) {
	      if (value === this._loop) return;
	      this._loop = value;
	      if (_utils2.default.isWebAudioSupported && this.audio) {
	        this.audio.loop = value;
	      }
	    }
	  }]);

	  return Audio;
	}(_eventemitter2.default);

	Audio._loop = false;
	Audio._paused = false;
	Audio._muted = false;
	Audio._startTime = 0;
	Audio._lastPauseTime = 0;
	Audio._offsetTime = 0;
	Audio.playing = false;

	exports.default = Audio;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.audioParser = audioParser;
	exports.audioUrlParser = audioUrlParser;

	var _core = __webpack_require__(6);

	var core = _interopRequireWildcard(_core);

	var _utils = __webpack_require__(166);

	var _utils2 = _interopRequireDefault(_utils);

	var _AudioManager = __webpack_require__(167);

	var _AudioManager2 = _interopRequireDefault(_AudioManager);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var _allowedExt = ['ogg', 'mp3'];
	var _mimeTypes = {
	  mp3: 'audio/mpeg',
	  mp4: 'audio/mp4',
	  ogg: 'audio/ogg; codecs="vorbis"',
	  m4a: 'audio/x-m4a',
	  wav: 'audio/wav; codecs="1"'
	};

	function audioParser() {
	  return function (resource, next) {
	    if (!_utils2.default.isAudioSupported || !resource.data) return next();

	    var ext = _getExt(resource.url);
	    if (_allowedExt.indexOf(ext) === -1 || !_canPlay(ext)) return next();

	    var name = resource.name || resource.url;
	    if (_utils2.default.isWebAudioSupported) {
	      _utils2.default.globalWebAudioContext.decodeAudioData(resource.data, function (buffer) {
	        _AudioManager2.default.audios[name] = buffer;
	        next();
	      });
	    } else {
	      _AudioManager2.default.audios[name] = resource.data;
	      return next();
	    }
	  };
	}

	function audioUrlParser(resourceUrl) {
	  var url = void 0;
	  for (var i = 0; i < resourceUrl.length; i++) {
	    var ext = _getExt(resourceUrl[i]);
	    if (_allowedExt.indexOf(ext) === -1) break;
	    if (_canPlay(ext)) {
	      url = resourceUrl[i];
	      break;
	    } else {
	      url = resourceUrl[i].replace(/\.[^\.\/\?\\]*(\?.*)?$/, '.' + _getCanPlayExtension()); // eslint-disable-line
	    }
	  }
	  console.log(url);

	  return url;
	}

	function _getExt(url) {
	  return url.split('?').shift().split('.').pop().toLowerCase();
	}

	function _canPlay(ext) {
	  var canPlay = false;
	  switch (ext) {
	    case 'm4a':
	      canPlay = _utils2.default.isM4aSupported;
	      break;
	    case 'mp3':
	      canPlay = _utils2.default.isMp3Supported;
	      break;
	    case 'ogg':
	      canPlay = _utils2.default.isOggSupported;
	      break;
	    case 'wav':
	      canPlay = _utils2.default.isWavSupported;
	      break;
	  }

	  return canPlay;
	}

	function _getCanPlayExtension() {
	  var audio = new Audio();
	  return core.detect(_allowedExt, function (extension) {
	    return audio.canPlayType(_mimeTypes[extension]) ? extension : null;
	  });
	}

/***/ })
/******/ ])
});
;